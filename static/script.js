(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/mapbox-gl/dist/mapbox-gl.js
  var require_mapbox_gl = __commonJS({
    "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.mapboxgl = factory());
      })(exports, function() {
        "use strict";
        var shared, worker, mapboxgl2;
        function define2(_, chunk) {
          if (!shared) {
            shared = chunk;
          } else if (!worker) {
            worker = chunk;
          } else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl2 = chunk(sharedChunk);
            if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
              mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
            }
          }
        }
        define2(["exports"], function(t) {
          "use strict";
          var e = "undefined" != typeof self ? self : {}, r = "2.14.1";
          let n;
          const i = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
            if (null == n) {
              const t2 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
              try {
                n = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t2;
              } catch (e2) {
                n = t2;
              }
            }
            return n;
          }, get API_TILEJSON_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
          }, get API_SPRITE_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
          }, get API_FONTS_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
          }, get API_STYLE_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
          }, get API_CDN_URL_REGEX() {
            return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
          }, get EVENTS_URL() {
            if (!i.API_URL)
              return null;
            try {
              const t2 = new URL(i.API_URL);
              return "api.mapbox.cn" === t2.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t2.hostname ? "https://events.mapbox.com/events/v2" : null;
            } catch (t2) {
              return null;
            }
          }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, s = { supported: false, testSupport: function(t2) {
            !l && o && (u ? c(t2) : a = t2);
          } };
          let a, o, l = false, u = false;
          function c(t2) {
            const e2 = t2.createTexture();
            t2.bindTexture(t2.TEXTURE_2D, e2);
            try {
              if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, o), t2.isContextLost())
                return;
              s.supported = true;
            } catch (t3) {
            }
            t2.deleteTexture(e2), l = true;
          }
          e.document && (o = e.document.createElement("img"), o.onload = function() {
            a && c(a), a = null, u = true;
          }, o.onerror = function() {
            l = true, a = null;
          }, o.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
          const h = "01";
          var p = f;
          function f(t2, e2, r2, n2) {
            this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
          }
          f.prototype = { sampleCurveX: function(t2) {
            return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
          }, sampleCurveY: function(t2) {
            return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
          }, sampleCurveDerivativeX: function(t2) {
            return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
          }, solveCurveX: function(t2, e2) {
            if (void 0 === e2 && (e2 = 1e-6), t2 < 0)
              return 0;
            if (t2 > 1)
              return 1;
            for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
              var i2 = this.sampleCurveX(r2) - t2;
              if (Math.abs(i2) < e2)
                return r2;
              var s2 = this.sampleCurveDerivativeX(r2);
              if (Math.abs(s2) < 1e-6)
                break;
              r2 -= i2 / s2;
            }
            var a2 = 0, o2 = 1;
            for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++)
              t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
            return r2;
          }, solve: function(t2, e2) {
            return this.sampleCurveY(this.solveCurveX(t2, e2));
          } };
          var d = y;
          function y(t2, e2) {
            this.x = t2, this.y = e2;
          }
          y.prototype = { clone: function() {
            return new y(this.x, this.y);
          }, add: function(t2) {
            return this.clone()._add(t2);
          }, sub: function(t2) {
            return this.clone()._sub(t2);
          }, multByPoint: function(t2) {
            return this.clone()._multByPoint(t2);
          }, divByPoint: function(t2) {
            return this.clone()._divByPoint(t2);
          }, mult: function(t2) {
            return this.clone()._mult(t2);
          }, div: function(t2) {
            return this.clone()._div(t2);
          }, rotate: function(t2) {
            return this.clone()._rotate(t2);
          }, rotateAround: function(t2, e2) {
            return this.clone()._rotateAround(t2, e2);
          }, matMult: function(t2) {
            return this.clone()._matMult(t2);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(t2) {
            return this.x === t2.x && this.y === t2.y;
          }, dist: function(t2) {
            return Math.sqrt(this.distSqr(t2));
          }, distSqr: function(t2) {
            var e2 = t2.x - this.x, r2 = t2.y - this.y;
            return e2 * e2 + r2 * r2;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(t2) {
            return Math.atan2(this.y - t2.y, this.x - t2.x);
          }, angleWith: function(t2) {
            return this.angleWithSep(t2.x, t2.y);
          }, angleWithSep: function(t2, e2) {
            return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
          }, _matMult: function(t2) {
            var e2 = t2[2] * this.x + t2[3] * this.y;
            return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
          }, _add: function(t2) {
            return this.x += t2.x, this.y += t2.y, this;
          }, _sub: function(t2) {
            return this.x -= t2.x, this.y -= t2.y, this;
          }, _mult: function(t2) {
            return this.x *= t2, this.y *= t2, this;
          }, _div: function(t2) {
            return this.x /= t2, this.y /= t2, this;
          }, _multByPoint: function(t2) {
            return this.x *= t2.x, this.y *= t2.y, this;
          }, _divByPoint: function(t2) {
            return this.x /= t2.x, this.y /= t2.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var t2 = this.y;
            return this.y = this.x, this.x = -t2, this;
          }, _rotate: function(t2) {
            var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
            return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
          }, _rotateAround: function(t2, e2) {
            var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
            return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, y.convert = function(t2) {
            return t2 instanceof y ? t2 : Array.isArray(t2) ? new y(t2[0], t2[1]) : t2;
          };
          const m = Math.PI / 180, g = 180 / Math.PI;
          function x(t2) {
            return t2 * m;
          }
          function v(t2) {
            return t2 * g;
          }
          const b = [[0, 0], [1, 0], [1, 1], [0, 1]];
          function w(t2) {
            if (t2 <= 0)
              return 0;
            if (t2 >= 1)
              return 1;
            const e2 = t2 * t2, r2 = e2 * t2;
            return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e2) + r2 - 0.75);
          }
          function _(t2, e2, r2, n2) {
            const i2 = new p(t2, e2, r2, n2);
            return function(t3) {
              return i2.solve(t3);
            };
          }
          const A = _(0.25, 0.1, 0.25, 1);
          function S(t2, e2, r2) {
            return Math.min(r2, Math.max(e2, t2));
          }
          function k(t2, e2, r2) {
            return (r2 = S((r2 - t2) / (e2 - t2), 0, 1)) * r2 * (3 - 2 * r2);
          }
          function I(t2, e2, r2) {
            const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
            return i2 === e2 ? r2 : i2;
          }
          function M(t2, e2, r2) {
            if (!t2.length)
              return r2(null, []);
            let n2 = t2.length;
            const i2 = new Array(t2.length);
            let s2 = null;
            t2.forEach((t3, a2) => {
              e2(t3, (t4, e3) => {
                t4 && (s2 = t4), i2[a2] = e3, 0 == --n2 && r2(s2, i2);
              });
            });
          }
          function T(t2) {
            const e2 = [];
            for (const r2 in t2)
              e2.push(t2[r2]);
            return e2;
          }
          function z(t2, ...e2) {
            for (const r2 of e2)
              for (const e3 in r2)
                t2[e3] = r2[e3];
            return t2;
          }
          let B = 1;
          function E() {
            return B++;
          }
          function C() {
            return function t2(e2) {
              return e2 ? (e2 ^ Math.random() * (16 >> e2 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
            }();
          }
          function P(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
          }
          function D(t2) {
            return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
          }
          function V(t2, e2) {
            t2.forEach((t3) => {
              e2[t3] && (e2[t3] = e2[t3].bind(e2));
            });
          }
          function L(t2, e2) {
            return -1 !== t2.indexOf(e2, t2.length - e2.length);
          }
          function F(t2, e2, r2) {
            const n2 = {};
            for (const i2 in t2)
              n2[i2] = e2.call(r2 || this, t2[i2], i2, t2);
            return n2;
          }
          function R(t2, e2, r2) {
            const n2 = {};
            for (const i2 in t2)
              e2.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
            return n2;
          }
          function j(t2) {
            return Array.isArray(t2) ? t2.map(j) : "object" == typeof t2 && t2 ? F(t2, j) : t2;
          }
          const $ = {};
          function U(t2) {
            $[t2] || ("undefined" != typeof console && console.warn(t2), $[t2] = true);
          }
          function O(t2, e2, r2) {
            return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
          }
          function q(t2) {
            let e2 = 0;
            for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
              r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
            return e2;
          }
          function N() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
          }
          function G(t2) {
            const e2 = {};
            if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
              const s2 = n2 || i2;
              return e2[r2] = !s2 || s2.toLowerCase(), "";
            }), e2["max-age"]) {
              const t3 = parseInt(e2["max-age"], 10);
              isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
            }
            return e2;
          }
          let Z = null;
          function X(t2) {
            if (null == Z) {
              const e2 = t2.navigator ? t2.navigator.userAgent : null;
              Z = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
            }
            return Z;
          }
          function K(t2) {
            try {
              const r2 = e[t2];
              return r2.setItem("_mapbox_test_", 1), r2.removeItem("_mapbox_test_"), true;
            } catch (t3) {
              return false;
            }
          }
          function Y(t2, e2) {
            return [t2[4 * e2], t2[4 * e2 + 1], t2[4 * e2 + 2], t2[4 * e2 + 3]];
          }
          const H = "mapbox-tiles";
          let W, J, Q = 500, tt = 50;
          function et() {
            try {
              return e.caches;
            } catch (t2) {
            }
          }
          function rt() {
            et() && !W && (W = e.caches.open(H));
          }
          function nt(t2) {
            const e2 = t2.indexOf("?");
            if (e2 < 0)
              return t2;
            const r2 = function(t3) {
              const e3 = t3.indexOf("?");
              return e3 > 0 ? t3.slice(e3 + 1).split("&") : [];
            }(t2), n2 = r2.filter((t3) => {
              const e3 = t3.split("=");
              return "language" === e3[0] || "worldview" === e3[0];
            });
            return n2.length ? `${t2.slice(0, e2)}?${n2.join("&")}` : t2.slice(0, e2);
          }
          let it = 1 / 0;
          const st = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
          "function" == typeof Object.freeze && Object.freeze(st);
          class at extends Error {
            constructor(t2, e2, r2) {
              401 === e2 && gt(r2) && (t2 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t2), this.status = e2, this.url = r2;
            }
            toString() {
              return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
          }
          const ot = N() ? () => self.worker && self.worker.referrer : () => ("blob:" === e.location.protocol ? e.parent : e).location.href;
          const lt = function(t2, r2) {
            if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(ot()) && !/^\w+:/.test(n2))) {
              if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal"))
                return function(t3, r3) {
                  const n3 = new e.AbortController(), i2 = new e.Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: ot(), referrerPolicy: t3.referrerPolicy, signal: n3.signal });
                  let s2 = false, a2 = false;
                  const o2 = (l2 = i2.url).indexOf("sku=") > 0 && gt(l2);
                  var l2;
                  "json" === t3.type && i2.headers.set("Accept", "application/json");
                  const u2 = (n4, s3, l3) => {
                    if (a2)
                      return;
                    if (n4 && "SecurityError" !== n4.message && U(n4), s3 && l3)
                      return c2(s3);
                    const u3 = Date.now();
                    e.fetch(i2).then((e2) => {
                      if (e2.ok) {
                        const t4 = o2 ? e2.clone() : null;
                        return c2(e2, t4, u3);
                      }
                      return r3(new at(e2.statusText, e2.status, t3.url));
                    }).catch((e2) => {
                      "AbortError" !== e2.name && r3(new Error(`${e2.message} ${t3.url}`));
                    });
                  }, c2 = (n4, o3, l3) => {
                    ("arrayBuffer" === t3.type ? n4.arrayBuffer() : "json" === t3.type ? n4.json() : n4.text()).then((t4) => {
                      a2 || (o3 && l3 && function(t5, r4, n5) {
                        if (rt(), !W)
                          return;
                        const i3 = { status: r4.status, statusText: r4.statusText, headers: new e.Headers() };
                        r4.headers.forEach((t6, e2) => i3.headers.set(e2, t6));
                        const s3 = G(r4.headers.get("Cache-Control") || "");
                        if (s3["no-store"])
                          return;
                        s3["max-age"] && i3.headers.set("Expires", new Date(n5 + 1e3 * s3["max-age"]).toUTCString());
                        const a3 = i3.headers.get("Expires");
                        a3 && (new Date(a3).getTime() - n5 < 42e4 || function(t6, e2) {
                          if (void 0 === J)
                            try {
                              new Response(new ReadableStream()), J = true;
                            } catch (t7) {
                              J = false;
                            }
                          J ? e2(t6.body) : t6.blob().then(e2);
                        }(r4, (r5) => {
                          const n6 = new e.Response(r5, i3);
                          rt(), W && W.then((e2) => e2.put(nt(t5.url), n6)).catch((t6) => U(t6.message));
                        }));
                      }(i2, o3, l3), s2 = true, r3(null, t4, n4.headers.get("Cache-Control"), n4.headers.get("Expires")));
                    }).catch((t4) => {
                      a2 || r3(new Error(t4.message));
                    });
                  };
                  return o2 ? function(t4, e2) {
                    if (rt(), !W)
                      return e2(null);
                    const r4 = nt(t4.url);
                    W.then((t5) => {
                      t5.match(r4).then((n4) => {
                        const i3 = function(t6) {
                          if (!t6)
                            return false;
                          const e3 = new Date(t6.headers.get("Expires") || 0), r5 = G(t6.headers.get("Cache-Control") || "");
                          return e3 > Date.now() && !r5["no-cache"];
                        }(n4);
                        t5.delete(r4), i3 && t5.put(r4, n4.clone()), e2(null, n4, i3);
                      }).catch(e2);
                    }).catch(e2);
                  }(i2, u2) : u2(null, null), { cancel: () => {
                    a2 = true, s2 || n3.abort();
                  } };
                }(t2, r2);
              if (N() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t2, r2, void 0, true);
            }
            var n2;
            return function(t3, r3) {
              const n3 = new e.XMLHttpRequest();
              n3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (n3.responseType = "arraybuffer");
              for (const e2 in t3.headers)
                n3.setRequestHeader(e2, t3.headers[e2]);
              return "json" === t3.type && (n3.responseType = "text", n3.setRequestHeader("Accept", "application/json")), n3.withCredentials = "include" === t3.credentials, n3.onerror = () => {
                r3(new Error(n3.statusText));
              }, n3.onload = () => {
                if ((n3.status >= 200 && n3.status < 300 || 0 === n3.status) && null !== n3.response) {
                  let e2 = n3.response;
                  if ("json" === t3.type)
                    try {
                      e2 = JSON.parse(n3.response);
                    } catch (t4) {
                      return r3(t4);
                    }
                  r3(null, e2, n3.getResponseHeader("Cache-Control"), n3.getResponseHeader("Expires"));
                } else
                  r3(new at(n3.statusText, n3.status, t3.url));
              }, n3.send(t3.body), { cancel: () => n3.abort() };
            }(t2, r2);
          }, ut = function(t2, e2) {
            return lt(z(t2, { type: "arrayBuffer" }), e2);
          };
          function ct(t2) {
            const r2 = e.document.createElement("a");
            return r2.href = t2, r2.protocol === e.document.location.protocol && r2.host === e.document.location.host;
          }
          const ht = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          let pt, ft;
          pt = [], ft = 0;
          const dt = function(t2, r2) {
            if (s.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), ft >= i.MAX_PARALLEL_IMAGE_REQUESTS) {
              const e2 = { requestParameters: t2, callback: r2, cancelled: false, cancel() {
                this.cancelled = true;
              } };
              return pt.push(e2), e2;
            }
            ft++;
            let n2 = false;
            const a2 = () => {
              if (!n2)
                for (n2 = true, ft--; pt.length && ft < i.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                  const t3 = pt.shift(), { requestParameters: e2, callback: r3, cancelled: n3 } = t3;
                  n3 || (t3.cancel = dt(e2, r3).cancel);
                }
            }, o2 = ut(t2, (t3, n3, i2, s2) => {
              a2(), t3 ? r2(t3) : n3 && (e.createImageBitmap ? function(t4, r3) {
                const n4 = new e.Blob([new Uint8Array(t4)], { type: "image/png" });
                e.createImageBitmap(n4).then((t5) => {
                  r3(null, t5);
                }).catch((t5) => {
                  r3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                });
              }(n3, (t4, e2) => r2(t4, e2, i2, s2)) : function(t4, r3) {
                const n4 = new e.Image(), i3 = e.URL;
                n4.onload = () => {
                  r3(null, n4), i3.revokeObjectURL(n4.src), n4.onload = null, e.requestAnimationFrame(() => {
                    n4.src = ht;
                  });
                }, n4.onerror = () => r3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                const s3 = new e.Blob([new Uint8Array(t4)], { type: "image/png" });
                n4.src = t4.byteLength ? i3.createObjectURL(s3) : ht;
              }(n3, (t4, e2) => r2(t4, e2, i2, s2)));
            });
            return { cancel: () => {
              o2.cancel(), a2();
            } };
          }, yt = "NO_ACCESS_TOKEN";
          function mt(t2) {
            return 0 === t2.indexOf("mapbox:");
          }
          function gt(t2) {
            return i.API_URL_REGEX.test(t2);
          }
          function xt(t2) {
            return i.API_CDN_URL_REGEX.test(t2);
          }
          function vt(t2) {
            return i.API_STYLE_REGEX.test(t2) && !bt(t2);
          }
          function bt(t2) {
            return i.API_SPRITE_REGEX.test(t2);
          }
          const wt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
          function _t(t2) {
            const e2 = t2.match(wt);
            if (!e2)
              throw new Error("Unable to parse URL object");
            return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
          }
          function At(t2) {
            const e2 = t2.params.length ? `?${t2.params.join("&")}` : "";
            return `${t2.protocol}://${t2.authority}${t2.path}${e2}`;
          }
          function St(t2) {
            if (!t2)
              return null;
            const r2 = t2.split(".");
            if (!r2 || 3 !== r2.length)
              return null;
            try {
              return JSON.parse(decodeURIComponent(e.atob(r2[1]).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join("")));
            } catch (t3) {
              return null;
            }
          }
          class kt {
            constructor(t2) {
              this.type = t2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t2) {
              const r2 = St(i.ACCESS_TOKEN);
              let n2 = "";
              return n2 = r2 && r2.u ? e.btoa(encodeURIComponent(r2.u).replace(/%([0-9A-F]{2})/g, (t3, e2) => String.fromCharCode(Number("0x" + e2)))) : i.ACCESS_TOKEN || "", t2 ? `mapbox.eventData.${t2}:${n2}` : `mapbox.eventData:${n2}`;
            }
            fetchEventData() {
              const t2 = K("localStorage"), r2 = this.getStorageKey(), n2 = this.getStorageKey("uuid");
              if (t2)
                try {
                  const t3 = e.localStorage.getItem(r2);
                  t3 && (this.eventData = JSON.parse(t3));
                  const i2 = e.localStorage.getItem(n2);
                  i2 && (this.anonId = i2);
                } catch (t3) {
                  U("Unable to read from LocalStorage");
                }
            }
            saveEventData() {
              const t2 = K("localStorage"), r2 = this.getStorageKey(), n2 = this.getStorageKey("uuid");
              if (t2)
                try {
                  e.localStorage.setItem(n2, this.anonId), Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(r2, JSON.stringify(this.eventData));
                } catch (t3) {
                  U("Unable to write to LocalStorage");
                }
            }
            processRequests(t2) {
            }
            postEvent(t2, e2, r2, n2) {
              if (!i.EVENTS_URL)
                return;
              const s2 = _t(i.EVENTS_URL);
              s2.params.push(`access_token=${n2 || i.ACCESS_TOKEN || ""}`);
              const a2 = { event: this.type, created: new Date(t2).toISOString() }, o2 = e2 ? z(a2, e2) : a2, l2 = { url: At(s2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o2]) };
              this.pendingRequest = function(t3, e3) {
                return lt(z(t3, { method: "POST" }), e3);
              }(l2, (t3) => {
                this.pendingRequest = null, r2(t3), this.saveEventData(), this.processRequests(n2);
              });
            }
            queueRequest(t2, e2) {
              this.queue.push(t2), this.processRequests(e2);
            }
          }
          const It = new class extends kt {
            constructor(t2) {
              super("appUserTurnstile"), this._customAccessToken = t2;
            }
            postTurnstileEvent(t2, e2) {
              i.EVENTS_URL && i.ACCESS_TOKEN && Array.isArray(t2) && t2.some((t3) => mt(t3) || gt(t3)) && this.queueRequest(Date.now(), e2);
            }
            processRequests(t2) {
              if (this.pendingRequest || 0 === this.queue.length)
                return;
              this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
              const e2 = St(i.ACCESS_TOKEN), n2 = e2 ? e2.u : i.ACCESS_TOKEN;
              let s2 = n2 !== this.eventData.tokenU;
              D(this.anonId) || (this.anonId = C(), s2 = true);
              const a2 = this.queue.shift();
              if (this.eventData.lastSuccess) {
                const t3 = new Date(this.eventData.lastSuccess), e3 = new Date(a2), r2 = (a2 - this.eventData.lastSuccess) / 864e5;
                s2 = s2 || r2 >= 1 || r2 < -1 || t3.getDate() !== e3.getDate();
              } else
                s2 = true;
              s2 ? this.postEvent(a2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r, skuId: h, "enabled.telemetry": false, userId: this.anonId }, (t3) => {
                t3 || (this.eventData.lastSuccess = a2, this.eventData.tokenU = n2);
              }, t2) : this.processRequests();
            }
          }(), Mt = It.postTurnstileEvent.bind(It), Tt = new class extends kt {
            constructor() {
              super("map.load"), this.success = {}, this.skuToken = "";
            }
            postMapLoadEvent(t2, e2, r2, n2) {
              this.skuToken = e2, this.errorCb = n2, i.EVENTS_URL && (r2 || i.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r2) : this.errorCb(new Error(yt)));
            }
            processRequests(t2) {
              if (this.pendingRequest || 0 === this.queue.length)
                return;
              const { id: e2, timestamp: n2 } = this.queue.shift();
              e2 && this.success[e2] || (this.anonId || this.fetchEventData(), D(this.anonId) || (this.anonId = C()), this.postEvent(n2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r, skuId: h, skuToken: this.skuToken, userId: this.anonId }, (t3) => {
                t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
              }, t2));
            }
          }(), zt = Tt.postMapLoadEvent.bind(Tt), Bt = new class extends kt {
            constructor() {
              super("gljs.performance");
            }
            postPerformanceEvent(t2, e2) {
              i.EVENTS_URL && (t2 || i.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: e2 }, t2);
            }
            processRequests(t2) {
              if (this.pendingRequest || 0 === this.queue.length)
                return;
              const { timestamp: n2, performanceData: i2 } = this.queue.shift(), s2 = function(t3) {
                const n3 = e.performance.getEntriesByType("resource"), i3 = e.performance.getEntriesByType("mark"), s3 = function(t4) {
                  const e2 = {};
                  if (t4) {
                    for (const r2 in t4)
                      if ("other" !== r2)
                        for (const n4 of t4[r2]) {
                          const t5 = `${r2}ResolveRangeMin`, i4 = `${r2}ResolveRangeMax`, s4 = `${r2}RequestCount`, a3 = `${r2}RequestCachedCount`;
                          e2[t5] = Math.min(e2[t5] || 1 / 0, n4.startTime), e2[i4] = Math.max(e2[i4] || -1 / 0, n4.responseEnd);
                          const o3 = (t6) => {
                            void 0 === e2[t6] && (e2[t6] = 0), ++e2[t6];
                          };
                          void 0 !== n4.transferSize && 0 === n4.transferSize && o3(a3), o3(s4);
                        }
                  }
                  return e2;
                }(function(t4, e2) {
                  const r2 = {};
                  if (t4)
                    for (const n4 of t4) {
                      const t5 = e2(n4);
                      void 0 === r2[t5] && (r2[t5] = []), r2[t5].push(n4);
                    }
                  return r2;
                }(n3, Ft)), a2 = e.devicePixelRatio, o2 = e.navigator.connection || e.navigator.mozConnection || e.navigator.webkitConnection, l2 = { counters: [], metadata: [], attributes: [] }, u2 = (t4, e2, r2) => {
                  null != r2 && t4.push({ name: e2, value: r2.toString() });
                };
                for (const t4 in s3)
                  u2(l2.counters, t4, s3[t4]);
                if (t3.interactionRange[0] !== 1 / 0 && t3.interactionRange[1] !== -1 / 0 && (u2(l2.counters, "interactionRangeMin", t3.interactionRange[0]), u2(l2.counters, "interactionRangeMax", t3.interactionRange[1])), i3)
                  for (const t4 of Object.keys(Vt)) {
                    const e2 = Vt[t4], r2 = i3.find((t5) => t5.name === e2);
                    r2 && u2(l2.counters, e2, r2.startTime);
                  }
                return u2(l2.counters, "visibilityHidden", t3.visibilityHidden), u2(l2.attributes, "style", function(t4) {
                  if (t4)
                    for (const e2 of t4) {
                      const t5 = e2.name.split("?")[0];
                      if (vt(t5)) {
                        const e3 = t5.split("/").slice(-2);
                        if (2 === e3.length)
                          return `mapbox://styles/${e3[0]}/${e3[1]}`;
                      }
                    }
                }(n3)), u2(l2.attributes, "terrainEnabled", t3.terrainEnabled ? "true" : "false"), u2(l2.attributes, "fogEnabled", t3.fogEnabled ? "true" : "false"), u2(l2.attributes, "projection", t3.projection), u2(l2.attributes, "zoom", t3.zoom), u2(l2.metadata, "devicePixelRatio", a2), u2(l2.metadata, "connectionEffectiveType", o2 ? o2.effectiveType : void 0), u2(l2.metadata, "navigatorUserAgent", e.navigator.userAgent), u2(l2.metadata, "screenWidth", e.screen.width), u2(l2.metadata, "screenHeight", e.screen.height), u2(l2.metadata, "windowWidth", e.innerWidth), u2(l2.metadata, "windowHeight", e.innerHeight), u2(l2.metadata, "mapWidth", t3.width / a2), u2(l2.metadata, "mapHeight", t3.height / a2), u2(l2.metadata, "webglRenderer", t3.renderer), u2(l2.metadata, "webglVendor", t3.vendor), u2(l2.metadata, "sdkVersion", r), u2(l2.metadata, "sdkIdentifier", "mapbox-gl-js"), l2;
              }(i2);
              for (const t3 of s2.metadata)
                ;
              for (const t3 of s2.counters)
                ;
              for (const t3 of s2.attributes)
                ;
              this.postEvent(n2, s2, () => {
              }, t2);
            }
          }(), Et = Bt.postPerformanceEvent.bind(Bt), Ct = new class extends kt {
            constructor() {
              super("map.auth"), this.success = {}, this.skuToken = "";
            }
            getSession(t2, e2, r2, n2) {
              if (!i.API_URL || !i.SESSION_PATH)
                return;
              const s2 = _t(i.API_URL + i.SESSION_PATH);
              s2.params.push(`sku=${e2 || ""}`), s2.params.push(`access_token=${n2 || i.ACCESS_TOKEN || ""}`);
              const a2 = { url: At(s2), headers: { "Content-Type": "text/plain" } };
              this.pendingRequest = function(t3, e3) {
                return lt(z(t3, { method: "GET" }), e3);
              }(a2, (t3) => {
                this.pendingRequest = null, r2(t3), this.saveEventData(), this.processRequests(n2);
              });
            }
            getSessionAPI(t2, e2, r2, n2) {
              this.skuToken = e2, this.errorCb = n2, i.SESSION_PATH && i.API_URL && (r2 || i.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r2) : this.errorCb(new Error(yt)));
            }
            processRequests(t2) {
              if (this.pendingRequest || 0 === this.queue.length)
                return;
              const { id: e2, timestamp: r2 } = this.queue.shift();
              e2 && this.success[e2] || this.getSession(r2, this.skuToken, (t3) => {
                t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
              }, t2);
            }
          }(), Pt = Ct.getSessionAPI.bind(Ct), Dt = /* @__PURE__ */ new Set(), Vt = { create: "create", load: "load", fullLoad: "fullLoad" }, Lt = { mark(t2) {
            e.performance.mark(t2);
          }, measure(t2, r2, n2) {
            e.performance.measure(t2, r2, n2);
          } };
          function Ft(t2) {
            const e2 = t2.name.split("?")[0];
            return xt(e2) && e2.includes("mapbox-gl.js") ? "javascript" : xt(e2) && e2.includes("mapbox-gl.css") ? "css" : function(t3) {
              return i.API_FONTS_REGEX.test(t3);
            }(e2) ? "fontRange" : bt(e2) ? "sprite" : vt(e2) ? "style" : function(t3) {
              return i.API_TILEJSON_REGEX.test(t3);
            }(e2) ? "tilejson" : "other";
          }
          const Rt = e.performance;
          function jt(t2) {
            const e2 = t2 ? t2.url.toString() : void 0;
            return Rt.getEntriesByName(e2);
          }
          let $t, Ut, Ot, qt;
          const Nt = { now: () => void 0 !== Ot ? Ot : e.performance.now(), setNow(t2) {
            Ot = t2;
          }, restoreNow() {
            Ot = void 0;
          }, frame(t2) {
            const r2 = e.requestAnimationFrame(t2);
            return { cancel: () => e.cancelAnimationFrame(r2) };
          }, getImageData(t2, r2 = 0) {
            const { width: n2, height: i2 } = t2;
            qt || (qt = e.document.createElement("canvas"));
            const s2 = qt.getContext("2d", { willReadFrequently: true });
            if (!s2)
              throw new Error("failed to create canvas 2d context");
            return (n2 > qt.width || i2 > qt.height) && (qt.width = n2, qt.height = i2), s2.clearRect(-r2, -r2, n2 + 2 * r2, i2 + 2 * r2), s2.drawImage(t2, 0, 0, n2, i2), s2.getImageData(-r2, -r2, n2 + 2 * r2, i2 + 2 * r2);
          }, resolveURL: (t2) => ($t || ($t = e.document.createElement("a")), $t.href = t2, $t.href), get devicePixelRatio() {
            return e.devicePixelRatio;
          }, get prefersReducedMotion() {
            return !!e.matchMedia && (null == Ut && (Ut = e.matchMedia("(prefers-reduced-motion: reduce)")), Ut.matches);
          } };
          function Gt(t2, e2, r2) {
            r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
          }
          function Zt(t2, e2, r2) {
            if (r2 && r2[t2]) {
              const n2 = r2[t2].indexOf(e2);
              -1 !== n2 && r2[t2].splice(n2, 1);
            }
          }
          class Xt {
            constructor(t2, e2 = {}) {
              z(this, e2), this.type = t2;
            }
          }
          class Kt extends Xt {
            constructor(t2, e2 = {}) {
              super("error", z({ error: t2 }, e2));
            }
          }
          class Yt {
            on(t2, e2) {
              return this._listeners = this._listeners || {}, Gt(t2, e2, this._listeners), this;
            }
            off(t2, e2) {
              return Zt(t2, e2, this._listeners), Zt(t2, e2, this._oneTimeListeners), this;
            }
            once(t2, e2) {
              return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Gt(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
            }
            fire(t2, e2) {
              "string" == typeof t2 && (t2 = new Xt(t2, e2 || {}));
              const r2 = t2.type;
              if (this.listens(r2)) {
                t2.target = this;
                const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
                for (const r3 of e3)
                  r3.call(this, t2);
                const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
                for (const e4 of n2)
                  Zt(r2, e4, this._oneTimeListeners), e4.call(this, t2);
                const i2 = this._eventedParent;
                i2 && (z(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
              } else
                t2 instanceof Kt && console.error(t2.error);
              return this;
            }
            listens(t2) {
              return !!(this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2));
            }
            setEventedParent(t2, e2) {
              return this._eventedParent = t2, this._eventedParentData = e2, this;
            }
          }
          var Ht = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
          function Wt(t2, ...e2) {
            for (const r2 of e2)
              for (const e3 in r2)
                t2[e3] = r2[e3];
            return t2;
          }
          function Jt(t2) {
            return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
          }
          function Qt(t2) {
            if (Array.isArray(t2))
              return t2.map(Qt);
            if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
              const e2 = {};
              for (const r2 in t2)
                e2[r2] = Qt(t2[r2]);
              return e2;
            }
            return Jt(t2);
          }
          class te extends Error {
            constructor(t2, e2) {
              super(e2), this.message = e2, this.key = t2;
            }
          }
          var ee = te;
          class re {
            constructor(t2, e2 = []) {
              this.parent = t2, this.bindings = {};
              for (const [t3, r2] of e2)
                this.bindings[t3] = r2;
            }
            concat(t2) {
              return new re(this, t2);
            }
            get(t2) {
              if (this.bindings[t2])
                return this.bindings[t2];
              if (this.parent)
                return this.parent.get(t2);
              throw new Error(`${t2} not found in scope.`);
            }
            has(t2) {
              return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
            }
          }
          var ne = re;
          const ie = { kind: "null" }, se = { kind: "number" }, ae = { kind: "string" }, oe = { kind: "boolean" }, le = { kind: "color" }, ue = { kind: "object" }, ce = { kind: "value" }, he = { kind: "collator" }, pe = { kind: "formatted" }, fe = { kind: "resolvedImage" };
          function de(t2, e2) {
            return { kind: "array", itemType: t2, N: e2 };
          }
          function ye(t2) {
            if ("array" === t2.kind) {
              const e2 = ye(t2.itemType);
              return "number" == typeof t2.N ? `array<${e2}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e2}>`;
            }
            return t2.kind;
          }
          const me = [ie, se, ae, oe, le, pe, ue, de(ce), fe];
          function ge(t2, e2) {
            if ("error" === e2.kind)
              return null;
            if ("array" === t2.kind) {
              if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !ge(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N))
                return null;
            } else {
              if (t2.kind === e2.kind)
                return null;
              if ("value" === t2.kind) {
                for (const t3 of me)
                  if (!ge(t3, e2))
                    return null;
              }
            }
            return `Expected ${ye(t2)} but found ${ye(e2)} instead.`;
          }
          function xe(t2, e2) {
            return e2.some((e3) => e3.kind === t2.kind);
          }
          function ve(t2, e2) {
            return e2.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
          }
          var be, we = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
          function _e(t2) {
            return (t2 = Math.round(t2)) < 0 ? 0 : t2 > 255 ? 255 : t2;
          }
          function Ae(t2) {
            return _e("%" === t2[t2.length - 1] ? parseFloat(t2) / 100 * 255 : parseInt(t2));
          }
          function Se(t2) {
            return (e2 = "%" === t2[t2.length - 1] ? parseFloat(t2) / 100 : parseFloat(t2)) < 0 ? 0 : e2 > 1 ? 1 : e2;
            var e2;
          }
          function ke(t2, e2, r2) {
            return r2 < 0 ? r2 += 1 : r2 > 1 && (r2 -= 1), 6 * r2 < 1 ? t2 + (e2 - t2) * r2 * 6 : 2 * r2 < 1 ? e2 : 3 * r2 < 2 ? t2 + (e2 - t2) * (2 / 3 - r2) * 6 : t2;
          }
          try {
            be = {}.parseCSSColor = function(t2) {
              var e2, r2 = t2.replace(/ /g, "").toLowerCase();
              if (r2 in we)
                return we[r2].slice();
              if ("#" === r2[0])
                return 4 === r2.length ? (e2 = parseInt(r2.substr(1), 16)) >= 0 && e2 <= 4095 ? [(3840 & e2) >> 4 | (3840 & e2) >> 8, 240 & e2 | (240 & e2) >> 4, 15 & e2 | (15 & e2) << 4, 1] : null : 7 === r2.length && (e2 = parseInt(r2.substr(1), 16)) >= 0 && e2 <= 16777215 ? [(16711680 & e2) >> 16, (65280 & e2) >> 8, 255 & e2, 1] : null;
              var n2 = r2.indexOf("("), i2 = r2.indexOf(")");
              if (-1 !== n2 && i2 + 1 === r2.length) {
                var s2 = r2.substr(0, n2), a2 = r2.substr(n2 + 1, i2 - (n2 + 1)).split(","), o2 = 1;
                switch (s2) {
                  case "rgba":
                    if (4 !== a2.length)
                      return null;
                    o2 = Se(a2.pop());
                  case "rgb":
                    return 3 !== a2.length ? null : [Ae(a2[0]), Ae(a2[1]), Ae(a2[2]), o2];
                  case "hsla":
                    if (4 !== a2.length)
                      return null;
                    o2 = Se(a2.pop());
                  case "hsl":
                    if (3 !== a2.length)
                      return null;
                    var l2 = (parseFloat(a2[0]) % 360 + 360) % 360 / 360, u2 = Se(a2[1]), c2 = Se(a2[2]), h2 = c2 <= 0.5 ? c2 * (u2 + 1) : c2 + u2 - c2 * u2, p2 = 2 * c2 - h2;
                    return [_e(255 * ke(p2, h2, l2 + 1 / 3)), _e(255 * ke(p2, h2, l2)), _e(255 * ke(p2, h2, l2 - 1 / 3)), o2];
                  default:
                    return null;
                }
              }
              return null;
            };
          } catch (t2) {
          }
          class Ie {
            constructor(t2, e2, r2, n2 = 1) {
              this.r = t2, this.g = e2, this.b = r2, this.a = n2;
            }
            static parse(t2) {
              if (!t2)
                return;
              if (t2 instanceof Ie)
                return t2;
              if ("string" != typeof t2)
                return;
              const e2 = be(t2);
              return e2 ? new Ie(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
            }
            toString() {
              const [t2, e2, r2, n2] = this.toArray();
              return `rgba(${Math.round(t2)},${Math.round(e2)},${Math.round(r2)},${n2})`;
            }
            toArray() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return 0 === n2 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e2 / n2, 255 * r2 / n2, n2];
            }
            toArray01() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return 0 === n2 ? [0, 0, 0, 0] : [t2 / n2, e2 / n2, r2 / n2, n2];
            }
            toArray01PremultipliedAlpha() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return [t2, e2, r2, n2];
            }
          }
          Ie.black = new Ie(0, 0, 0, 1), Ie.white = new Ie(1, 1, 1, 1), Ie.transparent = new Ie(0, 0, 0, 0), Ie.red = new Ie(1, 0, 0, 1), Ie.blue = new Ie(0, 0, 1, 1);
          var Me = Ie;
          class Te {
            constructor(t2, e2, r2) {
              this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }
            compare(t2, e2) {
              return this.collator.compare(t2, e2);
            }
            resolvedLocale() {
              return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
          }
          class ze {
            constructor(t2, e2, r2, n2, i2) {
              this.text = t2.normalize ? t2.normalize() : t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
            }
          }
          class Be {
            constructor(t2) {
              this.sections = t2;
            }
            static fromString(t2) {
              return new Be([new ze(t2, null, null, null, null)]);
            }
            isEmpty() {
              return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length);
            }
            static factory(t2) {
              return t2 instanceof Be ? t2 : Be.fromString(t2);
            }
            toString() {
              return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
            }
            serialize() {
              const t2 = ["format"];
              for (const e2 of this.sections) {
                if (e2.image) {
                  t2.push(["image", e2.image.name]);
                  continue;
                }
                t2.push(e2.text);
                const r2 = {};
                e2.fontStack && (r2["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r2["font-scale"] = e2.scale), e2.textColor && (r2["text-color"] = ["rgba"].concat(e2.textColor.toArray())), t2.push(r2);
              }
              return t2;
            }
          }
          class Ee {
            constructor(t2) {
              this.name = t2.name, this.available = t2.available;
            }
            toString() {
              return this.name;
            }
            static fromString(t2) {
              return t2 ? new Ee({ name: t2, available: false }) : null;
            }
            serialize() {
              return ["image", this.name];
            }
          }
          function Ce(t2, e2, r2, n2) {
            return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
          }
          function Pe(t2) {
            if (null === t2)
              return true;
            if ("string" == typeof t2)
              return true;
            if ("boolean" == typeof t2)
              return true;
            if ("number" == typeof t2)
              return true;
            if (t2 instanceof Me)
              return true;
            if (t2 instanceof Te)
              return true;
            if (t2 instanceof Be)
              return true;
            if (t2 instanceof Ee)
              return true;
            if (Array.isArray(t2)) {
              for (const e2 of t2)
                if (!Pe(e2))
                  return false;
              return true;
            }
            if ("object" == typeof t2) {
              for (const e2 in t2)
                if (!Pe(t2[e2]))
                  return false;
              return true;
            }
            return false;
          }
          function De(t2) {
            if (null === t2)
              return ie;
            if ("string" == typeof t2)
              return ae;
            if ("boolean" == typeof t2)
              return oe;
            if ("number" == typeof t2)
              return se;
            if (t2 instanceof Me)
              return le;
            if (t2 instanceof Te)
              return he;
            if (t2 instanceof Be)
              return pe;
            if (t2 instanceof Ee)
              return fe;
            if (Array.isArray(t2)) {
              const e2 = t2.length;
              let r2;
              for (const e3 of t2) {
                const t3 = De(e3);
                if (r2) {
                  if (r2 === t3)
                    continue;
                  r2 = ce;
                  break;
                }
                r2 = t3;
              }
              return de(r2 || ce, e2);
            }
            return ue;
          }
          function Ve(t2) {
            const e2 = typeof t2;
            return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof Me || t2 instanceof Be || t2 instanceof Ee ? t2.toString() : JSON.stringify(t2);
          }
          class Le {
            constructor(t2, e2) {
              this.type = t2, this.value = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length)
                return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (!Pe(t2[1]))
                return e2.error("invalid value");
              const r2 = t2[1];
              let n2 = De(r2);
              const i2 = e2.expectedType;
              return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new Le(n2, r2);
            }
            evaluate() {
              return this.value;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Me ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Be ? this.value.serialize() : this.value;
            }
          }
          var Fe = Le, Re = class {
            constructor(t2) {
              this.name = "ExpressionEvaluationError", this.message = t2;
            }
            toJSON() {
              return this.message;
            }
          };
          const je = { string: ae, number: se, boolean: oe, object: ue };
          class $e {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              let r2, n2 = 1;
              const i2 = t2[0];
              if ("array" === i2) {
                let i3, s3;
                if (t2.length > 2) {
                  const r3 = t2[1];
                  if ("string" != typeof r3 || !(r3 in je) || "object" === r3)
                    return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                  i3 = je[r3], n2++;
                } else
                  i3 = ce;
                if (t2.length > 3) {
                  if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                    return e2.error('The length argument to "array" must be a positive integer literal', 2);
                  s3 = t2[2], n2++;
                }
                r2 = de(i3, s3);
              } else
                r2 = je[i2];
              const s2 = [];
              for (; n2 < t2.length; n2++) {
                const r3 = e2.parse(t2[n2], n2, ce);
                if (!r3)
                  return null;
                s2.push(r3);
              }
              return new $e(r2, s2);
            }
            evaluate(t2) {
              for (let e2 = 0; e2 < this.args.length; e2++) {
                const r2 = this.args[e2].evaluate(t2);
                if (!ge(this.type, De(r2)))
                  return r2;
                if (e2 === this.args.length - 1)
                  throw new Re(`Expected value to be of type ${ye(this.type)}, but found ${ye(De(r2))} instead.`);
              }
              return null;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = this.type, e2 = [t2.kind];
              if ("array" === t2.kind) {
                const r2 = t2.itemType;
                if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
                  e2.push(r2.kind);
                  const n2 = t2.N;
                  ("number" == typeof n2 || this.args.length > 1) && e2.push(n2);
                }
              }
              return e2.concat(this.args.map((t3) => t3.serialize()));
            }
          }
          var Ue = $e;
          class Oe {
            constructor(t2) {
              this.type = pe, this.sections = t2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              const r2 = t2[1];
              if (!Array.isArray(r2) && "object" == typeof r2)
                return e2.error("First argument must be an image or text section.");
              const n2 = [];
              let i2 = false;
              for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
                const s2 = t2[r3];
                if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
                  i2 = false;
                  let t3 = null;
                  if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, se), !t3))
                    return null;
                  let r4 = null;
                  if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, de(ae)), !r4))
                    return null;
                  let a2 = null;
                  if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, le), !a2))
                    return null;
                  const o2 = n2[n2.length - 1];
                  o2.scale = t3, o2.font = r4, o2.textColor = a2;
                } else {
                  const s3 = e2.parse(t2[r3], 1, ce);
                  if (!s3)
                    return null;
                  const a2 = s3.type.kind;
                  if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2)
                    return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                  i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
                }
              }
              return new Oe(n2);
            }
            evaluate(t2) {
              return new Be(this.sections.map((e2) => {
                const r2 = e2.content.evaluate(t2);
                return De(r2) === fe ? new ze("", r2, null, null, null) : new ze(Ve(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
              }));
            }
            eachChild(t2) {
              for (const e2 of this.sections)
                t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["format"];
              for (const e2 of this.sections) {
                t2.push(e2.content.serialize());
                const r2 = {};
                e2.scale && (r2["font-scale"] = e2.scale.serialize()), e2.font && (r2["text-font"] = e2.font.serialize()), e2.textColor && (r2["text-color"] = e2.textColor.serialize()), t2.push(r2);
              }
              return t2;
            }
          }
          class qe {
            constructor(t2) {
              this.type = fe, this.input = t2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length)
                return e2.error("Expected two arguments.");
              const r2 = e2.parse(t2[1], 1, ae);
              return r2 ? new qe(r2) : e2.error("No image name provided.");
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2), r2 = Ee.fromString(e2);
              return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["image", this.input.serialize()];
            }
          }
          const Ne = { "to-boolean": oe, "to-color": le, "to-number": se, "to-string": ae };
          class Ge {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              const r2 = t2[0];
              if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
                return e2.error("Expected one argument.");
              const n2 = Ne[r2], i2 = [];
              for (let r3 = 1; r3 < t2.length; r3++) {
                const n3 = e2.parse(t2[r3], r3, ce);
                if (!n3)
                  return null;
                i2.push(n3);
              }
              return new Ge(n2, i2);
            }
            evaluate(t2) {
              if ("boolean" === this.type.kind)
                return Boolean(this.args[0].evaluate(t2));
              if ("color" === this.type.kind) {
                let e2, r2;
                for (const n2 of this.args) {
                  if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof Me)
                    return e2;
                  if ("string" == typeof e2) {
                    const r3 = t2.parseColor(e2);
                    if (r3)
                      return r3;
                  } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Ce(e2[0], e2[1], e2[2], e2[3]), !r2))
                    return new Me(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                }
                throw new Re(r2 || `Could not parse color from value '${"string" == typeof e2 ? e2 : String(JSON.stringify(e2))}'`);
              }
              if ("number" === this.type.kind) {
                let e2 = null;
                for (const r2 of this.args) {
                  if (e2 = r2.evaluate(t2), null === e2)
                    return 0;
                  const n2 = Number(e2);
                  if (!isNaN(n2))
                    return n2;
                }
                throw new Re(`Could not convert ${JSON.stringify(e2)} to number.`);
              }
              return "formatted" === this.type.kind ? Be.fromString(Ve(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? Ee.fromString(Ve(this.args[0].evaluate(t2))) : Ve(this.args[0].evaluate(t2));
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              if ("formatted" === this.type.kind)
                return new Oe([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
              if ("resolvedImage" === this.type.kind)
                return new qe(this.args[0]).serialize();
              const t2 = [`to-${this.type.kind}`];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          var Ze = Ge;
          const Xe = ["Unknown", "Point", "LineString", "Polygon"];
          var Ke = class {
            constructor() {
              this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
            }
            id() {
              return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
            }
            geometryType() {
              return this.feature ? "number" == typeof this.feature.type ? Xe[this.feature.type] : this.feature.type : null;
            }
            geometry() {
              return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return this.feature && this.feature.properties || {};
            }
            distanceFromCenter() {
              if (this.featureTileCoord && this.featureDistanceData) {
                const t2 = this.featureDistanceData.center, e2 = this.featureDistanceData.scale, { x: r2, y: n2 } = this.featureTileCoord;
                return this.featureDistanceData.bearing[0] * (r2 * e2 - t2[0]) + this.featureDistanceData.bearing[1] * (n2 * e2 - t2[1]);
              }
              return 0;
            }
            parseColor(t2) {
              let e2 = this._parseColorCache[t2];
              return e2 || (e2 = this._parseColorCache[t2] = Me.parse(t2)), e2;
            }
          };
          class Ye {
            constructor(t2, e2, r2, n2) {
              this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
            }
            evaluate(t2) {
              return this._evaluate(t2, this.args);
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return [this.name].concat(this.args.map((t2) => t2.serialize()));
            }
            static parse(t2, e2) {
              const r2 = t2[0], n2 = Ye.definitions[r2];
              if (!n2)
                return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
              let o2 = null;
              for (const [n3, s3] of a2) {
                o2 = new _r(e2.registry, e2.path, null, e2.scope);
                const a3 = [];
                let l2 = false;
                for (let e3 = 1; e3 < t2.length; e3++) {
                  const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
                  if (!s4) {
                    l2 = true;
                    break;
                  }
                  a3.push(s4);
                }
                if (!l2)
                  if (Array.isArray(n3) && n3.length !== a3.length)
                    o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
                  else {
                    for (let t3 = 0; t3 < a3.length; t3++) {
                      const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                      o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                    }
                    if (0 === o2.errors.length)
                      return new Ye(r2, i2, s3, a3);
                  }
              }
              if (1 === a2.length)
                e2.errors.push(...o2.errors);
              else {
                const r3 = (a2.length ? a2 : s2).map(([t3]) => {
                  return e3 = t3, Array.isArray(e3) ? `(${e3.map(ye).join(", ")})` : `(${ye(e3.type)}...)`;
                  var e3;
                }).join(" | "), n3 = [];
                for (let r4 = 1; r4 < t2.length; r4++) {
                  const i3 = e2.parse(t2[r4], 1 + n3.length);
                  if (!i3)
                    return null;
                  n3.push(ye(i3.type));
                }
                e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
              }
              return null;
            }
            static register(t2, e2) {
              Ye.definitions = e2;
              for (const r2 in e2)
                t2[r2] = Ye;
            }
          }
          var He = Ye;
          class We {
            constructor(t2, e2, r2) {
              this.type = he, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length)
                return e2.error("Expected one argument.");
              const r2 = t2[1];
              if ("object" != typeof r2 || Array.isArray(r2))
                return e2.error("Collator options argument must be an object.");
              const n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, oe);
              if (!n2)
                return null;
              const i2 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, oe);
              if (!i2)
                return null;
              let s2 = null;
              return r2.locale && (s2 = e2.parse(r2.locale, 1, ae), !s2) ? null : new We(n2, i2, s2);
            }
            evaluate(t2) {
              return new Te(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
            }
            eachChild(t2) {
              t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = {};
              return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
            }
          }
          const Je = 8192;
          function Qe(t2, e2) {
            t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
          }
          function tr(t2, e2) {
            return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
          }
          function er(t2, e2) {
            const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
            return [Math.round(r2 * i2 * Je), Math.round(n2 * i2 * Je)];
          }
          function rr(t2, e2, r2) {
            const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
            return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
          }
          function nr(t2, e2) {
            let r2 = false;
            for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
              const o3 = e2[a2];
              for (let e3 = 0, a3 = o3.length; e3 < a3 - 1; e3++) {
                if (rr(t2, o3[e3], o3[e3 + 1]))
                  return false;
                (i2 = o3[e3])[1] > (n2 = t2)[1] != (s2 = o3[e3 + 1])[1] > n2[1] && n2[0] < (s2[0] - i2[0]) * (n2[1] - i2[1]) / (s2[1] - i2[1]) + i2[0] && (r2 = !r2);
              }
            }
            var n2, i2, s2;
            return r2;
          }
          function ir(t2, e2) {
            for (let r2 = 0; r2 < e2.length; r2++)
              if (nr(t2, e2[r2]))
                return true;
            return false;
          }
          function sr(t2, e2, r2, n2) {
            const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
            return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
          }
          function ar(t2, e2, r2) {
            for (const u2 of r2)
              for (let r3 = 0; r3 < u2.length - 1; ++r3)
                if (0 != (o2 = [(a2 = u2[r3 + 1])[0] - (s2 = u2[r3])[0], a2[1] - s2[1]])[0] * (l2 = [(i2 = e2)[0] - (n2 = t2)[0], i2[1] - n2[1]])[1] - o2[1] * l2[0] && sr(n2, i2, s2, a2) && sr(s2, a2, n2, i2))
                  return true;
            var n2, i2, s2, a2, o2, l2;
            return false;
          }
          function or(t2, e2) {
            for (let r2 = 0; r2 < t2.length; ++r2)
              if (!nr(t2[r2], e2))
                return false;
            for (let r2 = 0; r2 < t2.length - 1; ++r2)
              if (ar(t2[r2], t2[r2 + 1], e2))
                return false;
            return true;
          }
          function lr(t2, e2) {
            for (let r2 = 0; r2 < e2.length; r2++)
              if (or(t2, e2[r2]))
                return true;
            return false;
          }
          function ur(t2, e2, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = [];
              for (let n3 = 0; n3 < t2[i2].length; n3++) {
                const a2 = er(t2[i2][n3], r2);
                Qe(e2, a2), s2.push(a2);
              }
              n2.push(s2);
            }
            return n2;
          }
          function cr(t2, e2, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = ur(t2[i2], e2, r2);
              n2.push(s2);
            }
            return n2;
          }
          function hr(t2, e2, r2, n2) {
            if (t2[0] < r2[0] || t2[0] > r2[2]) {
              const e3 = 0.5 * n2;
              let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
              0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
            }
            Qe(e2, t2);
          }
          function pr(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z) * Je, s2 = [n2.x * Je, n2.y * Je], a2 = [];
            if (!t2)
              return a2;
            for (const n3 of t2)
              for (const t3 of n3) {
                const n4 = [t3.x + s2[0], t3.y + s2[1]];
                hr(n4, e2, r2, i2), a2.push(n4);
              }
            return a2;
          }
          function fr(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z) * Je, s2 = [n2.x * Je, n2.y * Je], a2 = [];
            if (!t2)
              return a2;
            for (const r3 of t2) {
              const t3 = [];
              for (const n3 of r3) {
                const r4 = [n3.x + s2[0], n3.y + s2[1]];
                Qe(e2, r4), t3.push(r4);
              }
              a2.push(t3);
            }
            if (e2[2] - e2[0] <= i2 / 2) {
              (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
              for (const t3 of a2)
                for (const n3 of t3)
                  hr(n3, e2, r2, i2);
            }
            var o2;
            return a2;
          }
          class dr {
            constructor(t2, e2) {
              this.type = oe, this.geojson = t2, this.geometries = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length)
                return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (Pe(t2[1])) {
                const e3 = t2[1];
                if ("FeatureCollection" === e3.type)
                  for (let t3 = 0; t3 < e3.features.length; ++t3) {
                    const r2 = e3.features[t3].geometry.type;
                    if ("Polygon" === r2 || "MultiPolygon" === r2)
                      return new dr(e3, e3.features[t3].geometry);
                  }
                else if ("Feature" === e3.type) {
                  const t3 = e3.geometry.type;
                  if ("Polygon" === t3 || "MultiPolygon" === t3)
                    return new dr(e3, e3.geometry);
                } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type)
                  return new dr(e3, e3);
              }
              return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t2) {
              if (null != t2.geometry() && null != t2.canonicalID()) {
                if ("Point" === t2.geometryType())
                  return function(t3, e2) {
                    const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                    if (!i2)
                      return false;
                    if ("Polygon" === e2.type) {
                      const s2 = ur(e2.coordinates, n2, i2), a2 = pr(t3.geometry(), r2, n2, i2);
                      if (!tr(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!nr(t4, s2))
                          return false;
                    }
                    if ("MultiPolygon" === e2.type) {
                      const s2 = cr(e2.coordinates, n2, i2), a2 = pr(t3.geometry(), r2, n2, i2);
                      if (!tr(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!ir(t4, s2))
                          return false;
                    }
                    return true;
                  }(t2, this.geometries);
                if ("LineString" === t2.geometryType())
                  return function(t3, e2) {
                    const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                    if (!i2)
                      return false;
                    if ("Polygon" === e2.type) {
                      const s2 = ur(e2.coordinates, n2, i2), a2 = fr(t3.geometry(), r2, n2, i2);
                      if (!tr(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!or(t4, s2))
                          return false;
                    }
                    if ("MultiPolygon" === e2.type) {
                      const s2 = cr(e2.coordinates, n2, i2), a2 = fr(t3.geometry(), r2, n2, i2);
                      if (!tr(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!lr(t4, s2))
                          return false;
                    }
                    return true;
                  }(t2, this.geometries);
              }
              return false;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["within", this.geojson];
            }
          }
          var yr = dr;
          function mr(t2) {
            if (t2 instanceof He) {
              if ("get" === t2.name && 1 === t2.args.length)
                return false;
              if ("feature-state" === t2.name)
                return false;
              if ("has" === t2.name && 1 === t2.args.length)
                return false;
              if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
                return false;
              if (/^filter-/.test(t2.name))
                return false;
            }
            if (t2 instanceof yr)
              return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !mr(t3) && (e2 = false);
            }), e2;
          }
          function gr(t2) {
            if (t2 instanceof He && "feature-state" === t2.name)
              return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !gr(t3) && (e2 = false);
            }), e2;
          }
          function xr(t2, e2) {
            if (t2 instanceof He && e2.indexOf(t2.name) >= 0)
              return false;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 && !xr(t3, e2) && (r2 = false);
            }), r2;
          }
          class vr {
            constructor(t2, e2) {
              this.type = e2.type, this.name = t2, this.boundExpression = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length || "string" != typeof t2[1])
                return e2.error("'var' expression requires exactly one string literal argument.");
              const r2 = t2[1];
              return e2.scope.has(r2) ? new vr(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t2) {
              return this.boundExpression.evaluate(t2);
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["var", this.name];
            }
          }
          var br = vr;
          class wr {
            constructor(t2, e2 = [], r2, n2 = new ne(), i2 = []) {
              this.registry = t2, this.path = e2, this.key = e2.map((t3) => `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2;
            }
            parse(t2, e2, r2, n2, i2 = {}) {
              return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
            }
            _parse(t2, e2) {
              function r2(t3, e3, r3) {
                return "assert" === r3 ? new Ue(e3, [t3]) : "coerce" === r3 ? new Ze(e3, [t3]) : t3;
              }
              if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
                if (0 === t2.length)
                  return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                const n2 = t2[0];
                if ("string" != typeof n2)
                  return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                const i2 = this.registry[n2];
                if (i2) {
                  let n3 = i2.parse(t2, this);
                  if (!n3)
                    return null;
                  if (this.expectedType) {
                    const t3 = this.expectedType, i3 = n3.type;
                    if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== i3.kind)
                      if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== i3.kind && "string" !== i3.kind) {
                        if (this.checkSubtype(t3, i3))
                          return null;
                      } else
                        n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                    else
                      n3 = r2(n3, t3, e2.typeAnnotation || "assert");
                  }
                  if (!(n3 instanceof Fe) && "resolvedImage" !== n3.type.kind && Ar(n3)) {
                    const t3 = new Ke();
                    try {
                      n3 = new Fe(n3.type, n3.evaluate(t3));
                    } catch (t4) {
                      return this.error(t4.message), null;
                    }
                  }
                  return n3;
                }
                return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              }
              return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
            }
            concat(t2, e2, r2) {
              const n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
              return new wr(this.registry, n2, e2 || null, i2, this.errors);
            }
            error(t2, ...e2) {
              const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
              this.errors.push(new ee(r2, t2));
            }
            checkSubtype(t2, e2) {
              const r2 = ge(t2, e2);
              return r2 && this.error(r2), r2;
            }
          }
          var _r = wr;
          function Ar(t2) {
            if (t2 instanceof br)
              return Ar(t2.boundExpression);
            if (t2 instanceof He && "error" === t2.name)
              return false;
            if (t2 instanceof We)
              return false;
            if (t2 instanceof yr)
              return false;
            const e2 = t2 instanceof Ze || t2 instanceof Ue;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 = e2 ? r2 && Ar(t3) : r2 && t3 instanceof Fe;
            }), !!r2 && mr(t2) && xr(t2, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
          }
          function Sr(t2, e2) {
            const r2 = t2.length - 1;
            let n2, i2, s2 = 0, a2 = r2, o2 = 0;
            for (; s2 <= a2; )
              if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
                if (o2 === r2 || e2 < i2)
                  return o2;
                s2 = o2 + 1;
              } else {
                if (!(n2 > e2))
                  throw new Re("Input is not a number.");
                a2 = o2 - 1;
              }
            return 0;
          }
          class kr {
            constructor(t2, e2, r2) {
              this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of r2)
                this.labels.push(t3), this.outputs.push(e3);
            }
            static parse(t2, e2) {
              if (t2.length - 1 < 4)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0)
                return e2.error("Expected an even number of arguments.");
              const r2 = e2.parse(t2[1], 1, se);
              if (!r2)
                return null;
              const n2 = [];
              let i2 = null;
              e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
              for (let r3 = 1; r3 < t2.length; r3 += 2) {
                const s2 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
                if ("number" != typeof s2)
                  return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
                if (n2.length && n2[n2.length - 1][0] >= s2)
                  return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
                const u2 = e2.parse(a2, l2, i2);
                if (!u2)
                  return null;
                i2 = i2 || u2.type, n2.push([s2, u2]);
              }
              return new kr(i2, r2, n2);
            }
            evaluate(t2) {
              const e2 = this.labels, r2 = this.outputs;
              if (1 === e2.length)
                return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0])
                return r2[0].evaluate(t2);
              const i2 = e2.length;
              return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[Sr(e2, n2)].evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs)
                t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = ["step", this.input.serialize()];
              for (let e2 = 0; e2 < this.labels.length; e2++)
                e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
              return t2;
            }
          }
          var Ir = kr;
          function Mr(t2, e2, r2) {
            return t2 * (1 - r2) + e2 * r2;
          }
          var Tr = Object.freeze({ __proto__: null, number: Mr, color: function(t2, e2, r2) {
            return new Me(Mr(t2.r, e2.r, r2), Mr(t2.g, e2.g, r2), Mr(t2.b, e2.b, r2), Mr(t2.a, e2.a, r2));
          }, array: function(t2, e2, r2) {
            return t2.map((t3, n2) => Mr(t3, e2[n2], r2));
          } });
          const zr = 0.95047, Br = 1.08883, Er = 4 / 29, Cr = 6 / 29, Pr = 3 * Cr * Cr, Dr = Math.PI / 180, Vr = 180 / Math.PI;
          function Lr(t2) {
            return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / Pr + Er;
          }
          function Fr(t2) {
            return t2 > Cr ? t2 * t2 * t2 : Pr * (t2 - Er);
          }
          function Rr(t2) {
            return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
          }
          function jr(t2) {
            return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
          }
          function $r(t2) {
            const e2 = jr(t2.r), r2 = jr(t2.g), n2 = jr(t2.b), i2 = Lr((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / zr), s2 = Lr((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
            return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - Lr((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / Br)), alpha: t2.a };
          }
          function Ur(t2) {
            let e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
            return e2 = 1 * Fr(e2), r2 = zr * Fr(r2), n2 = Br * Fr(n2), new Me(Rr(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), Rr(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), Rr(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
          }
          function Or(t2, e2, r2) {
            const n2 = e2 - t2;
            return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
          }
          const qr = { forward: $r, reverse: Ur, interpolate: function(t2, e2, r2) {
            return { l: Mr(t2.l, e2.l, r2), a: Mr(t2.a, e2.a, r2), b: Mr(t2.b, e2.b, r2), alpha: Mr(t2.alpha, e2.alpha, r2) };
          } }, Nr = { forward: function(t2) {
            const { l: e2, a: r2, b: n2 } = $r(t2), i2 = Math.atan2(n2, r2) * Vr;
            return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e2, alpha: t2.a };
          }, reverse: function(t2) {
            const e2 = t2.h * Dr, r2 = t2.c;
            return Ur({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
          }, interpolate: function(t2, e2, r2) {
            return { h: Or(t2.h, e2.h, r2), c: Mr(t2.c, e2.c, r2), l: Mr(t2.l, e2.l, r2), alpha: Mr(t2.alpha, e2.alpha, r2) };
          } };
          var Gr = Object.freeze({ __proto__: null, lab: qr, hcl: Nr });
          class Zr {
            constructor(t2, e2, r2, n2, i2) {
              this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of i2)
                this.labels.push(t3), this.outputs.push(e3);
            }
            static interpolationFactor(t2, e2, r2, n2) {
              let i2 = 0;
              if ("exponential" === t2.name)
                i2 = Xr(e2, t2.base, r2, n2);
              else if ("linear" === t2.name)
                i2 = Xr(e2, 1, r2, n2);
              else if ("cubic-bezier" === t2.name) {
                const s2 = t2.controlPoints;
                i2 = new p(s2[0], s2[1], s2[2], s2[3]).solve(Xr(e2, 1, r2, n2));
              }
              return i2;
            }
            static parse(t2, e2) {
              let [r2, n2, i2, ...s2] = t2;
              if (!Array.isArray(n2) || 0 === n2.length)
                return e2.error("Expected an interpolation type expression.", 1);
              if ("linear" === n2[0])
                n2 = { name: "linear" };
              else if ("exponential" === n2[0]) {
                const t3 = n2[1];
                if ("number" != typeof t3)
                  return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
                n2 = { name: "exponential", base: t3 };
              } else {
                if ("cubic-bezier" !== n2[0])
                  return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
                {
                  const t3 = n2.slice(1);
                  if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1))
                    return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                  n2 = { name: "cubic-bezier", controlPoints: t3 };
                }
              }
              if (t2.length - 1 < 4)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0)
                return e2.error("Expected an even number of arguments.");
              if (i2 = e2.parse(i2, 2, se), !i2)
                return null;
              const a2 = [];
              let o2 = null;
              "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = le : e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType);
              for (let t3 = 0; t3 < s2.length; t3 += 2) {
                const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
                if ("number" != typeof r3)
                  return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
                if (a2.length && a2[a2.length - 1][0] >= r3)
                  return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
                const u2 = e2.parse(n3, l2, o2);
                if (!u2)
                  return null;
                o2 = o2 || u2.type, a2.push([r3, u2]);
              }
              return "number" === o2.kind || "color" === o2.kind || "array" === o2.kind && "number" === o2.itemType.kind && "number" == typeof o2.N ? new Zr(o2, r2, n2, i2, a2) : e2.error(`Type ${ye(o2)} is not interpolatable.`);
            }
            evaluate(t2) {
              const e2 = this.labels, r2 = this.outputs;
              if (1 === e2.length)
                return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0])
                return r2[0].evaluate(t2);
              const i2 = e2.length;
              if (n2 >= e2[i2 - 1])
                return r2[i2 - 1].evaluate(t2);
              const s2 = Sr(e2, n2), a2 = Zr.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
              return "interpolate" === this.operator ? Tr[this.type.kind.toLowerCase()](o2, l2, a2) : "interpolate-hcl" === this.operator ? Nr.reverse(Nr.interpolate(Nr.forward(o2), Nr.forward(l2), a2)) : qr.reverse(qr.interpolate(qr.forward(o2), qr.forward(l2), a2));
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs)
                t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
            serialize() {
              let t2;
              t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
              const e2 = [this.operator, t2, this.input.serialize()];
              for (let t3 = 0; t3 < this.labels.length; t3++)
                e2.push(this.labels[t3], this.outputs[t3].serialize());
              return e2;
            }
          }
          function Xr(t2, e2, r2, n2) {
            const i2 = n2 - r2, s2 = t2 - r2;
            return 0 === i2 ? 0 : 1 === e2 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
          }
          var Kr = Zr;
          class Yr {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expectected at least one argument.");
              let r2 = null;
              const n2 = e2.expectedType;
              n2 && "value" !== n2.kind && (r2 = n2);
              const i2 = [];
              for (const n3 of t2.slice(1)) {
                const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
                if (!t3)
                  return null;
                r2 = r2 || t3.type, i2.push(t3);
              }
              const s2 = n2 && i2.some((t3) => ge(n2, t3.type));
              return new Yr(s2 ? ce : r2, i2);
            }
            evaluate(t2) {
              let e2, r2 = null, n2 = 0;
              for (const i2 of this.args) {
                if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof Ee && !r2.available && (e2 || (e2 = r2), r2 = null, n2 === this.args.length))
                  return e2;
                if (null !== r2)
                  break;
              }
              return r2;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = ["coalesce"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          var Hr = Yr;
          class Wr {
            constructor(t2, e2) {
              this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
            }
            evaluate(t2) {
              return this.result.evaluate(t2);
            }
            eachChild(t2) {
              for (const e2 of this.bindings)
                t2(e2[1]);
              t2(this.result);
            }
            static parse(t2, e2) {
              if (t2.length < 4)
                return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
              const r2 = [];
              for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
                const i2 = t2[n3];
                if ("string" != typeof i2)
                  return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
                if (/[^a-zA-Z0-9_]/.test(i2))
                  return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
                const s2 = e2.parse(t2[n3 + 1], n3 + 1);
                if (!s2)
                  return null;
                r2.push([i2, s2]);
              }
              const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
              return n2 ? new Wr(r2, n2) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
            serialize() {
              const t2 = ["let"];
              for (const [e2, r2] of this.bindings)
                t2.push(e2, r2.serialize());
              return t2.push(this.result.serialize()), t2;
            }
          }
          var Jr = Wr;
          class Qr {
            constructor(t2, e2, r2) {
              this.type = t2, this.index = e2, this.input = r2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length)
                return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, se), n2 = e2.parse(t2[2], 2, de(e2.expectedType || ce));
              return r2 && n2 ? new Qr(n2.type.itemType, r2, n2) : null;
            }
            evaluate(t2) {
              const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
              if (e2 < 0)
                throw new Re(`Array index out of bounds: ${e2} < 0.`);
              if (e2 >= r2.length)
                throw new Re(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
              if (e2 !== Math.floor(e2))
                throw new Re(`Array index must be an integer, but found ${e2} instead.`);
              return r2[e2];
            }
            eachChild(t2) {
              t2(this.index), t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["at", this.index.serialize(), this.input.serialize()];
            }
          }
          var tn = Qr;
          class en {
            constructor(t2, e2) {
              this.type = oe, this.needle = t2, this.haystack = e2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length)
                return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, ce), n2 = e2.parse(t2[2], 2, ce);
              return r2 && n2 ? xe(r2.type, [oe, ae, se, ie, ce]) ? new en(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r2.type)} instead`) : null;
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (null == r2)
                return false;
              if (!ve(e2, ["boolean", "string", "number", "null"]))
                throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e2))} instead.`);
              if (!ve(r2, ["string", "array"]))
                throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r2))} instead.`);
              return r2.indexOf(e2) >= 0;
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["in", this.needle.serialize(), this.haystack.serialize()];
            }
          }
          var rn = en;
          class nn {
            constructor(t2, e2, r2) {
              this.type = se, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5)
                return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, ce), n2 = e2.parse(t2[2], 2, ce);
              if (!r2 || !n2)
                return null;
              if (!xe(r2.type, [oe, ae, se, ie, ce]))
                return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r2.type)} instead`);
              if (4 === t2.length) {
                const i2 = e2.parse(t2[3], 3, se);
                return i2 ? new nn(r2, n2, i2) : null;
              }
              return new nn(r2, n2);
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (!ve(e2, ["boolean", "string", "number", "null"]))
                throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e2))} instead.`);
              if (!ve(r2, ["string", "array"]))
                throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r2))} instead.`);
              if (this.fromIndex) {
                const n2 = this.fromIndex.evaluate(t2);
                return r2.indexOf(e2, n2);
              }
              return r2.indexOf(e2);
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              if (null != this.fromIndex && void 0 !== this.fromIndex) {
                const t2 = this.fromIndex.serialize();
                return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
              }
              return ["index-of", this.needle.serialize(), this.haystack.serialize()];
            }
          }
          var sn = nn;
          class an {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
            }
            static parse(t2, e2) {
              if (t2.length < 5)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 1)
                return e2.error("Expected an even number of arguments.");
              let r2, n2;
              e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
              const i2 = {}, s2 = [];
              for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
                let o3 = t2[a3];
                const l2 = t2[a3 + 1];
                Array.isArray(o3) || (o3 = [o3]);
                const u2 = e2.concat(a3);
                if (0 === o3.length)
                  return u2.error("Expected at least one branch label.");
                for (const t3 of o3) {
                  if ("number" != typeof t3 && "string" != typeof t3)
                    return u2.error("Branch labels must be numbers or strings.");
                  if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                    return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if ("number" == typeof t3 && Math.floor(t3) !== t3)
                    return u2.error("Numeric branch labels must be integer values.");
                  if (r2) {
                    if (u2.checkSubtype(r2, De(t3)))
                      return null;
                  } else
                    r2 = De(t3);
                  if (void 0 !== i2[String(t3)])
                    return u2.error("Branch labels must be unique.");
                  i2[String(t3)] = s2.length;
                }
                const c2 = e2.parse(l2, a3, n2);
                if (!c2)
                  return null;
                n2 = n2 || c2.type, s2.push(c2);
              }
              const a2 = e2.parse(t2[1], 1, ce);
              if (!a2)
                return null;
              const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
              return o2 ? "value" !== a2.type.kind && e2.concat(1).checkSubtype(r2, a2.type) ? null : new an(r2, n2, a2, i2, s2, o2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              return (De(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
              const t2 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r2 = [], n2 = {};
              for (const t3 of e2) {
                const e3 = n2[this.cases[t3]];
                void 0 === e3 ? (n2[this.cases[t3]] = r2.length, r2.push([this.cases[t3], [t3]])) : r2[e3][1].push(t3);
              }
              const i2 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
              for (const [e3, n3] of r2)
                t2.push(1 === n3.length ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e3].serialize());
              return t2.push(this.otherwise.serialize()), t2;
            }
          }
          var on = an;
          class ln {
            constructor(t2, e2, r2) {
              this.type = t2, this.branches = e2, this.otherwise = r2;
            }
            static parse(t2, e2) {
              if (t2.length < 4)
                return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 0)
                return e2.error("Expected an odd number of arguments.");
              let r2;
              e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
              const n2 = [];
              for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
                const s2 = e2.parse(t2[i3], i3, oe);
                if (!s2)
                  return null;
                const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
                if (!a2)
                  return null;
                n2.push([s2, a2]), r2 = r2 || a2.type;
              }
              const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
              return i2 ? new ln(r2, n2, i2) : null;
            }
            evaluate(t2) {
              for (const [e2, r2] of this.branches)
                if (e2.evaluate(t2))
                  return r2.evaluate(t2);
              return this.otherwise.evaluate(t2);
            }
            eachChild(t2) {
              for (const [e2, r2] of this.branches)
                t2(e2), t2(r2);
              t2(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
              const t2 = ["case"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          var un = ln;
          class cn {
            constructor(t2, e2, r2, n2) {
              this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5)
                return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, ce), n2 = e2.parse(t2[2], 2, se);
              if (!r2 || !n2)
                return null;
              if (!xe(r2.type, [de(ce), ae, ce]))
                return e2.error(`Expected first argument to be of type array or string, but found ${ye(r2.type)} instead`);
              if (4 === t2.length) {
                const i2 = e2.parse(t2[3], 3, se);
                return i2 ? new cn(r2.type, r2, n2, i2) : null;
              }
              return new cn(r2.type, r2, n2);
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
              if (!ve(e2, ["string", "array"]))
                throw new Re(`Expected first argument to be of type array or string, but found ${ye(De(e2))} instead.`);
              if (this.endIndex) {
                const n2 = this.endIndex.evaluate(t2);
                return e2.slice(r2, n2);
              }
              return e2.slice(r2);
            }
            eachChild(t2) {
              t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              if (null != this.endIndex && void 0 !== this.endIndex) {
                const t2 = this.endIndex.serialize();
                return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
              }
              return ["slice", this.input.serialize(), this.beginIndex.serialize()];
            }
          }
          var hn = cn;
          function pn(t2, e2) {
            return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
          }
          function fn2(t2, e2, r2, n2) {
            return 0 === n2.compare(e2, r2);
          }
          function dn(t2, e2, r2) {
            const n2 = "==" !== t2 && "!=" !== t2;
            return class i2 {
              constructor(t3, e3, r3) {
                this.type = oe, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
              }
              static parse(t3, e3) {
                if (3 !== t3.length && 4 !== t3.length)
                  return e3.error("Expected two or three arguments.");
                const r3 = t3[0];
                let s2 = e3.parse(t3[1], 1, ce);
                if (!s2)
                  return null;
                if (!pn(r3, s2.type))
                  return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${ye(s2.type)}'.`);
                let a2 = e3.parse(t3[2], 2, ce);
                if (!a2)
                  return null;
                if (!pn(r3, a2.type))
                  return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${ye(a2.type)}'.`);
                if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                  return e3.error(`Cannot compare types '${ye(s2.type)}' and '${ye(a2.type)}'.`);
                n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new Ue(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new Ue(s2.type, [a2])));
                let o2 = null;
                if (4 === t3.length) {
                  if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                    return e3.error("Cannot use collator to compare non-string types.");
                  if (o2 = e3.parse(t3[3], 3, he), !o2)
                    return null;
                }
                return new i2(s2, a2, o2);
              }
              evaluate(i3) {
                const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
                if (n2 && this.hasUntypedArgument) {
                  const e3 = De(s2), r3 = De(a2);
                  if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind)
                    throw new Re(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
                }
                if (this.collator && !n2 && this.hasUntypedArgument) {
                  const t3 = De(s2), r3 = De(a2);
                  if ("string" !== t3.kind || "string" !== r3.kind)
                    return e2(i3, s2, a2);
                }
                return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
              }
              eachChild(t3) {
                t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
              }
              outputDefined() {
                return true;
              }
              serialize() {
                const e3 = [t2];
                return this.eachChild((t3) => {
                  e3.push(t3.serialize());
                }), e3;
              }
            };
          }
          const yn = dn("==", function(t2, e2, r2) {
            return e2 === r2;
          }, fn2), mn = dn("!=", function(t2, e2, r2) {
            return e2 !== r2;
          }, function(t2, e2, r2, n2) {
            return !fn2(0, e2, r2, n2);
          }), gn = dn("<", function(t2, e2, r2) {
            return e2 < r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) < 0;
          }), xn = dn(">", function(t2, e2, r2) {
            return e2 > r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) > 0;
          }), vn = dn("<=", function(t2, e2, r2) {
            return e2 <= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) <= 0;
          }), bn = dn(">=", function(t2, e2, r2) {
            return e2 >= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) >= 0;
          });
          class wn {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.type = ae, this.number = t2, this.locale = e2, this.currency = r2, this.unit = n2, this.minFractionDigits = i2, this.maxFractionDigits = s2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length)
                return e2.error("Expected two arguments.");
              const r2 = e2.parse(t2[1], 1, se);
              if (!r2)
                return null;
              const n2 = t2[2];
              if ("object" != typeof n2 || Array.isArray(n2))
                return e2.error("NumberFormat options argument must be an object.");
              let i2 = null;
              if (n2.locale && (i2 = e2.parse(n2.locale, 1, ae), !i2))
                return null;
              let s2 = null;
              if (n2.currency && (s2 = e2.parse(n2.currency, 1, ae), !s2))
                return null;
              let a2 = null;
              if (n2.unit && (a2 = e2.parse(n2.unit, 1, ae), !a2))
                return null;
              let o2 = null;
              if (n2["min-fraction-digits"] && (o2 = e2.parse(n2["min-fraction-digits"], 1, se), !o2))
                return null;
              let l2 = null;
              return n2["max-fraction-digits"] && (l2 = e2.parse(n2["max-fraction-digits"], 1, se), !l2) ? null : new wn(r2, i2, s2, a2, o2, l2);
            }
            evaluate(t2) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, unit: this.unit ? this.unit.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
            }
            eachChild(t2) {
              t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.unit && t2(this.unit), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = {};
              return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.unit && (t2.unit = this.unit.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
            }
          }
          class _n {
            constructor(t2) {
              this.type = se, this.input = t2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length)
                return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1);
              return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error(`Expected argument of type string or array, but found ${ye(r2.type)} instead.`) : new _n(r2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              if ("string" == typeof e2)
                return e2.length;
              if (Array.isArray(e2))
                return e2.length;
              throw new Re(`Expected value to be of type string or array, but found ${ye(De(e2))} instead.`);
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["length"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          const An = { "==": yn, "!=": mn, ">": xn, "<": gn, ">=": bn, "<=": vn, array: Ue, at: tn, boolean: Ue, case: un, coalesce: Hr, collator: We, format: Oe, image: qe, in: rn, "index-of": sn, interpolate: Kr, "interpolate-hcl": Kr, "interpolate-lab": Kr, length: _n, let: Jr, literal: Fe, match: on, number: Ue, "number-format": wn, object: Ue, slice: hn, step: Ir, string: Ue, "to-boolean": Ze, "to-color": Ze, "to-number": Ze, "to-string": Ze, var: br, within: yr };
          function Sn(t2, [e2, r2, n2, i2]) {
            e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
            const s2 = i2 ? i2.evaluate(t2) : 1, a2 = Ce(e2, r2, n2, s2);
            if (a2)
              throw new Re(a2);
            return new Me(e2 / 255 * s2, r2 / 255 * s2, n2 / 255 * s2, s2);
          }
          function kn(t2, e2) {
            return t2 in e2;
          }
          function In(t2, e2) {
            const r2 = e2[t2];
            return void 0 === r2 ? null : r2;
          }
          function Mn(t2) {
            return { type: t2 };
          }
          He.register(An, { error: [{ kind: "error" }, [ae], (t2, [e2]) => {
            throw new Re(e2.evaluate(t2));
          }], typeof: [ae, [ce], (t2, [e2]) => ye(De(e2.evaluate(t2)))], "to-rgba": [de(se, 4), [le], (t2, [e2]) => e2.evaluate(t2).toArray()], rgb: [le, [se, se, se], Sn], rgba: [le, [se, se, se, se], Sn], has: { type: oe, overloads: [[[ae], (t2, [e2]) => kn(e2.evaluate(t2), t2.properties())], [[ae, ue], (t2, [e2, r2]) => kn(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: ce, overloads: [[[ae], (t2, [e2]) => In(e2.evaluate(t2), t2.properties())], [[ae, ue], (t2, [e2, r2]) => In(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [ce, [ae], (t2, [e2]) => In(e2.evaluate(t2), t2.featureState || {})], properties: [ue, [], (t2) => t2.properties()], "geometry-type": [ae, [], (t2) => t2.geometryType()], id: [ce, [], (t2) => t2.id()], zoom: [se, [], (t2) => t2.globals.zoom], pitch: [se, [], (t2) => t2.globals.pitch || 0], "distance-from-center": [se, [], (t2) => t2.distanceFromCenter()], "heatmap-density": [se, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [se, [], (t2) => t2.globals.lineProgress || 0], "sky-radial-progress": [se, [], (t2) => t2.globals.skyRadialProgress || 0], accumulated: [ce, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [se, Mn(se), (t2, e2) => {
            let r2 = 0;
            for (const n2 of e2)
              r2 += n2.evaluate(t2);
            return r2;
          }], "*": [se, Mn(se), (t2, e2) => {
            let r2 = 1;
            for (const n2 of e2)
              r2 *= n2.evaluate(t2);
            return r2;
          }], "-": { type: se, overloads: [[[se, se], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[se], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [se, [se, se], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [se, [se, se], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [se, [], () => Math.LN2], pi: [se, [], () => Math.PI], e: [se, [], () => Math.E], "^": [se, [se, se], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [se, [se], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [se, [se], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [se, [se], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [se, [se], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [se, [se], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [se, [se], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [se, [se], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [se, [se], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [se, [se], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [se, [se], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [se, Mn(se), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [se, Mn(se), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [se, [se], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [se, [se], (t2, [e2]) => {
            const r2 = e2.evaluate(t2);
            return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
          }], floor: [se, [se], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [se, [se], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [oe, [ae, ce], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [oe, [ce], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [oe, [ae], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [oe, [ae, ce], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 < i2;
          }], "filter-id-<": [oe, [ce], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 < n2;
          }], "filter->": [oe, [ae, ce], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 > i2;
          }], "filter-id->": [oe, [ce], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 > n2;
          }], "filter-<=": [oe, [ae, ce], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 <= i2;
          }], "filter-id-<=": [oe, [ce], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 <= n2;
          }], "filter->=": [oe, [ae, ce], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 >= i2;
          }], "filter-id->=": [oe, [ce], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 >= n2;
          }], "filter-has": [oe, [ce], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [oe, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [oe, [de(ae)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [oe, [de(ce)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [oe, [ae, de(ce)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [oe, [ae, de(ce)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
            for (; r3 <= n2; ) {
              const i2 = r3 + n2 >> 1;
              if (e3[i2] === t3)
                return true;
              e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
            }
            return false;
          }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: oe, overloads: [[[oe, oe], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [Mn(oe), (t2, e2) => {
            for (const r2 of e2)
              if (!r2.evaluate(t2))
                return false;
            return true;
          }]] }, any: { type: oe, overloads: [[[oe, oe], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [Mn(oe), (t2, e2) => {
            for (const r2 of e2)
              if (r2.evaluate(t2))
                return true;
            return false;
          }]] }, "!": [oe, [oe], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [oe, [ae], (t2, [e2]) => {
            const r2 = t2.globals && t2.globals.isSupportedScript;
            return !r2 || r2(e2.evaluate(t2));
          }], upcase: [ae, [ae], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [ae, [ae], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [ae, Mn(ce), (t2, e2) => e2.map((e3) => Ve(e3.evaluate(t2))).join("")], "resolved-locale": [ae, [he], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
          var Tn = An;
          function zn(t2) {
            return { result: "success", value: t2 };
          }
          function Bn(t2) {
            return { result: "error", value: t2 };
          }
          function En(t2) {
            return "data-driven" === t2["property-type"];
          }
          function Cn(t2) {
            return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
          }
          function Pn(t2) {
            return !!t2.expression && t2.expression.interpolated;
          }
          function Dn(t2) {
            return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
          }
          function Vn(t2) {
            return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
          }
          function Ln(t2) {
            return t2;
          }
          function Fn(t2, e2) {
            const r2 = "color" === e2.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), s2 = t2.type || (Pn(e2) ? "exponential" : "interval");
            if (r2 && ((t2 = Wt({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], Me.parse(t3[1])])), t2.default = Me.parse(t2.default ? t2.default : e2.default)), t2.colorSpace && "rgb" !== t2.colorSpace && !Gr[t2.colorSpace])
              throw new Error(`Unknown color space: ${t2.colorSpace}`);
            let a2, o2, l2;
            if ("exponential" === s2)
              a2 = Un;
            else if ("interval" === s2)
              a2 = $n;
            else if ("categorical" === s2) {
              a2 = jn, o2 = /* @__PURE__ */ Object.create(null);
              for (const e3 of t2.stops)
                o2[e3[0]] = e3[1];
              l2 = typeof t2.stops[0][0];
            } else {
              if ("identity" !== s2)
                throw new Error(`Unknown function type "${s2}"`);
              a2 = On;
            }
            if (n2) {
              const r3 = {}, n3 = [];
              for (let e3 = 0; e3 < t2.stops.length; e3++) {
                const i4 = t2.stops[e3], s4 = i4[0].zoom;
                void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
              }
              const i3 = [];
              for (const t3 of n3)
                i3.push([r3[t3].zoom, Fn(r3[t3], e2)]);
              const s3 = { name: "linear" };
              return { kind: "composite", interpolationType: s3, interpolationFactor: Kr.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Un({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
            }
            if (i2) {
              const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
              return { kind: "camera", interpolationType: r3, interpolationFactor: Kr.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => a2(t2, e2, r4, o2, l2) };
            }
            return { kind: "source", evaluate(r3, n3) {
              const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
              return void 0 === i3 ? Rn(t2.default, e2.default) : a2(t2, e2, i3, o2, l2);
            } };
          }
          function Rn(t2, e2, r2) {
            return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
          }
          function jn(t2, e2, r2, n2, i2) {
            return Rn(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
          }
          function $n(t2, e2, r2) {
            if ("number" !== Dn(r2))
              return Rn(t2.default, e2.default);
            const n2 = t2.stops.length;
            if (1 === n2)
              return t2.stops[0][1];
            if (r2 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r2 >= t2.stops[n2 - 1][0])
              return t2.stops[n2 - 1][1];
            const i2 = Sr(t2.stops.map((t3) => t3[0]), r2);
            return t2.stops[i2][1];
          }
          function Un(t2, e2, r2) {
            const n2 = void 0 !== t2.base ? t2.base : 1;
            if ("number" !== Dn(r2))
              return Rn(t2.default, e2.default);
            const i2 = t2.stops.length;
            if (1 === i2)
              return t2.stops[0][1];
            if (r2 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r2 >= t2.stops[i2 - 1][0])
              return t2.stops[i2 - 1][1];
            const s2 = Sr(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
              const i3 = n3 - r3, s3 = t3 - r3;
              return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
            }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
            let u2 = Tr[e2.type] || Ln;
            if (t2.colorSpace && "rgb" !== t2.colorSpace) {
              const e3 = Gr[t2.colorSpace];
              u2 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), a2));
            }
            return "function" == typeof o2.evaluate ? { evaluate(...t3) {
              const e3 = o2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
              if (void 0 !== e3 && void 0 !== r3)
                return u2(e3, r3, a2);
            } } : u2(o2, l2, a2);
          }
          function On(t2, e2, r2) {
            return "color" === e2.type ? r2 = Me.parse(r2) : "formatted" === e2.type ? r2 = Be.fromString(r2.toString()) : "resolvedImage" === e2.type ? r2 = Ee.fromString(r2.toString()) : Dn(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0), Rn(r2, t2.default, e2.default);
          }
          class qn {
            constructor(t2, e2) {
              this.expression = t2, this._warningHistory = {}, this._evaluator = new Ke(), this._defaultValue = e2 ? function(t3) {
                return "color" === t3.type && (Vn(t3.default) || Array.isArray(t3.default)) ? new Me(0, 0, 0, 0) : "color" === t3.type ? Me.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
              }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2, a2, o2) {
              return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this.expression.evaluate(this._evaluator);
            }
            evaluate(t2, e2, r2, n2, i2, s2, a2, o2) {
              this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null;
              try {
                const t3 = this.expression.evaluate(this._evaluator);
                if (null == t3 || "number" == typeof t3 && t3 != t3)
                  return this._defaultValue;
                if (this._enumValues && !(t3 in this._enumValues))
                  throw new Re(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
                return t3;
              } catch (t3) {
                return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
              }
            }
          }
          function Nn(t2) {
            return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in Tn;
          }
          function Gn(t2, e2) {
            const r2 = new _r(Tn, [], e2 ? function(t3) {
              const e3 = { color: le, string: ae, number: se, enum: ae, boolean: oe, formatted: pe, resolvedImage: fe };
              return "array" === t3.type ? de(e3[t3.value] || ce, t3.length) : e3[t3.type];
            }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
            return n2 ? zn(new qn(n2, e2)) : Bn(r2.errors);
          }
          class Zn {
            constructor(t2, e2) {
              this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !gr(e2.expression);
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
            }
          }
          class Xn {
            constructor(t2, e2, r2, n2) {
              this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !gr(e2.expression), this.interpolationType = n2;
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
            }
            interpolationFactor(t2, e2, r2) {
              return this.interpolationType ? Kr.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
            }
          }
          function Kn(t2, e2) {
            if ("error" === (t2 = Gn(t2, e2)).result)
              return t2;
            const r2 = t2.value.expression, n2 = mr(r2);
            if (!n2 && !En(e2))
              return Bn([new ee("", "data expressions not supported")]);
            const i2 = xr(r2, ["zoom", "pitch", "distance-from-center"]);
            if (!i2 && !Cn(e2))
              return Bn([new ee("", "zoom expressions not supported")]);
            const s2 = Hn(r2);
            return s2 || i2 ? s2 instanceof ee ? Bn([s2]) : s2 instanceof Kr && !Pn(e2) ? Bn([new ee("", '"interpolate" expressions cannot be used with this property')]) : zn(s2 ? new Xn(n2 ? "camera" : "composite", t2.value, s2.labels, s2 instanceof Kr ? s2.interpolation : void 0) : new Zn(n2 ? "constant" : "source", t2.value)) : Bn([new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
          }
          class Yn {
            constructor(t2, e2) {
              this._parameters = t2, this._specification = e2, Wt(this, Fn(this._parameters, this._specification));
            }
            static deserialize(t2) {
              return new Yn(t2._parameters, t2._specification);
            }
            static serialize(t2) {
              return { _parameters: t2._parameters, _specification: t2._specification };
            }
          }
          function Hn(t2) {
            let e2 = null;
            if (t2 instanceof Jr)
              e2 = Hn(t2.result);
            else if (t2 instanceof Hr) {
              for (const r2 of t2.args)
                if (e2 = Hn(r2), e2)
                  break;
            } else
              (t2 instanceof Ir || t2 instanceof Kr) && t2.input instanceof He && "zoom" === t2.input.name && (e2 = t2);
            return e2 instanceof ee || t2.eachChild((t3) => {
              const r2 = Hn(t3);
              r2 instanceof ee ? e2 = r2 : !e2 && r2 ? e2 = new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new ee("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e2;
          }
          class Wn {
            constructor(t2, e2, r2, n2) {
              this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
            }
          }
          function Jn(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec;
            let o2 = [];
            const l2 = Dn(r2);
            if ("object" !== l2)
              return [new Wn(e2, r2, `object expected, ${l2} found`)];
            for (const t3 in r2) {
              const l3 = t3.split(".")[0], u2 = n2[l3] || n2["*"];
              let c2;
              i2[l3] ? c2 = i2[l3] : n2[l3] ? c2 = Ci : i2["*"] ? c2 = i2["*"] : n2["*"] && (c2 = Ci), c2 ? o2 = o2.concat(c2({ key: (e2 ? `${e2}.` : e2) + t3, value: r2[t3], valueSpec: u2, style: s2, styleSpec: a2, object: r2, objectKey: t3 }, r2)) : o2.push(new Wn(e2, r2[t3], `unknown property "${t3}"`));
            }
            for (const t3 in n2)
              i2[t3] || n2[t3].required && void 0 === n2[t3].default && void 0 === r2[t3] && o2.push(new Wn(e2, r2, `missing required property "${t3}"`));
            return o2;
          }
          function Qn(t2) {
            const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || Ci;
            if ("array" !== Dn(e2))
              return [new Wn(s2, e2, `array expected, ${Dn(e2)} found`)];
            if (r2.length && e2.length !== r2.length)
              return [new Wn(s2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
            if (r2["min-length"] && e2.length < r2["min-length"])
              return [new Wn(s2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
            let o2 = { type: r2.value, values: r2.values, minimum: r2.minimum, maximum: r2.maximum, function: void 0 };
            i2.$version < 7 && (o2.function = r2.function), "object" === Dn(r2.value) && (o2 = r2.value);
            let l2 = [];
            for (let t3 = 0; t3 < e2.length; t3++)
              l2 = l2.concat(a2({ array: e2, arrayIndex: t3, value: e2[t3], valueSpec: o2, style: n2, styleSpec: i2, key: `${s2}[${t3}]` }));
            return l2;
          }
          function ti(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
            let i2 = Dn(r2);
            if ("number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2)
              return [new Wn(e2, r2, `number expected, ${i2} found`)];
            if ("minimum" in n2) {
              let i3 = n2.minimum;
              if ("array" === Dn(n2.minimum) && (i3 = n2.minimum[t2.arrayIndex]), r2 < i3)
                return [new Wn(e2, r2, `${r2} is less than the minimum value ${i3}`)];
            }
            if ("maximum" in n2) {
              let i3 = n2.maximum;
              if ("array" === Dn(n2.maximum) && (i3 = n2.maximum[t2.arrayIndex]), r2 > i3)
                return [new Wn(e2, r2, `${r2} is greater than the maximum value ${i3}`)];
            }
            return [];
          }
          function ei(t2) {
            const e2 = t2.valueSpec, r2 = Jt(t2.value.type);
            let n2, i2, s2, a2 = {};
            const o2 = "categorical" !== r2 && void 0 === t2.value.property, l2 = !o2, u2 = "array" === Dn(t2.value.stops) && "array" === Dn(t2.value.stops[0]) && "object" === Dn(t2.value.stops[0][0]), c2 = Jn({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
              if ("identity" === r2)
                return [new Wn(t3.key, t3.value, 'identity function may not have a "stops" property')];
              let e3 = [];
              const n3 = t3.value;
              return e3 = e3.concat(Qn({ key: t3.key, value: n3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), "array" === Dn(n3) && 0 === n3.length && e3.push(new Wn(t3.key, n3, "array must have at least one stop")), e3;
            }, default: function(t3) {
              return Ci({ key: t3.key, value: t3.value, valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec });
            } } });
            return "identity" === r2 && o2 && c2.push(new Wn(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || t2.value.stops || c2.push(new Wn(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && t2.valueSpec.expression && !Pn(t2.valueSpec) && c2.push(new Wn(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !En(t2.valueSpec) ? c2.push(new Wn(t2.key, t2.value, "property functions not supported")) : o2 && !Cn(t2.valueSpec) && c2.push(new Wn(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t2.value.property || c2.push(new Wn(t2.key, t2.value, '"property" property is required')), c2;
            function h2(t3) {
              let r3 = [];
              const n3 = t3.value, o3 = t3.key;
              if ("array" !== Dn(n3))
                return [new Wn(o3, n3, `array expected, ${Dn(n3)} found`)];
              if (2 !== n3.length)
                return [new Wn(o3, n3, `array length 2 expected, length ${n3.length} found`)];
              if (u2) {
                if ("object" !== Dn(n3[0]))
                  return [new Wn(o3, n3, `object expected, ${Dn(n3[0])} found`)];
                if (void 0 === n3[0].zoom)
                  return [new Wn(o3, n3, "object stop key must have zoom")];
                if (void 0 === n3[0].value)
                  return [new Wn(o3, n3, "object stop key must have value")];
                const e3 = Jt(n3[0].zoom);
                if ("number" != typeof e3)
                  return [new Wn(o3, n3[0].zoom, "stop zoom values must be numbers")];
                if (s2 && s2 > e3)
                  return [new Wn(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
                e3 !== s2 && (s2 = e3, i2 = void 0, a2 = {}), r3 = r3.concat(Jn({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: ti, value: p2 } }));
              } else
                r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n3));
              return Nn(Qt(n3[1])) ? r3.concat([new Wn(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(Ci({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec }));
            }
            function p2(t3, s3) {
              const o3 = Dn(t3.value), l3 = Jt(t3.value), u3 = null !== t3.value ? t3.value : s3;
              if (n2) {
                if (o3 !== n2)
                  return [new Wn(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
              } else
                n2 = o3;
              if ("number" !== o3 && "string" !== o3 && "boolean" !== o3 && "number" != typeof l3 && "string" != typeof l3 && "boolean" != typeof l3)
                return [new Wn(t3.key, u3, "stop domain value must be a number, string, or boolean")];
              if ("number" !== o3 && "categorical" !== r2) {
                let n3 = `number expected, ${o3} found`;
                return En(e2) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Wn(t3.key, u3, n3)];
              }
              return "categorical" !== r2 || "number" !== o3 || "number" == typeof l3 && isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && "number" == typeof l3 && "number" == typeof i2 && void 0 !== i2 && l3 < i2 ? [new Wn(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, "categorical" === r2 && l3 in a2 ? [new Wn(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new Wn(t3.key, u3, `integer expected, found ${String(l3)}`)];
            }
          }
          function ri(t2) {
            const e2 = ("property" === t2.expressionContext ? Kn : Gn)(Qt(t2.value), t2.valueSpec);
            if ("error" === e2.result)
              return e2.value.map((e3) => new Wn(`${t2.key}${e3.key}`, t2.value, e3.message));
            const r2 = e2.value.expression || e2.value._styleExpression.expression;
            if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined())
              return [new Wn(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === t2.expressionContext && "layout" === t2.propertyType && !gr(r2))
              return [new Wn(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t2.expressionContext)
              return ni(r2, t2);
            if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
              if (!xr(r2, ["zoom", "feature-state"]))
                return [new Wn(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if ("cluster-initial" === t2.expressionContext && !mr(r2))
                return [new Wn(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function ni(t2, e2) {
            const r2 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
            if (e2.valueSpec && e2.valueSpec.expression)
              for (const t3 of e2.valueSpec.expression.parameters)
                r2.delete(t3);
            if (0 === r2.size)
              return [];
            const n2 = [];
            return t2 instanceof He && r2.has(t2.name) ? [new Wn(e2.key, e2.value, `["${t2.name}"] expression is not supported in a filter for a ${e2.object.type} layer with id: ${e2.object.id}`)] : (t2.eachChild((t3) => {
              n2.push(...ni(t3, e2));
            }), n2);
          }
          function ii(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
            return Array.isArray(n2.values) ? -1 === n2.values.indexOf(Jt(r2)) && i2.push(new Wn(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n2.values).indexOf(Jt(r2)) && i2.push(new Wn(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
          }
          function si(t2) {
            if (true === t2 || false === t2)
              return true;
            if (!Array.isArray(t2) || 0 === t2.length)
              return false;
            switch (t2[0]) {
              case "has":
                return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
              case "in":
                return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
              case "any":
              case "all":
                for (const e2 of t2.slice(1))
                  if (!si(e2) && "boolean" != typeof e2)
                    return false;
                return true;
              default:
                return true;
            }
          }
          function ai(t2, e2 = "fill") {
            if (null == t2)
              return { filter: () => true, needGeometry: false, needFeature: false };
            si(t2) || (t2 = fi(t2));
            const r2 = t2;
            let n2 = true;
            try {
              n2 = function(t3) {
                if (!ui(t3))
                  return t3;
                let e3 = Qt(t3);
                return li(e3), e3 = oi(e3), e3;
              }(r2);
            } catch (t3) {
              console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(r2, null, 2)}
        `);
            }
            const i2 = Ht[`filter_${e2}`], s2 = Gn(n2, i2);
            let a2 = null;
            if ("error" === s2.result)
              throw new Error(s2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
            a2 = (t3, e3, r3) => s2.value.evaluate(t3, e3, {}, r3);
            let o2 = null, l2 = null;
            if (n2 !== r2) {
              const t3 = Gn(r2, i2);
              if ("error" === t3.result)
                throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              o2 = (e3, r3, n3, i3, s3) => t3.value.evaluate(e3, r3, {}, n3, void 0, void 0, i3, s3), l2 = !mr(t3.value.expression);
            }
            return { filter: a2, dynamicFilter: o2 || void 0, needGeometry: pi(n2), needFeature: !!l2 };
          }
          function oi(t2) {
            if (!Array.isArray(t2))
              return t2;
            const e2 = function(t3) {
              if (ci.has(t3[0])) {
                for (let e3 = 1; e3 < t3.length; e3++)
                  if (ui(t3[e3]))
                    return true;
              }
              return t3;
            }(t2);
            return true === e2 ? e2 : e2.map((t3) => oi(t3));
          }
          function li(t2) {
            let e2 = false;
            const r2 = [];
            if ("case" === t2[0]) {
              for (let n2 = 1; n2 < t2.length - 1; n2 += 2)
                e2 = e2 || ui(t2[n2]), r2.push(t2[n2 + 1]);
              r2.push(t2[t2.length - 1]);
            } else if ("match" === t2[0]) {
              e2 = e2 || ui(t2[1]);
              for (let e3 = 2; e3 < t2.length - 1; e3 += 2)
                r2.push(t2[e3 + 1]);
              r2.push(t2[t2.length - 1]);
            } else if ("step" === t2[0]) {
              e2 = e2 || ui(t2[1]);
              for (let e3 = 1; e3 < t2.length - 1; e3 += 2)
                r2.push(t2[e3 + 1]);
            }
            e2 && (t2.length = 0, t2.push("any", ...r2));
            for (let e3 = 1; e3 < t2.length; e3++)
              li(t2[e3]);
          }
          function ui(t2) {
            if (!Array.isArray(t2))
              return false;
            if ("pitch" === (e2 = t2[0]) || "distance-from-center" === e2)
              return true;
            var e2;
            for (let e3 = 1; e3 < t2.length; e3++)
              if (ui(t2[e3]))
                return true;
            return false;
          }
          const ci = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
          function hi(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function pi(t2) {
            if (!Array.isArray(t2))
              return false;
            if ("within" === t2[0])
              return true;
            for (let e2 = 1; e2 < t2.length; e2++)
              if (pi(t2[e2]))
                return true;
            return false;
          }
          function fi(t2) {
            if (!t2)
              return true;
            const e2 = t2[0];
            return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? di(t2[1], t2[2], "==") : "!=" === e2 ? gi(di(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? di(t2[1], t2[2], e2) : "any" === e2 ? (r2 = t2.slice(1), ["any"].concat(r2.map(fi))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(fi)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(fi).map(gi)) : "in" === e2 ? yi(t2[1], t2.slice(2)) : "!in" === e2 ? gi(yi(t2[1], t2.slice(2))) : "has" === e2 ? mi(t2[1]) : "!has" === e2 ? gi(mi(t2[1])) : "within" !== e2 || t2;
            var r2;
          }
          function di(t2, e2, r2) {
            switch (t2) {
              case "$type":
                return [`filter-type-${r2}`, e2];
              case "$id":
                return [`filter-id-${r2}`, e2];
              default:
                return [`filter-${r2}`, t2, e2];
            }
          }
          function yi(t2, e2) {
            if (0 === e2.length)
              return false;
            switch (t2) {
              case "$type":
                return ["filter-type-in", ["literal", e2]];
              case "$id":
                return ["filter-id-in", ["literal", e2]];
              default:
                return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(hi)]] : ["filter-in-small", t2, ["literal", e2]];
            }
          }
          function mi(t2) {
            switch (t2) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t2];
            }
          }
          function gi(t2) {
            return ["!", t2];
          }
          function xi(t2) {
            return si(Qt(t2.value)) ? ri(Wt({}, t2, { expressionContext: "filter", valueSpec: t2.styleSpec[`filter_${t2.layerType || "fill"}`] })) : vi(t2);
          }
          function vi(t2) {
            const e2 = t2.value, r2 = t2.key;
            if ("array" !== Dn(e2))
              return [new Wn(r2, e2, `array expected, ${Dn(e2)} found`)];
            const n2 = t2.styleSpec;
            let i2, s2 = [];
            if (e2.length < 1)
              return [new Wn(r2, e2, "filter array must have at least 1 element")];
            switch (s2 = s2.concat(ii({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), Jt(e2[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                e2.length >= 2 && "$type" === Jt(e2[1]) && s2.push(new Wn(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
              case "==":
              case "!=":
                3 !== e2.length && s2.push(new Wn(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
              case "in":
              case "!in":
                e2.length >= 2 && (i2 = Dn(e2[1]), "string" !== i2 && s2.push(new Wn(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
                for (let a2 = 2; a2 < e2.length; a2++)
                  i2 = Dn(e2[a2]), "$type" === Jt(e2[1]) ? s2 = s2.concat(ii({ key: `${r2}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s2.push(new Wn(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let n3 = 1; n3 < e2.length; n3++)
                  s2 = s2.concat(vi({ key: `${r2}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
                break;
              case "has":
              case "!has":
                i2 = Dn(e2[1]), 2 !== e2.length ? s2.push(new Wn(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "string" !== i2 && s2.push(new Wn(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
                break;
              case "within":
                i2 = Dn(e2[1]), 2 !== e2.length ? s2.push(new Wn(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "object" !== i2 && s2.push(new Wn(`${r2}[1]`, e2[1], `object expected, ${i2} found`));
            }
            return s2;
          }
          function bi(t2, e2) {
            const r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.value, a2 = t2.objectKey, o2 = i2[`${e2}_${t2.layerType}`];
            if (!o2)
              return [];
            const l2 = a2.match(/^(.*)-transition$/);
            if ("paint" === e2 && l2 && o2[l2[1]] && o2[l2[1]].transition)
              return Ci({ key: r2, value: s2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
            const u2 = t2.valueSpec || o2[a2];
            if (!u2)
              return [new Wn(r2, s2, `unknown property "${a2}"`)];
            let c2;
            if ("string" === Dn(s2) && En(u2) && !u2.tokens && (c2 = /^{([^}]+)}$/.exec(s2))) {
              const t3 = `\`{ "type": "identity", "property": ${c2 ? JSON.stringify(c2[1]) : '"_"'} }\``;
              return [new Wn(r2, s2, `"${a2}" does not support interpolation syntax
Use an identity property function instead: ${t3}.`)];
            }
            const h2 = [];
            return "symbol" === t2.layerType && ("text-field" === a2 && n2 && !n2.glyphs && h2.push(new Wn(r2, s2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a2 && Vn(Qt(s2)) && "identity" === Jt(s2.type) && h2.push(new Wn(r2, s2, '"text-font" does not support identity functions'))), h2.concat(Ci({ key: t2.key, value: s2, valueSpec: u2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: a2 }));
          }
          function wi(t2) {
            return bi(t2, "paint");
          }
          function _i(t2) {
            return bi(t2, "layout");
          }
          function Ai(t2) {
            let e2 = [];
            const r2 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
            r2.type || r2.ref || e2.push(new Wn(n2, r2, 'either "type" or "ref" is required'));
            let a2 = Jt(r2.type);
            const o2 = Jt(r2.ref);
            if (r2.id) {
              const s3 = Jt(r2.id);
              for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
                const t3 = i2.layers[a3];
                Jt(t3.id) === s3 && e2.push(new Wn(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
              }
            }
            if ("ref" in r2) {
              let t3;
              ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
                t4 in r2 && e2.push(new Wn(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
              }), i2.layers.forEach((e3) => {
                Jt(e3.id) === o2 && (t3 = e3);
              }), t3 ? t3.ref ? e2.push(new Wn(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = Jt(t3.type) : "string" == typeof o2 && e2.push(new Wn(n2, r2.ref, `ref layer "${o2}" not found`));
            } else if ("background" !== a2 && "sky" !== a2)
              if (r2.source) {
                const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && Jt(t3.type);
                t3 ? "vector" === s3 && "raster" === a2 ? e2.push(new Wn(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster" === s3 && "raster" !== a2 ? e2.push(new Wn(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== s3 || r2["source-layer"] ? "raster-dem" === s3 && "hillshade" !== a2 ? e2.push(new Wn(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a2 || !r2.paint || !r2.paint["line-gradient"] && !r2.paint["line-trim-offset"] || "geojson" === s3 && t3.lineMetrics || e2.push(new Wn(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new Wn(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new Wn(n2, r2.source, `source "${r2.source}" not found`));
              } else
                e2.push(new Wn(n2, r2, 'missing required property "source"'));
            return e2 = e2.concat(Jn({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => Ci({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" }), filter: (t3) => xi(Wt({ layerType: a2 }, t3)), layout: (t3) => Jn({ layer: r2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => _i(Wt({ layerType: a2 }, t4)) } }), paint: (t3) => Jn({ layer: r2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => wi(Wt({ layerType: a2 }, t4)) } }) } })), e2;
          }
          function Si(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = Dn(e2);
            return "string" !== n2 ? [new Wn(r2, e2, `string expected, ${n2} found`)] : [];
          }
          const ki = { promoteId: function({ key: t2, value: e2 }) {
            if ("string" === Dn(e2))
              return Si({ key: t2, value: e2 });
            {
              const r2 = [];
              for (const n2 in e2)
                r2.push(...Si({ key: `${t2}.${n2}`, value: e2[n2] }));
              return r2;
            }
          } };
          function Ii(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
            if (!e2.type)
              return [new Wn(r2, e2, '"type" is required')];
            const s2 = Jt(e2.type);
            let a2;
            switch (s2) {
              case "vector":
              case "raster":
              case "raster-dem":
                return a2 = Jn({ key: r2, value: e2, valueSpec: n2[`source_${s2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: ki }), a2;
              case "geojson":
                if (a2 = Jn({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: ki }), e2.cluster)
                  for (const t3 in e2.clusterProperties) {
                    const [n3, i3] = e2.clusterProperties[t3], s3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t3]] : n3;
                    a2.push(...ri({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...ri({ key: `${r2}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
                  }
                return a2;
              case "video":
                return Jn({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
              case "image":
                return Jn({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
              case "canvas":
                return [new Wn(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return ii({ key: `${r2}.type`, value: e2.type, valueSpec: { values: Mi(n2) }, style: i2, styleSpec: n2 });
            }
          }
          function Mi(t2) {
            return t2.source.reduce((e2, r2) => {
              const n2 = t2[r2];
              return "enum" === n2.type.type && (e2 = e2.concat(Object.keys(n2.type.values))), e2;
            }, []);
          }
          function Ti(t2) {
            const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
            let s2 = [];
            const a2 = Dn(e2);
            if (void 0 === e2)
              return s2;
            if ("object" !== a2)
              return s2 = s2.concat([new Wn("light", e2, `object expected, ${a2} found`)]), s2;
            for (const t3 in e2) {
              const a3 = t3.match(/^(.*)-transition$/);
              s2 = s2.concat(a3 && n2[a3[1]] && n2[a3[1]].transition ? Ci({ key: t3, value: e2[t3], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[t3] ? Ci({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new Wn(t3, e2[t3], `unknown property "${t3}"`)]);
            }
            return s2;
          }
          function zi(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = i2.terrain;
            let a2 = [];
            const o2 = Dn(e2);
            if (void 0 === e2)
              return a2;
            if ("object" !== o2)
              return a2 = a2.concat([new Wn("terrain", e2, `object expected, ${o2} found`)]), a2;
            for (const t3 in e2) {
              const r3 = t3.match(/^(.*)-transition$/);
              a2 = a2.concat(r3 && s2[r3[1]] && s2[r3[1]].transition ? Ci({ key: t3, value: e2[t3], valueSpec: i2.transition, style: n2, styleSpec: i2 }) : s2[t3] ? Ci({ key: t3, value: e2[t3], valueSpec: s2[t3], style: n2, styleSpec: i2 }) : [new Wn(t3, e2[t3], `unknown property "${t3}"`)]);
            }
            if (e2.source) {
              const t3 = n2.sources && n2.sources[e2.source], i3 = t3 && Jt(t3.type);
              t3 ? "raster-dem" !== i3 && a2.push(new Wn(r2, e2.source, `terrain cannot be used with a source of type ${String(i3)}, it only be used with a "raster-dem" source type`)) : a2.push(new Wn(r2, e2.source, `source "${e2.source}" not found`));
            } else
              a2.push(new Wn(r2, e2, 'terrain is missing required property "source"'));
            return a2;
          }
          function Bi(t2) {
            const e2 = t2.value, r2 = t2.style, n2 = t2.styleSpec, i2 = n2.fog;
            let s2 = [];
            const a2 = Dn(e2);
            if (void 0 === e2)
              return s2;
            if ("object" !== a2)
              return s2 = s2.concat([new Wn("fog", e2, `object expected, ${a2} found`)]), s2;
            for (const t3 in e2) {
              const a3 = t3.match(/^(.*)-transition$/);
              s2 = s2.concat(a3 && i2[a3[1]] && i2[a3[1]].transition ? Ci({ key: t3, value: e2[t3], valueSpec: n2.transition, style: r2, styleSpec: n2 }) : i2[t3] ? Ci({ key: t3, value: e2[t3], valueSpec: i2[t3], style: r2, styleSpec: n2 }) : [new Wn(t3, e2[t3], `unknown property "${t3}"`)]);
            }
            return s2;
          }
          const Ei = { "*": () => [], array: Qn, boolean: function(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = Dn(e2);
            return "boolean" !== n2 ? [new Wn(r2, e2, `boolean expected, ${n2} found`)] : [];
          }, number: ti, color: function(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = Dn(r2);
            return "string" !== n2 ? [new Wn(e2, r2, `color expected, ${n2} found`)] : null === be(r2) ? [new Wn(e2, r2, `color expected, "${r2}" found`)] : [];
          }, enum: ii, filter: xi, function: ei, layer: Ai, object: Jn, source: Ii, light: Ti, terrain: zi, fog: Bi, string: Si, formatted: function(t2) {
            return 0 === Si(t2).length ? [] : ri(t2);
          }, resolvedImage: function(t2) {
            return 0 === Si(t2).length ? [] : ri(t2);
          }, projection: function(t2) {
            const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.projection, i2 = t2.style;
            let s2 = [];
            const a2 = Dn(e2);
            if ("object" === a2)
              for (const t3 in e2)
                s2 = s2.concat(Ci({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }));
            else
              "string" !== a2 && (s2 = s2.concat([new Wn("projection", e2, `object or string expected, ${a2} found`)]));
            return s2;
          } };
          function Ci(t2) {
            const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
            return r2.expression && Vn(Jt(e2)) ? ei(t2) : r2.expression && Nn(Qt(e2)) ? ri(t2) : r2.type && Ei[r2.type] ? Ei[r2.type](t2) : Jn(Wt({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
          }
          function Pi(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = Si(t2);
            return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new Wn(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new Wn(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
          }
          function Di(t2, e2 = Ht) {
            return Fi(Ci({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: Pi, "*": () => [] } }));
          }
          const Vi = (t2) => Fi(wi(t2)), Li = (t2) => Fi(_i(t2));
          function Fi(t2) {
            return t2.slice().sort((t3, e2) => t3.line && e2.line ? t3.line - e2.line : 0);
          }
          function Ri(t2, e2) {
            let r2 = false;
            if (e2 && e2.length)
              for (const n2 of e2)
                t2.fire(new Kt(new Error(n2.message))), r2 = true;
            return r2;
          }
          var ji = $i;
          function $i(t2, e2, r2) {
            var n2 = this.cells = [];
            if (t2 instanceof ArrayBuffer) {
              this.arrayBuffer = t2;
              var i2 = new Int32Array(this.arrayBuffer);
              t2 = i2[0], this.d = (e2 = i2[1]) + 2 * (r2 = i2[2]);
              for (var s2 = 0; s2 < this.d * this.d; s2++) {
                var a2 = i2[3 + s2], o2 = i2[3 + s2 + 1];
                n2.push(a2 === o2 ? null : i2.subarray(a2, o2));
              }
              var l2 = i2[3 + n2.length + 1];
              this.keys = i2.subarray(i2[3 + n2.length], l2), this.bboxes = i2.subarray(l2), this.insert = this._insertReadonly;
            } else {
              this.d = e2 + 2 * r2;
              for (var u2 = 0; u2 < this.d * this.d; u2++)
                n2.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
            var c2 = r2 / e2 * t2;
            this.min = -c2, this.max = t2 + c2;
          }
          $i.prototype.insert = function(t2, e2, r2, n2, i2) {
            this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
          }, $i.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
          }, $i.prototype._insertCell = function(t2, e2, r2, n2, i2, s2) {
            this.cells[i2].push(s2);
          }, $i.prototype.query = function(t2, e2, r2, n2, i2) {
            var s2 = this.min, a2 = this.max;
            if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
              return Array.prototype.slice.call(this.keys);
            var o2 = [];
            return this._forEachCell(t2, e2, r2, n2, this._queryCell, o2, {}, i2), o2;
          }, $i.prototype._queryCell = function(t2, e2, r2, n2, i2, s2, a2, o2) {
            var l2 = this.cells[i2];
            if (null !== l2)
              for (var u2 = this.keys, c2 = this.bboxes, h2 = 0; h2 < l2.length; h2++) {
                var p2 = l2[h2];
                if (void 0 === a2[p2]) {
                  var f2 = 4 * p2;
                  (o2 ? o2(c2[f2 + 0], c2[f2 + 1], c2[f2 + 2], c2[f2 + 3]) : t2 <= c2[f2 + 2] && e2 <= c2[f2 + 3] && r2 >= c2[f2 + 0] && n2 >= c2[f2 + 1]) ? (a2[p2] = true, s2.push(u2[p2])) : a2[p2] = false;
                }
              }
          }, $i.prototype._forEachCell = function(t2, e2, r2, n2, i2, s2, a2, o2) {
            for (var l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2), p2 = l2; p2 <= c2; p2++)
              for (var f2 = u2; f2 <= h2; f2++) {
                var d2 = this.d * f2 + p2;
                if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(f2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(f2 + 1))) && i2.call(this, t2, e2, r2, n2, d2, s2, a2, o2))
                  return;
              }
          }, $i.prototype._convertFromCellCoord = function(t2) {
            return (t2 - this.padding) / this.scale;
          }, $i.prototype._convertToCellCoord = function(t2) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
          }, $i.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer)
              return this.arrayBuffer;
            for (var t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r2 = 0, n2 = 0; n2 < this.cells.length; n2++)
              r2 += this.cells[n2].length;
            var i2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
            i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
            for (var s2 = e2, a2 = 0; a2 < t2.length; a2++) {
              var o2 = t2[a2];
              i2[3 + a2] = s2, i2.set(o2, s2), s2 += o2.length;
            }
            return i2[3 + t2.length] = s2, i2.set(this.keys, s2), i2[3 + t2.length + 1] = s2 += this.keys.length, i2.set(this.bboxes, s2), s2 += this.bboxes.length, i2.buffer;
          };
          const Ui = {};
          function Oi(t2, e2, r2 = {}) {
            Object.defineProperty(t2, "_classRegistryKey", { value: e2, writeable: false }), Ui[e2] = { klass: t2, omit: r2.omit || [] };
          }
          Oi(Object, "Object"), ji.serialize = function(t2, e2) {
            const r2 = t2.toArrayBuffer();
            return e2 && e2.push(r2), { buffer: r2 };
          }, ji.deserialize = function(t2) {
            return new ji(t2.buffer);
          }, Object.defineProperty(ji, "name", { value: "Grid" }), Oi(ji, "Grid"), Oi(Me, "Color"), Oi(Error, "Error"), Oi(at, "AJAXError"), Oi(Ee, "ResolvedImage"), Oi(Yn, "StylePropertyFunction"), Oi(qn, "StyleExpression", { omit: ["_evaluator"] }), Oi(Xn, "ZoomDependentExpression"), Oi(Zn, "ZoomConstantExpression"), Oi(He, "CompoundExpression", { omit: ["_evaluate"] });
          for (const t2 in Tn)
            Ui[Tn[t2]._classRegistryKey] || Oi(Tn[t2], `Expression${t2}`);
          function qi(t2) {
            return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
          }
          function Ni(t2) {
            return e.ImageBitmap && t2 instanceof e.ImageBitmap;
          }
          function Gi(t2, r2) {
            if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
              return t2;
            if (qi(t2) || Ni(t2))
              return r2 && r2.push(t2), t2;
            if (ArrayBuffer.isView(t2)) {
              const e2 = t2;
              return r2 && r2.push(e2.buffer), e2;
            }
            if (t2 instanceof e.ImageData)
              return r2 && r2.push(t2.data.buffer), t2;
            if (Array.isArray(t2)) {
              const e2 = [];
              for (const n2 of t2)
                e2.push(Gi(n2, r2));
              return e2;
            }
            if ("object" == typeof t2) {
              const e2 = t2.constructor, n2 = e2._classRegistryKey;
              if (!n2)
                throw new Error(`can't serialize object of unregistered class ${n2}`);
              const i2 = e2.serialize ? e2.serialize(t2, r2) : {};
              if (!e2.serialize) {
                for (const e3 in t2)
                  t2.hasOwnProperty(e3) && (Ui[n2].omit.indexOf(e3) >= 0 || (i2[e3] = Gi(t2[e3], r2)));
                t2 instanceof Error && (i2.message = t2.message);
              }
              if (i2.$name)
                throw new Error("$name property is reserved for worker serialization logic.");
              return "Object" !== n2 && (i2.$name = n2), i2;
            }
            throw new Error("can't serialize object of type " + typeof t2);
          }
          function Zi(t2) {
            if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || qi(t2) || Ni(t2) || ArrayBuffer.isView(t2) || t2 instanceof e.ImageData)
              return t2;
            if (Array.isArray(t2))
              return t2.map(Zi);
            if ("object" == typeof t2) {
              const e2 = t2.$name || "Object", { klass: r2 } = Ui[e2];
              if (!r2)
                throw new Error(`can't deserialize unregistered class ${e2}`);
              if (r2.deserialize)
                return r2.deserialize(t2);
              const n2 = Object.create(r2.prototype);
              for (const e3 of Object.keys(t2))
                "$name" !== e3 && (n2[e3] = Zi(t2[e3]));
              return n2;
            }
            throw new Error("can't deserialize object of type " + typeof t2);
          }
          const Xi = (t2) => t2 >= 1536 && t2 <= 1791, Ki = (t2) => t2 >= 1872 && t2 <= 1919, Yi = (t2) => t2 >= 2208 && t2 <= 2303, Hi = (t2) => t2 >= 11904 && t2 <= 12031, Wi = (t2) => t2 >= 12032 && t2 <= 12255, Ji = (t2) => t2 >= 12272 && t2 <= 12287, Qi = (t2) => t2 >= 12288 && t2 <= 12351, ts = (t2) => t2 >= 12352 && t2 <= 12447, es = (t2) => t2 >= 12448 && t2 <= 12543, rs = (t2) => t2 >= 12544 && t2 <= 12591, ns = (t2) => t2 >= 12704 && t2 <= 12735, is = (t2) => t2 >= 12736 && t2 <= 12783, ss = (t2) => t2 >= 12784 && t2 <= 12799, as = (t2) => t2 >= 12800 && t2 <= 13055, os = (t2) => t2 >= 13056 && t2 <= 13311, ls = (t2) => t2 >= 13312 && t2 <= 19903, us = (t2) => t2 >= 19968 && t2 <= 40959, cs = (t2) => t2 >= 40960 && t2 <= 42127, hs = (t2) => t2 >= 42128 && t2 <= 42191, ps = (t2) => t2 >= 44032 && t2 <= 55215, fs = (t2) => t2 >= 63744 && t2 <= 64255, ds = (t2) => t2 >= 64336 && t2 <= 65023, ys = (t2) => t2 >= 65040 && t2 <= 65055, ms = (t2) => t2 >= 65072 && t2 <= 65103, gs = (t2) => t2 >= 65104 && t2 <= 65135, xs = (t2) => t2 >= 65136 && t2 <= 65279, vs = (t2) => t2 >= 65280 && t2 <= 65519;
          function bs(t2) {
            for (const e2 of t2)
              if (As(e2.charCodeAt(0)))
                return true;
            return false;
          }
          function ws(t2) {
            for (const e2 of t2)
              if (!_s(e2.charCodeAt(0)))
                return false;
            return true;
          }
          function _s(t2) {
            return !(Xi(t2) || Ki(t2) || Yi(t2) || ds(t2) || xs(t2));
          }
          function As(t2) {
            return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(ns(t2) || rs(t2) || ms(t2) && !(t2 >= 65097 && t2 <= 65103) || fs(t2) || os(t2) || Hi(t2) || is(t2) || !(!Qi(t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || ls(t2) || us(t2) || as(t2) || ((t3) => t3 >= 12592 && t3 <= 12687)(t2) || ((t3) => t3 >= 43360 && t3 <= 43391)(t2) || ((t3) => t3 >= 55216 && t3 <= 55295)(t2) || ((t3) => t3 >= 4352 && t3 <= 4607)(t2) || ps(t2) || ts(t2) || Ji(t2) || ((t3) => t3 >= 12688 && t3 <= 12703)(t2) || Wi(t2) || ss(t2) || es(t2) && 12540 !== t2 || !(!vs(t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!gs(t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || ((t3) => t3 >= 5120 && t3 <= 5759)(t2) || ((t3) => t3 >= 6320 && t3 <= 6399)(t2) || ys(t2) || ((t3) => t3 >= 19904 && t3 <= 19967)(t2) || cs(t2) || hs(t2))));
          }
          function Ss(t2) {
            return !(As(t2) || function(t3) {
              return !!(((t4) => t4 >= 128 && t4 <= 255)(t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || ((t4) => t4 >= 8192 && t4 <= 8303)(t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || ((t4) => t4 >= 8448 && t4 <= 8527)(t3) || ((t4) => t4 >= 8528 && t4 <= 8591)(t3) || ((t4) => t4 >= 8960 && t4 <= 9215)(t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || ((t4) => t4 >= 9216 && t4 <= 9279)(t3) && 9251 !== t3 || ((t4) => t4 >= 9280 && t4 <= 9311)(t3) || ((t4) => t4 >= 9312 && t4 <= 9471)(t3) || ((t4) => t4 >= 9632 && t4 <= 9727)(t3) || ((t4) => t4 >= 9728 && t4 <= 9983)(t3) && !(t3 >= 9754 && t3 <= 9759) || ((t4) => t4 >= 11008 && t4 <= 11263)(t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Qi(t3) || es(t3) || ((t4) => t4 >= 57344 && t4 <= 63743)(t3) || ms(t3) || gs(t3) || vs(t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
            }(t2));
          }
          function ks(t2) {
            return t2 >= 1424 && t2 <= 2303 || ds(t2) || xs(t2);
          }
          function Is(t2, e2) {
            return !(!e2 && ks(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || ((t3) => t3 >= 6016 && t3 <= 6143)(t2));
          }
          function Ms(t2) {
            for (const e2 of t2)
              if (ks(e2.charCodeAt(0)))
                return true;
            return false;
          }
          const Ts = "deferred", zs = "loading", Bs = "loaded";
          let Es = null, Cs = "unavailable", Ps = null;
          const Ds = function(t2) {
            t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (Cs = "error"), Es && Es(t2);
          };
          function Vs() {
            Ls.fire(new Xt("pluginStateChange", { pluginStatus: Cs, pluginURL: Ps }));
          }
          const Ls = new Yt(), Fs = function() {
            return Cs;
          }, Rs = function() {
            if (Cs !== Ts || !Ps)
              throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Cs = zs, Vs(), Ps && ut({ url: Ps }, (t2) => {
              t2 ? Ds(t2) : (Cs = Bs, Vs());
            });
          }, js = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Cs === Bs || null != js.applyArabicShaping, isLoading: () => Cs === zs, setState(t2) {
            Cs = t2.pluginStatus, Ps = t2.pluginURL;
          }, isParsed: () => null != js.applyArabicShaping && null != js.processBidirectionalText && null != js.processStyledBidirectionalText, getPluginURL: () => Ps };
          class $s {
            constructor(t2, e2) {
              this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.transition = e2.transition, this.pitch = e2.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
            }
            isSupportedScript(t2) {
              return function(t3, e2) {
                for (const r2 of t3)
                  if (!Is(r2.charCodeAt(0), e2))
                    return false;
                return true;
              }(t2, js.isLoaded());
            }
          }
          class Us {
            constructor(t2, e2) {
              this.property = t2, this.value = e2, this.expression = function(t3, e3) {
                if (Vn(t3))
                  return new Yn(t3, e3);
                if (Nn(t3)) {
                  const r2 = Kn(t3, e3);
                  if ("error" === r2.result)
                    throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                  return r2.value;
                }
                {
                  let r2 = t3;
                  return "string" == typeof t3 && "color" === e3.type && (r2 = Me.parse(t3)), { kind: "constant", evaluate: () => r2 };
                }
              }(void 0 === e2 ? t2.specification.default : e2, t2.specification);
            }
            isDataDriven() {
              return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t2, e2, r2) {
              return this.property.possiblyEvaluate(this, t2, e2, r2);
            }
          }
          class Os {
            constructor(t2) {
              this.property = t2, this.value = new Us(t2, void 0);
            }
            transitioned(t2, e2) {
              return new Ns(this.property, this.value, e2, z({}, t2.transition, this.transition), t2.now);
            }
            untransitioned() {
              return new Ns(this.property, this.value, null, {}, 0);
            }
          }
          class qs {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
            }
            getValue(t2) {
              return j(this._values[t2].value.value);
            }
            setValue(t2, e2) {
              this._values.hasOwnProperty(t2) || (this._values[t2] = new Os(this._values[t2].property)), this._values[t2].value = new Us(this._values[t2].property, null === e2 ? void 0 : j(e2));
            }
            getTransition(t2) {
              return j(this._values[t2].transition);
            }
            setTransition(t2, e2) {
              this._values.hasOwnProperty(t2) || (this._values[t2] = new Os(this._values[t2].property)), this._values[t2].transition = j(e2) || void 0;
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r2 = this.getValue(e2);
                void 0 !== r2 && (t2[e2] = r2);
                const n2 = this.getTransition(e2);
                void 0 !== n2 && (t2[`${e2}-transition`] = n2);
              }
              return t2;
            }
            transitioned(t2, e2) {
              const r2 = new Gs(this._properties);
              for (const n2 of Object.keys(this._values))
                r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
              return r2;
            }
            untransitioned() {
              const t2 = new Gs(this._properties);
              for (const e2 of Object.keys(this._values))
                t2._values[e2] = this._values[e2].untransitioned();
              return t2;
            }
          }
          class Ns {
            constructor(t2, e2, r2, n2, i2) {
              const s2 = n2.delay || 0, a2 = n2.duration || 0;
              i2 = i2 || 0, this.property = t2, this.value = e2, this.begin = i2 + s2, this.end = this.begin + a2, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
              if (s2) {
                if (n2 > this.end)
                  return this.prior = null, i2;
                if (this.value.isDataDriven())
                  return this.prior = null, i2;
                if (n2 < this.begin)
                  return s2.possiblyEvaluate(t2, e2, r2);
                {
                  const a2 = (n2 - this.begin) / (this.end - this.begin);
                  return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, w(a2));
                }
              }
              return i2;
            }
          }
          class Gs {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = new Ks(this._properties);
              for (const i2 of Object.keys(this._values))
                n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
              return n2;
            }
            hasTransition() {
              for (const t2 of Object.keys(this._values))
                if (this._values[t2].prior)
                  return true;
              return false;
            }
          }
          class Zs {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
            }
            getValue(t2) {
              return j(this._values[t2].value);
            }
            setValue(t2, e2) {
              this._values[t2] = new Us(this._values[t2].property, null === e2 ? void 0 : j(e2));
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r2 = this.getValue(e2);
                void 0 !== r2 && (t2[e2] = r2);
              }
              return t2;
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = new Ks(this._properties);
              for (const i2 of Object.keys(this._values))
                n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
              return n2;
            }
          }
          class Xs {
            constructor(t2, e2, r2) {
              this.property = t2, this.value = e2, this.parameters = r2;
            }
            isConstant() {
              return "constant" === this.value.kind;
            }
            constantOr(t2) {
              return "constant" === this.value.kind ? this.value.value : t2;
            }
            evaluate(t2, e2, r2, n2) {
              return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
            }
          }
          class Ks {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
            }
            get(t2) {
              return this._values[t2];
            }
          }
          class Ys {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2) {
              return t2.expression.evaluate(e2);
            }
            interpolate(t2, e2, r2) {
              const n2 = Tr[this.specification.type];
              return n2 ? n2(t2, e2, r2) : t2;
            }
          }
          class Hs {
            constructor(t2, e2) {
              this.specification = t2, this.overrides = e2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              return new Xs(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
            }
            interpolate(t2, e2, r2) {
              if ("constant" !== t2.value.kind || "constant" !== e2.value.kind)
                return t2;
              if (void 0 === t2.value.value || void 0 === e2.value.value)
                return new Xs(this, { kind: "constant", value: void 0 }, t2.parameters);
              const n2 = Tr[this.specification.type];
              return n2 ? new Xs(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
            }
          }
          class Ws {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              return !!t2.expression.evaluate(e2, null, {}, r2, n2);
            }
            interpolate() {
              return false;
            }
          }
          class Js {
            constructor(t2) {
              this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
              const e2 = new $s(0, {});
              for (const r2 in t2) {
                const n2 = t2[r2];
                n2.specification.overridable && this.overridableProperties.push(r2);
                const i2 = this.defaultPropertyValues[r2] = new Us(n2, void 0), s2 = this.defaultTransitionablePropertyValues[r2] = new Os(n2);
                this.defaultTransitioningPropertyValues[r2] = s2.untransitioned(), this.defaultPossiblyEvaluatedValues[r2] = i2.possiblyEvaluate(e2);
              }
            }
          }
          function Qs(t2, e2) {
            return 256 * (t2 = S(Math.floor(t2), 0, 255)) + S(Math.floor(e2), 0, 255);
          }
          Oi(Hs, "DataDrivenProperty"), Oi(Ys, "DataConstantProperty"), Oi(Ws, "ColorRampProperty");
          const ta = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
          class ea {
            constructor(t2, e2) {
              this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
          }
          class ra {
            constructor() {
              this.isTransferred = false, this.capacity = -1, this.resize(0);
            }
            static serialize(t2, e2) {
              return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
            }
            static deserialize(t2) {
              const e2 = Object.create(this.prototype);
              return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
            }
            _trim() {
              this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
              this.length = 0;
            }
            resize(t2) {
              this.reserve(t2), this.length = t2;
            }
            reserve(t2) {
              if (t2 > this.capacity) {
                this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                const e2 = this.uint8;
                this._refreshViews(), e2 && this.uint8.set(e2);
              }
            }
            _refreshViews() {
              throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
            destroy() {
              this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
          }
          function na(t2, e2 = 1) {
            let r2 = 0, n2 = 0;
            return { members: t2.map((t3) => {
              const i2 = ta[t3.type].BYTES_PER_ELEMENT, s2 = r2 = ia(r2, Math.max(e2, i2)), a2 = t3.components || 1;
              return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
            }), size: ia(r2, Math.max(n2, e2)), alignment: e2 };
          }
          function ia(t2, e2) {
            return Math.ceil(t2 / e2) * e2;
          }
          class sa extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
            }
          }
          sa.prototype.bytesPerElement = 4, Oi(sa, "StructArrayLayout2i4");
          class aa extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
            }
          }
          aa.prototype.bytesPerElement = 6, Oi(aa, "StructArrayLayout3i6");
          class oa extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
            }
          }
          oa.prototype.bytesPerElement = 8, Oi(oa, "StructArrayLayout4i8");
          class la extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = 6 * t2, u2 = 12 * t2, c2 = 3 * t2;
              return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = s2, this.uint8[u2 + 7] = a2, this.float32[c2 + 2] = o2, t2;
            }
          }
          la.prototype.bytesPerElement = 12, Oi(la, "StructArrayLayout2i4ub1f12");
          class ua extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
            }
          }
          ua.prototype.bytesPerElement = 16, Oi(ua, "StructArrayLayout4f16");
          class ca extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const a2 = 6 * t2, o2 = 3 * t2;
              return this.uint16[a2 + 0] = e2, this.uint16[a2 + 1] = r2, this.uint16[a2 + 2] = n2, this.uint16[a2 + 3] = i2, this.float32[o2 + 2] = s2, t2;
            }
          }
          ca.prototype.bytesPerElement = 12, Oi(ca, "StructArrayLayout4ui1f12");
          class ha extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.uint16[s2 + 0] = e2, this.uint16[s2 + 1] = r2, this.uint16[s2 + 2] = n2, this.uint16[s2 + 3] = i2, t2;
            }
          }
          ha.prototype.bytesPerElement = 8, Oi(ha, "StructArrayLayout4ui8");
          class pa extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 6 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
            }
          }
          pa.prototype.bytesPerElement = 12, Oi(pa, "StructArrayLayout6i12");
          class fa extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
              const p2 = this.length;
              return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
              const f2 = 12 * t2;
              return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
            }
          }
          fa.prototype.bytesPerElement = 24, Oi(fa, "StructArrayLayout4i4ui4i24");
          class da extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 10 * t2, l2 = 5 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.float32[l2 + 2] = i2, this.float32[l2 + 3] = s2, this.float32[l2 + 4] = a2, t2;
            }
          }
          da.prototype.bytesPerElement = 20, Oi(da, "StructArrayLayout3i3f20");
          class ya extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint32[1 * t2 + 0] = e2, t2;
            }
          }
          ya.prototype.bytesPerElement = 4, Oi(ya, "StructArrayLayout1ul4");
          class ma extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
              const f2 = this.length;
              return this.resize(f2 + 1), this.emplace(f2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2) {
              const d2 = 20 * t2, y2 = 10 * t2;
              return this.int16[d2 + 0] = e2, this.int16[d2 + 1] = r2, this.int16[d2 + 2] = n2, this.int16[d2 + 3] = i2, this.int16[d2 + 4] = s2, this.float32[y2 + 3] = a2, this.float32[y2 + 4] = o2, this.float32[y2 + 5] = l2, this.float32[y2 + 6] = u2, this.int16[d2 + 14] = c2, this.uint32[y2 + 8] = h2, this.uint16[d2 + 18] = p2, this.uint16[d2 + 19] = f2, t2;
            }
          }
          ma.prototype.bytesPerElement = 40, Oi(ma, "StructArrayLayout5i4f1i1ul2ui40");
          class ga extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = 8 * t2;
              return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.int16[l2 + 2] = n2, this.int16[l2 + 4] = i2, this.int16[l2 + 5] = s2, this.int16[l2 + 6] = a2, this.int16[l2 + 7] = o2, t2;
            }
          }
          ga.prototype.bytesPerElement = 16, Oi(ga, "StructArrayLayout3i2i2i16");
          class xa extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const a2 = 4 * t2, o2 = 8 * t2;
              return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
            }
          }
          xa.prototype.bytesPerElement = 16, Oi(xa, "StructArrayLayout2f1f2i16");
          class va extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 12 * t2, a2 = 3 * t2;
              return this.uint8[s2 + 0] = e2, this.uint8[s2 + 1] = r2, this.float32[a2 + 1] = n2, this.float32[a2 + 2] = i2, t2;
            }
          }
          va.prototype.bytesPerElement = 12, Oi(va, "StructArrayLayout2ub2f12");
          class ba extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
            }
          }
          ba.prototype.bytesPerElement = 12, Oi(ba, "StructArrayLayout3f12");
          class wa extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
            }
          }
          wa.prototype.bytesPerElement = 6, Oi(wa, "StructArrayLayout3ui6");
          class _a extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2) {
              const w2 = this.length;
              return this.resize(w2 + 1), this.emplace(w2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2) {
              const _2 = 30 * t2, A2 = 15 * t2, S2 = 60 * t2;
              return this.int16[_2 + 0] = e2, this.int16[_2 + 1] = r2, this.int16[_2 + 2] = n2, this.float32[A2 + 2] = i2, this.float32[A2 + 3] = s2, this.uint16[_2 + 8] = a2, this.uint16[_2 + 9] = o2, this.uint32[A2 + 5] = l2, this.uint32[A2 + 6] = u2, this.uint32[A2 + 7] = c2, this.uint16[_2 + 16] = h2, this.uint16[_2 + 17] = p2, this.uint16[_2 + 18] = f2, this.float32[A2 + 10] = d2, this.float32[A2 + 11] = y2, this.uint8[S2 + 48] = m2, this.uint8[S2 + 49] = g2, this.uint8[S2 + 50] = x2, this.uint32[A2 + 13] = v2, this.int16[_2 + 28] = b2, this.uint8[S2 + 58] = w2, t2;
            }
          }
          _a.prototype.bytesPerElement = 60, Oi(_a, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
          class Aa extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2) {
              const B2 = this.length;
              return this.resize(B2 + 1), this.emplace(B2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2, B2) {
              const E2 = 38 * t2, C2 = 19 * t2;
              return this.int16[E2 + 0] = e2, this.int16[E2 + 1] = r2, this.int16[E2 + 2] = n2, this.float32[C2 + 2] = i2, this.float32[C2 + 3] = s2, this.int16[E2 + 8] = a2, this.int16[E2 + 9] = o2, this.int16[E2 + 10] = l2, this.int16[E2 + 11] = u2, this.int16[E2 + 12] = c2, this.int16[E2 + 13] = h2, this.uint16[E2 + 14] = p2, this.uint16[E2 + 15] = f2, this.uint16[E2 + 16] = d2, this.uint16[E2 + 17] = y2, this.uint16[E2 + 18] = m2, this.uint16[E2 + 19] = g2, this.uint16[E2 + 20] = x2, this.uint16[E2 + 21] = v2, this.uint16[E2 + 22] = b2, this.uint16[E2 + 23] = w2, this.uint16[E2 + 24] = _2, this.uint16[E2 + 25] = A2, this.uint16[E2 + 26] = S2, this.uint16[E2 + 27] = k2, this.uint16[E2 + 28] = I2, this.uint32[C2 + 15] = M2, this.float32[C2 + 16] = T2, this.float32[C2 + 17] = z2, this.float32[C2 + 18] = B2, t2;
            }
          }
          Aa.prototype.bytesPerElement = 76, Oi(Aa, "StructArrayLayout3i2f6i15ui1ul3f76");
          class Sa extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.float32[1 * t2 + 0] = e2, t2;
            }
          }
          Sa.prototype.bytesPerElement = 4, Oi(Sa, "StructArrayLayout1f4");
          class ka extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const a2 = 5 * t2;
              return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, this.float32[a2 + 4] = s2, t2;
            }
          }
          ka.prototype.bytesPerElement = 20, Oi(ka, "StructArrayLayout5f20");
          class Ia extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 6 * t2;
              return this.uint32[3 * t2 + 0] = e2, this.uint16[s2 + 2] = r2, this.uint16[s2 + 3] = n2, this.uint16[s2 + 4] = i2, t2;
            }
          }
          Ia.prototype.bytesPerElement = 12, Oi(Ia, "StructArrayLayout1ul3ui12");
          class Ma extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
            }
          }
          Ma.prototype.bytesPerElement = 4, Oi(Ma, "StructArrayLayout2ui4");
          class Ta extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint16[1 * t2 + 0] = e2, t2;
            }
          }
          Ta.prototype.bytesPerElement = 2, Oi(Ta, "StructArrayLayout1ui2");
          class za extends ra {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
            }
          }
          za.prototype.bytesPerElement = 8, Oi(za, "StructArrayLayout2f8");
          class Ba extends ea {
            get projectedAnchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get tileAnchorY() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get x1() {
              return this._structArray.float32[this._pos4 + 3];
            }
            get y1() {
              return this._structArray.float32[this._pos4 + 4];
            }
            get x2() {
              return this._structArray.float32[this._pos4 + 5];
            }
            get y2() {
              return this._structArray.float32[this._pos4 + 6];
            }
            get padding() {
              return this._structArray.int16[this._pos2 + 14];
            }
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 8];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 19];
            }
          }
          Ba.prototype.size = 40;
          class Ea extends ma {
            get(t2) {
              return new Ba(this, t2);
            }
          }
          Oi(Ea, "CollisionBoxArray");
          class Ca extends ea {
            get projectedAnchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
              return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
              return this._structArray.float32[this._pos4 + 3];
            }
            get glyphStartIndex() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get numGlyphs() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get vertexStartIndex() {
              return this._structArray.uint32[this._pos4 + 5];
            }
            get lineStartIndex() {
              return this._structArray.uint32[this._pos4 + 6];
            }
            get lineLength() {
              return this._structArray.uint32[this._pos4 + 7];
            }
            get segment() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get lowerSize() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get upperSize() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get lineOffsetX() {
              return this._structArray.float32[this._pos4 + 10];
            }
            get lineOffsetY() {
              return this._structArray.float32[this._pos4 + 11];
            }
            get writingMode() {
              return this._structArray.uint8[this._pos1 + 48];
            }
            get placedOrientation() {
              return this._structArray.uint8[this._pos1 + 49];
            }
            set placedOrientation(t2) {
              this._structArray.uint8[this._pos1 + 49] = t2;
            }
            get hidden() {
              return this._structArray.uint8[this._pos1 + 50];
            }
            set hidden(t2) {
              this._structArray.uint8[this._pos1 + 50] = t2;
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 13] = t2;
            }
            get associatedIconIndex() {
              return this._structArray.int16[this._pos2 + 28];
            }
            get flipState() {
              return this._structArray.uint8[this._pos1 + 58];
            }
            set flipState(t2) {
              this._structArray.uint8[this._pos1 + 58] = t2;
            }
          }
          Ca.prototype.size = 60;
          class Pa extends _a {
            get(t2) {
              return new Ca(this, t2);
            }
          }
          Oi(Pa, "PlacedSymbolArray");
          class Da extends ea {
            get projectedAnchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
              return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
              return this._structArray.float32[this._pos4 + 3];
            }
            get rightJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 8];
            }
            get centerJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 9];
            }
            get leftJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 10];
            }
            get verticalPlacedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 11];
            }
            get placedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 12];
            }
            get verticalPlacedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 13];
            }
            get key() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get textBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get textBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalTextBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get verticalTextBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get iconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 19];
            }
            get iconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 20];
            }
            get verticalIconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 21];
            }
            get verticalIconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 22];
            }
            get featureIndex() {
              return this._structArray.uint16[this._pos2 + 23];
            }
            get numHorizontalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 24];
            }
            get numVerticalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 25];
            }
            get numIconVertices() {
              return this._structArray.uint16[this._pos2 + 26];
            }
            get numVerticalIconVertices() {
              return this._structArray.uint16[this._pos2 + 27];
            }
            get useRuntimeCollisionCircles() {
              return this._structArray.uint16[this._pos2 + 28];
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 15];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 15] = t2;
            }
            get textOffset0() {
              return this._structArray.float32[this._pos4 + 16];
            }
            get textOffset1() {
              return this._structArray.float32[this._pos4 + 17];
            }
            get collisionCircleDiameter() {
              return this._structArray.float32[this._pos4 + 18];
            }
          }
          Da.prototype.size = 76;
          class Va extends Aa {
            get(t2) {
              return new Da(this, t2);
            }
          }
          Oi(Va, "SymbolInstanceArray");
          class La extends Sa {
            getoffsetX(t2) {
              return this.float32[1 * t2 + 0];
            }
          }
          Oi(La, "GlyphOffsetArray");
          class Fa extends sa {
            getx(t2) {
              return this.int16[2 * t2 + 0];
            }
            gety(t2) {
              return this.int16[2 * t2 + 1];
            }
          }
          Oi(Fa, "SymbolLineVertexArray");
          class Ra extends ea {
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
              return this._structArray.uint16[this._pos2 + 4];
            }
          }
          Ra.prototype.size = 12;
          class ja extends Ia {
            get(t2) {
              return new Ra(this, t2);
            }
          }
          Oi(ja, "FeatureIndexArray");
          class $a extends Ma {
            geta_centroid_pos0(t2) {
              return this.uint16[2 * t2 + 0];
            }
            geta_centroid_pos1(t2) {
              return this.uint16[2 * t2 + 1];
            }
          }
          Oi($a, "FillExtrusionCentroidArray");
          const Ua = na([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), Oa = na([{ name: "a_dash", components: 4, type: "Uint16" }]);
          var qa = {}, Na = { get exports() {
            return qa;
          }, set exports(t2) {
            qa = t2;
          } }, Ga = {};
          ({ get exports() {
            return Ga;
          }, set exports(t2) {
            Ga = t2;
          } }).exports = function(t2, e2) {
            var r2, n2, i2, s2, a2, o2, l2, u2;
            for (n2 = t2.length - (r2 = 3 & t2.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
              l2 = 255 & t2.charCodeAt(u2) | (255 & t2.charCodeAt(++u2)) << 8 | (255 & t2.charCodeAt(++u2)) << 16 | (255 & t2.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
            switch (l2 = 0, r2) {
              case 3:
                l2 ^= (255 & t2.charCodeAt(u2 + 2)) << 16;
              case 2:
                l2 ^= (255 & t2.charCodeAt(u2 + 1)) << 8;
              case 1:
                i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t2.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
            }
            return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
          };
          var Za = {};
          ({ get exports() {
            return Za;
          }, set exports(t2) {
            Za = t2;
          } }).exports = function(t2, e2) {
            for (var r2, n2 = t2.length, i2 = e2 ^ n2, s2 = 0; n2 >= 4; )
              r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(s2) | (255 & t2.charCodeAt(++s2)) << 8 | (255 & t2.charCodeAt(++s2)) << 16 | (255 & t2.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
            switch (n2) {
              case 3:
                i2 ^= (255 & t2.charCodeAt(s2 + 2)) << 16;
              case 2:
                i2 ^= (255 & t2.charCodeAt(s2 + 1)) << 8;
              case 1:
                i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
            }
            return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
          };
          var Xa = Ga, Ka = Za;
          Na.exports = Xa, qa.murmur3 = Xa, qa.murmur2 = Ka;
          class Ya {
            constructor() {
              this.ids = [], this.positions = [], this.indexed = false;
            }
            add(t2, e2, r2, n2) {
              this.ids.push(Ha(t2)), this.positions.push(e2, r2, n2);
            }
            getPositions(t2) {
              const e2 = Ha(t2);
              let r2 = 0, n2 = this.ids.length - 1;
              for (; r2 < n2; ) {
                const t3 = r2 + n2 >> 1;
                this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
              }
              const i2 = [];
              for (; this.ids[r2] === e2; )
                i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
              return i2;
            }
            static serialize(t2, e2) {
              const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
              return Wa(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
            }
            static deserialize(t2) {
              const e2 = new Ya();
              return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
            }
          }
          function Ha(t2) {
            const e2 = +t2;
            return !isNaN(e2) && Number.MIN_SAFE_INTEGER <= e2 && e2 <= Number.MAX_SAFE_INTEGER ? e2 : qa(String(t2));
          }
          function Wa(t2, e2, r2, n2) {
            for (; r2 < n2; ) {
              const i2 = t2[r2 + n2 >> 1];
              let s2 = r2 - 1, a2 = n2 + 1;
              for (; ; ) {
                do {
                  s2++;
                } while (t2[s2] < i2);
                do {
                  a2--;
                } while (t2[a2] > i2);
                if (s2 >= a2)
                  break;
                Ja(t2, s2, a2), Ja(e2, 3 * s2, 3 * a2), Ja(e2, 3 * s2 + 1, 3 * a2 + 1), Ja(e2, 3 * s2 + 2, 3 * a2 + 2);
              }
              a2 - r2 < n2 - a2 ? (Wa(t2, e2, r2, a2), r2 = a2 + 1) : (Wa(t2, e2, a2 + 1, n2), n2 = a2);
            }
          }
          function Ja(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          Oi(Ya, "FeaturePositionMap");
          class Qa {
            constructor(t2) {
              this.gl = t2.gl, this.initialized = false;
            }
            fetchUniformLocation(t2, e2) {
              return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t2, e2), this.initialized = true), !!this.location;
            }
          }
          class to extends Qa {
            constructor(t2) {
              super(t2), this.current = 0;
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1f(this.location, r2));
            }
          }
          class eo extends Qa {
            constructor(t2) {
              super(t2), this.current = [0, 0, 0, 0];
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] && r2[3] === this.current[3] || (this.current = r2, this.gl.uniform4f(this.location, r2[0], r2[1], r2[2], r2[3])));
            }
          }
          class ro extends Qa {
            constructor(t2) {
              super(t2), this.current = Me.transparent;
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2.r === this.current.r && r2.g === this.current.g && r2.b === this.current.b && r2.a === this.current.a || (this.current = r2, this.gl.uniform4f(this.location, r2.r, r2.g, r2.b, r2.a)));
            }
          }
          const no = new Float32Array(16), io = new Float32Array(9), so = new Float32Array(4);
          function ao(t2) {
            return [Qs(255 * t2.r, 255 * t2.g), Qs(255 * t2.b, 255 * t2.a)];
          }
          class oo {
            constructor(t2, e2, r2) {
              this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
            }
            setUniform(t2, e2, r2, n2, i2) {
              e2.set(t2, i2, n2.constantOr(this.value));
            }
            getBinding(t2, e2) {
              return "color" === this.type ? new ro(t2) : new to(t2);
            }
          }
          class lo {
            constructor(t2, e2) {
              this.uniformNames = e2.map((t3) => `u_${t3}`), this.pattern = null, this.pixelRatio = 1;
            }
            setConstantPatternPositions(t2) {
              this.pixelRatio = t2.pixelRatio || 1, this.pattern = t2.tl.concat(t2.br);
            }
            setUniform(t2, e2, r2, n2, i2) {
              const s2 = "u_pattern" === i2 || "u_dash" === i2 ? this.pattern : "u_pixel_ratio" === i2 ? this.pixelRatio : null;
              s2 && e2.set(t2, i2, s2);
            }
            getBinding(t2, e2) {
              return "u_pattern" === e2 || "u_dash" === e2 ? new eo(t2) : new to(t2);
            }
          }
          class uo {
            constructor(t2, e2, r2, n2) {
              this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
            }
            populatePaintArray(t2, e2, r2, n2, i2, s2) {
              const a2 = this.paintVertexArray.length, o2 = this.expression.evaluate(new $s(0), e2, {}, i2, n2, s2);
              this.paintVertexArray.resize(t2), this._setPaintValue(a2, t2, o2);
            }
            updatePaintArray(t2, e2, r2, n2, i2) {
              const s2 = this.expression.evaluate({ zoom: 0 }, r2, n2, void 0, i2);
              this._setPaintValue(t2, e2, s2);
            }
            _setPaintValue(t2, e2, r2) {
              if ("color" === this.type) {
                const n2 = ao(r2);
                for (let r3 = t2; r3 < e2; r3++)
                  this.paintVertexArray.emplace(r3, n2[0], n2[1]);
              } else {
                for (let n2 = t2; n2 < e2; n2++)
                  this.paintVertexArray.emplace(n2, r2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class co {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
            }
            populatePaintArray(t2, e2, r2, n2, i2, s2) {
              const a2 = this.expression.evaluate(new $s(this.zoom), e2, {}, i2, n2, s2), o2 = this.expression.evaluate(new $s(this.zoom + 1), e2, {}, i2, n2, s2), l2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t2), this._setPaintValue(l2, t2, a2, o2);
            }
            updatePaintArray(t2, e2, r2, n2, i2) {
              const s2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2, void 0, i2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2, void 0, i2);
              this._setPaintValue(t2, e2, s2, a2);
            }
            _setPaintValue(t2, e2, r2, n2) {
              if ("color" === this.type) {
                const i2 = ao(r2), s2 = ao(n2);
                for (let r3 = t2; r3 < e2; r3++)
                  this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
              } else {
                for (let i2 = t2; i2 < e2; i2++)
                  this.paintVertexArray.emplace(i2, r2, n2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t2, e2, r2, n2, i2) {
              const s2 = this.useIntegerZoom ? Math.floor(r2.zoom) : r2.zoom, a2 = S(this.expression.interpolationFactor(s2, this.zoom, this.zoom + 1), 0, 1);
              e2.set(t2, i2, a2);
            }
            getBinding(t2, e2) {
              return new to(t2);
            }
          }
          class ho {
            constructor(t2, e2, r2, n2, i2) {
              this.expression = t2, this.layerId = i2, this.paintVertexAttributes = ("array" === r2 ? Oa : Ua).members;
              for (let t3 = 0; t3 < e2.length; ++t3)
                ;
              this.paintVertexArray = new n2();
            }
            populatePaintArray(t2, e2, r2) {
              const n2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
            }
            updatePaintArray(t2, e2, r2, n2, i2, s2) {
              this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], s2);
            }
            _setPaintValues(t2, e2, r2, n2) {
              if (!n2 || !r2)
                return;
              const i2 = n2[r2];
              if (!i2)
                return;
              const { tl: s2, br: a2, pixelRatio: o2 } = i2;
              for (let r3 = t2; r3 < e2; r3++)
                this.paintVertexArray.emplace(r3, s2[0], s2[1], a2[0], a2[1], o2);
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class po {
            constructor(t2, e2, r2 = () => true) {
              this.binders = {}, this._buffers = [];
              const n2 = [];
              for (const i2 in t2.paint._values) {
                if (!r2(i2))
                  continue;
                const s2 = t2.paint.get(i2);
                if (!(s2 instanceof Xs && En(s2.property.specification)))
                  continue;
                const a2 = mo(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = !!s2.property.useIntegerZoom, c2 = "line-dasharray" === i2 || i2.endsWith("pattern"), h2 = "line-dasharray" === i2 && "constant" !== t2.layout.get("line-cap").value.kind;
                if ("constant" !== o2.kind || h2)
                  if ("source" === o2.kind || h2 || c2) {
                    const e3 = vo(i2, l2, "source");
                    this.binders[i2] = c2 ? new ho(o2, a2, l2, e3, t2.id) : new uo(o2, a2, l2, e3), n2.push(`/a_${i2}`);
                  } else {
                    const t3 = vo(i2, l2, "composite");
                    this.binders[i2] = new co(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
                  }
                else
                  this.binders[i2] = c2 ? new lo(o2.value, a2) : new oo(o2.value, a2, l2), n2.push(`/u_${i2}`);
              }
              this.cacheKey = n2.sort().join("");
            }
            getMaxValue(t2) {
              const e2 = this.binders[t2];
              return e2 instanceof uo || e2 instanceof co ? e2.maxValue : 0;
            }
            populatePaintArrays(t2, e2, r2, n2, i2, s2) {
              for (const a2 in this.binders) {
                const o2 = this.binders[a2];
                (o2 instanceof uo || o2 instanceof co || o2 instanceof ho) && o2.populatePaintArray(t2, e2, r2, n2, i2, s2);
              }
            }
            setConstantPatternPositions(t2) {
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                r2 instanceof lo && r2.setConstantPatternPositions(t2);
              }
            }
            updatePaintArrays(t2, e2, r2, n2, i2, s2) {
              let a2 = false;
              for (const o2 in t2) {
                const l2 = e2.getPositions(o2);
                for (const e3 of l2) {
                  const l3 = r2.feature(e3.index);
                  for (const r3 in this.binders) {
                    const u2 = this.binders[r3];
                    if ((u2 instanceof uo || u2 instanceof co || u2 instanceof ho) && true === u2.expression.isStateDependent) {
                      const c2 = n2.paint.get(r3);
                      u2.expression = c2.value, u2.updatePaintArray(e3.start, e3.end, l3, t2[o2], i2, s2), a2 = true;
                    }
                  }
                }
              }
              return a2;
            }
            defines() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                (r2 instanceof oo || r2 instanceof lo) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
              }
              return t2;
            }
            getBinderAttributes() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (r2 instanceof uo || r2 instanceof co || r2 instanceof ho)
                  for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++)
                    t2.push(r2.paintVertexAttributes[e3].name);
              }
              return t2;
            }
            getBinderUniforms() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (r2 instanceof oo || r2 instanceof lo || r2 instanceof co)
                  for (const e3 of r2.uniformNames)
                    t2.push(e3);
              }
              return t2;
            }
            getPaintVertexBuffers() {
              return this._buffers;
            }
            getUniforms(t2) {
              const e2 = [];
              for (const r2 in this.binders) {
                const n2 = this.binders[r2];
                if (n2 instanceof oo || n2 instanceof lo || n2 instanceof co)
                  for (const i2 of n2.uniformNames)
                    e2.push({ name: i2, property: r2, binding: n2.getBinding(t2, i2) });
              }
              return e2;
            }
            setUniforms(t2, e2, r2, n2, i2) {
              for (const { name: e3, property: s2, binding: a2 } of r2)
                this.binders[s2].setUniform(t2, a2, i2, n2.get(s2), e3);
            }
            updatePaintBuffers() {
              this._buffers = [];
              for (const t2 in this.binders) {
                const e2 = this.binders[t2];
                (e2 instanceof uo || e2 instanceof co || e2 instanceof ho) && e2.paintVertexBuffer && this._buffers.push(e2.paintVertexBuffer);
              }
            }
            upload(t2) {
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                (r2 instanceof uo || r2 instanceof co || r2 instanceof ho) && r2.upload(t2);
              }
              this.updatePaintBuffers();
            }
            destroy() {
              for (const t2 in this.binders) {
                const e2 = this.binders[t2];
                (e2 instanceof uo || e2 instanceof co || e2 instanceof ho) && e2.destroy();
              }
            }
          }
          class fo {
            constructor(t2, e2, r2 = () => true) {
              this.programConfigurations = {};
              for (const n2 of t2)
                this.programConfigurations[n2.id] = new po(n2, e2, r2);
              this.needsUpload = false, this._featureMap = new Ya(), this._bufferOffset = 0;
            }
            populatePaintArrays(t2, e2, r2, n2, i2, s2, a2) {
              for (const r3 in this.programConfigurations)
                this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2, a2);
              void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
            }
            updatePaintArrays(t2, e2, r2, n2, i2) {
              for (const s2 of r2)
                this.needsUpload = this.programConfigurations[s2.id].updatePaintArrays(t2, this._featureMap, e2, s2, n2, i2) || this.needsUpload;
            }
            get(t2) {
              return this.programConfigurations[t2];
            }
            upload(t2) {
              if (this.needsUpload) {
                for (const e2 in this.programConfigurations)
                  this.programConfigurations[e2].upload(t2);
                this.needsUpload = false;
              }
            }
            destroy() {
              for (const t2 in this.programConfigurations)
                this.programConfigurations[t2].destroy();
            }
          }
          const yo = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
          function mo(t2, e2) {
            return yo[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
          }
          const go = { "line-pattern": { source: ca, composite: ca }, "fill-pattern": { source: ca, composite: ca }, "fill-extrusion-pattern": { source: ca, composite: ca }, "line-dasharray": { source: ha, composite: ha } }, xo = { color: { source: za, composite: ua }, number: { source: Sa, composite: za } };
          function vo(t2, e2, r2) {
            const n2 = go[t2];
            return n2 && n2[r2] || xo[e2][r2];
          }
          Oi(oo, "ConstantBinder"), Oi(lo, "PatternConstantBinder"), Oi(uo, "SourceExpressionBinder"), Oi(ho, "PatternCompositeBinder"), Oi(co, "CompositeExpressionBinder"), Oi(po, "ProgramConfiguration", { omit: ["_buffers"] }), Oi(fo, "ProgramConfigurationSet");
          const bo = "-transition";
          class wo extends Yt {
            constructor(t2, e2) {
              if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, "custom" !== t2.type && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && "sky" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new Zs(e2.layout)), e2.paint)) {
                this._transitionablePaint = new qs(e2.paint);
                for (const e3 in t2.paint)
                  this.setPaintProperty(e3, t2.paint[e3], { validate: false });
                for (const e3 in t2.layout)
                  this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
                this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ks(e2.paint);
              }
            }
            getLayoutProperty(t2) {
              return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
            }
            setLayoutProperty(t2, e2, r2 = {}) {
              null != e2 && this._validate(Li, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || ("visibility" !== t2 ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
            }
            getPaintProperty(t2) {
              return L(t2, bo) ? this._transitionablePaint.getTransition(t2.slice(0, -bo.length)) : this._transitionablePaint.getValue(t2);
            }
            setPaintProperty(t2, e2, r2 = {}) {
              if (null != e2 && this._validate(Vi, `layers.${this.id}.paint.${t2}`, t2, e2, r2))
                return false;
              if (L(t2, bo))
                return this._transitionablePaint.setTransition(t2.slice(0, -bo.length), e2 || void 0), false;
              {
                const r3 = this._transitionablePaint._values[t2], n2 = r3.value.isDataDriven(), i2 = r3.value;
                this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
                const s2 = this._transitionablePaint._values[t2].value, a2 = s2.isDataDriven(), o2 = L(t2, "pattern") || "line-dasharray" === t2;
                return a2 || n2 || o2 || this._handleOverridablePaintPropertyUpdate(t2, i2, s2);
              }
            }
            _handleSpecialPaintPropertyUpdate(t2) {
            }
            getProgramIds() {
              return null;
            }
            getProgramConfiguration(t2) {
              return null;
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return false;
            }
            isHidden(t2) {
              return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t2) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
            }
            hasTransition() {
              return this._transitioningPaint.hasTransition();
            }
            recalculate(t2, e2) {
              this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
            }
            serialize() {
              const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
              return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), R(t2, (t3, e2) => !(void 0 === t3 || "layout" === e2 && !Object.keys(t3).length || "paint" === e2 && !Object.keys(t3).length));
            }
            _validate(t2, e2, r2, n2, i2 = {}) {
              return (!i2 || false !== i2.validate) && Ri(this, t2.call(Di, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: Ht, style: { glyphs: true, sprite: true } }));
            }
            is3D() {
              return false;
            }
            isSky() {
              return false;
            }
            isTileClipped() {
              return false;
            }
            hasOffscreenPass() {
              return false;
            }
            resize() {
            }
            isStateDependent() {
              for (const t2 in this.paint._values) {
                const e2 = this.paint.get(t2);
                if (e2 instanceof Xs && En(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent)
                  return true;
              }
              return false;
            }
            compileFilter() {
              this._filterCompiled || (this._featureFilter = ai(this.filter), this._filterCompiled = true);
            }
            invalidateCompiledFilter() {
              this._filterCompiled = false;
            }
            dynamicFilter() {
              return this._featureFilter.dynamicFilter;
            }
            dynamicFilterNeedsFeature() {
              return this._featureFilter.needFeature;
            }
          }
          const _o = na([{ name: "a_pos", components: 2, type: "Int16" }], 4), Ao = na([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
          class So {
            constructor(t2 = []) {
              this.segments = t2;
            }
            prepareSegment(t2, e2, r2, n2) {
              let i2 = this.segments[this.segments.length - 1];
              return t2 > So.MAX_VERTEX_ARRAY_LENGTH && U(`Max vertices per segment is ${So.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > So.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
            }
            get() {
              return this.segments;
            }
            destroy() {
              for (const t2 of this.segments)
                for (const e2 in t2.vaos)
                  t2.vaos[e2].destroy();
            }
            static simpleSegment(t2, e2, r2, n2) {
              return new So([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
            }
          }
          So.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Oi(So, "SegmentVector");
          var ko = 8192;
          class Io {
            constructor(t2, e2) {
              t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
            }
            setNorthEast(t2) {
              return this._ne = t2 instanceof ru ? new ru(t2.lng, t2.lat) : ru.convert(t2), this;
            }
            setSouthWest(t2) {
              return this._sw = t2 instanceof ru ? new ru(t2.lng, t2.lat) : ru.convert(t2), this;
            }
            extend(t2) {
              const e2 = this._sw, r2 = this._ne;
              let n2, i2;
              if (t2 instanceof ru)
                n2 = t2, i2 = t2;
              else {
                if (!(t2 instanceof Io))
                  return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(Io.convert(t2)) : this.extend(ru.convert(t2)) : "object" == typeof t2 && null !== t2 && t2.hasOwnProperty("lat") && (t2.hasOwnProperty("lon") || t2.hasOwnProperty("lng")) ? this.extend(ru.convert(t2)) : this;
                if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2)
                  return this;
              }
              return e2 || r2 ? (e2.lng = Math.min(n2.lng, e2.lng), e2.lat = Math.min(n2.lat, e2.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new ru(n2.lng, n2.lat), this._ne = new ru(i2.lng, i2.lat)), this;
            }
            getCenter() {
              return new ru((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
              return this._sw;
            }
            getNorthEast() {
              return this._ne;
            }
            getNorthWest() {
              return new ru(this.getWest(), this.getNorth());
            }
            getSouthEast() {
              return new ru(this.getEast(), this.getSouth());
            }
            getWest() {
              return this._sw.lng;
            }
            getSouth() {
              return this._sw.lat;
            }
            getEast() {
              return this._ne.lng;
            }
            getNorth() {
              return this._ne.lat;
            }
            toArray() {
              return [this._sw.toArray(), this._ne.toArray()];
            }
            toString() {
              return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
              return !(this._sw && this._ne);
            }
            contains(t2) {
              const { lng: e2, lat: r2 } = ru.convert(t2);
              let n2 = this._sw.lng <= e2 && e2 <= this._ne.lng;
              return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
            }
            static convert(t2) {
              return !t2 || t2 instanceof Io ? t2 : new Io(t2);
            }
          }
          var Mo = 1e-6, To = "undefined" != typeof Float32Array ? Float32Array : Array;
          function zo() {
            var t2 = new To(9);
            return To != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
          }
          function Bo(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = r2[0], f2 = r2[1], d2 = r2[2], y2 = r2[3], m2 = r2[4], g2 = r2[5], x2 = r2[6], v2 = r2[7], b2 = r2[8];
            return t2[0] = p2 * n2 + f2 * a2 + d2 * u2, t2[1] = p2 * i2 + f2 * o2 + d2 * c2, t2[2] = p2 * s2 + f2 * l2 + d2 * h2, t2[3] = y2 * n2 + m2 * a2 + g2 * u2, t2[4] = y2 * i2 + m2 * o2 + g2 * c2, t2[5] = y2 * s2 + m2 * l2 + g2 * h2, t2[6] = x2 * n2 + v2 * a2 + b2 * u2, t2[7] = x2 * i2 + v2 * o2 + b2 * c2, t2[8] = x2 * s2 + v2 * l2 + b2 * h2, t2;
          }
          function Eo(t2) {
            return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }
          function Co(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - s2 * o2, A2 = i2 * u2 - s2 * l2, S2 = c2 * y2 - h2 * d2, k2 = c2 * m2 - p2 * d2, I2 = c2 * g2 - f2 * d2, M2 = h2 * m2 - p2 * y2, T2 = h2 * g2 - f2 * y2, z2 = p2 * g2 - f2 * m2, B2 = x2 * z2 - v2 * T2 + b2 * M2 + w2 * I2 - _2 * k2 + A2 * S2;
            return B2 ? (t2[0] = (o2 * z2 - l2 * T2 + u2 * M2) * (B2 = 1 / B2), t2[1] = (i2 * T2 - n2 * z2 - s2 * M2) * B2, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * B2, t2[3] = (p2 * _2 - h2 * A2 - f2 * w2) * B2, t2[4] = (l2 * I2 - a2 * z2 - u2 * k2) * B2, t2[5] = (r2 * z2 - i2 * I2 + s2 * k2) * B2, t2[6] = (m2 * b2 - d2 * A2 - g2 * v2) * B2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v2) * B2, t2[8] = (a2 * T2 - o2 * I2 + u2 * S2) * B2, t2[9] = (n2 * I2 - r2 * T2 - s2 * S2) * B2, t2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * B2, t2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * B2, t2[12] = (o2 * k2 - a2 * M2 - l2 * S2) * B2, t2[13] = (r2 * M2 - n2 * k2 + i2 * S2) * B2, t2[14] = (y2 * v2 - d2 * w2 - m2 * x2) * B2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * B2, t2) : null;
          }
          function Po(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
            return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
          }
          function Do(t2, e2, r2) {
            var n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
            return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y2 + u2 * m2 + f2 * g2 + e2[14], t2[15] = a2 * y2 + c2 * m2 + d2 * g2 + e2[15]), t2;
          }
          function Vo(t2, e2, r2) {
            var n2 = r2[0], i2 = r2[1], s2 = r2[2];
            return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
          }
          function Lo(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
            return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
          }
          function Fo(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
            return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 - u2 * n2, t2[1] = a2 * i2 - c2 * n2, t2[2] = o2 * i2 - h2 * n2, t2[3] = l2 * i2 - p2 * n2, t2[8] = s2 * n2 + u2 * i2, t2[9] = a2 * n2 + c2 * i2, t2[10] = o2 * n2 + h2 * i2, t2[11] = l2 * n2 + p2 * i2, t2;
          }
          function Ro(t2, e2) {
            return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }
          function jo(t2, e2, r2) {
            var n2, i2, s2, a2 = r2[0], o2 = r2[1], l2 = r2[2], u2 = Math.hypot(a2, o2, l2);
            return u2 < Mo ? null : (a2 *= u2 = 1 / u2, o2 *= u2, l2 *= u2, n2 = Math.sin(e2), i2 = Math.cos(e2), t2[0] = a2 * a2 * (s2 = 1 - i2) + i2, t2[1] = o2 * a2 * s2 + l2 * n2, t2[2] = l2 * a2 * s2 - o2 * n2, t2[3] = 0, t2[4] = a2 * o2 * s2 - l2 * n2, t2[5] = o2 * o2 * s2 + i2, t2[6] = l2 * o2 * s2 + a2 * n2, t2[7] = 0, t2[8] = a2 * l2 * s2 + o2 * n2, t2[9] = o2 * l2 * s2 - a2 * n2, t2[10] = l2 * l2 * s2 + i2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2);
          }
          Math.hypot || (Math.hypot = function() {
            for (var t2 = 0, e2 = arguments.length; e2--; )
              t2 += arguments[e2] * arguments[e2];
            return Math.sqrt(t2);
          });
          var $o = Po;
          function Uo() {
            var t2 = new To(3);
            return To != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
          }
          function Oo(t2) {
            var e2 = new To(3);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
          }
          function qo(t2) {
            return Math.hypot(t2[0], t2[1], t2[2]);
          }
          function No(t2, e2, r2) {
            var n2 = new To(3);
            return n2[0] = t2, n2[1] = e2, n2[2] = r2, n2;
          }
          function Go(t2, e2, r2) {
            return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
          }
          function Zo(t2, e2, r2) {
            return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
          }
          function Xo(t2, e2, r2) {
            return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2;
          }
          function Ko(t2, e2, r2) {
            return t2[0] = Math.min(e2[0], r2[0]), t2[1] = Math.min(e2[1], r2[1]), t2[2] = Math.min(e2[2], r2[2]), t2;
          }
          function Yo(t2, e2, r2) {
            return t2[0] = Math.max(e2[0], r2[0]), t2[1] = Math.max(e2[1], r2[1]), t2[2] = Math.max(e2[2], r2[2]), t2;
          }
          function Ho(t2, e2, r2) {
            return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
          }
          function Wo(t2, e2, r2, n2) {
            return t2[0] = e2[0] + r2[0] * n2, t2[1] = e2[1] + r2[1] * n2, t2[2] = e2[2] + r2[2] * n2, t2;
          }
          function Jo(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = r2 * r2 + n2 * n2 + i2 * i2;
            return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e2[0] * s2, t2[1] = e2[1] * s2, t2[2] = e2[2] * s2, t2;
          }
          function Qo(t2, e2) {
            return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
          }
          function tl(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[0], o2 = r2[1], l2 = r2[2];
            return t2[0] = i2 * l2 - s2 * o2, t2[1] = s2 * a2 - n2 * l2, t2[2] = n2 * o2 - i2 * a2, t2;
          }
          function el(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
            return t2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / (a2 = a2 || 1), t2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / a2, t2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / a2, t2;
          }
          function rl(t2, e2, r2) {
            var n2 = r2[0], i2 = r2[1], s2 = r2[2], a2 = e2[0], o2 = e2[1], l2 = e2[2], u2 = i2 * l2 - s2 * o2, c2 = s2 * a2 - n2 * l2, h2 = n2 * o2 - i2 * a2, p2 = i2 * h2 - s2 * c2, f2 = s2 * u2 - n2 * h2, d2 = n2 * c2 - i2 * u2, y2 = 2 * r2[3];
            return c2 *= y2, h2 *= y2, f2 *= 2, d2 *= 2, t2[0] = a2 + (u2 *= y2) + (p2 *= 2), t2[1] = o2 + c2 + f2, t2[2] = l2 + h2 + d2, t2;
          }
          var nl, il = Zo, sl = Xo, al = qo;
          function ol(t2, e2, r2) {
            return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2[3] = e2[3] * r2, t2;
          }
          function ll(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r2 * r2 + n2 * n2 + i2 * i2 + s2 * s2;
            return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = r2 * a2, t2[1] = n2 * a2, t2[2] = i2 * a2, t2[3] = s2 * a2, t2;
          }
          function ul(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
            return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
          }
          function cl() {
            var t2 = new To(4);
            return To != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
          }
          function hl(t2) {
            return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
          }
          function pl(t2, e2, r2) {
            r2 *= 0.5;
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
            return t2[0] = n2 * l2 + a2 * o2, t2[1] = i2 * l2 + s2 * o2, t2[2] = s2 * l2 - i2 * o2, t2[3] = a2 * l2 - n2 * o2, t2;
          }
          function fl(t2, e2, r2) {
            r2 *= 0.5;
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
            return t2[0] = n2 * l2 - s2 * o2, t2[1] = i2 * l2 + a2 * o2, t2[2] = s2 * l2 + n2 * o2, t2[3] = a2 * l2 - i2 * o2, t2;
          }
          Uo(), nl = new To(4), To != Float32Array && (nl[0] = 0, nl[1] = 0, nl[2] = 0, nl[3] = 0);
          var dl = ll;
          Uo(), No(1, 0, 0), No(0, 1, 0), cl(), cl(), zo();
          const yl = na([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: ml } = yl, gl = na([{ name: "a_pos_3", components: 3, type: "Int16" }]);
          var xl = na([{ name: "a_pos", type: "Int16", components: 2 }]);
          class vl {
            constructor(t2, e2) {
              this.pos = t2, this.dir = e2;
            }
            intersectsPlane(t2, e2, r2) {
              const n2 = Qo(e2, this.dir);
              if (Math.abs(n2) < 1e-6)
                return false;
              const i2 = ((t2[0] - this.pos[0]) * e2[0] + (t2[1] - this.pos[1]) * e2[1] + (t2[2] - this.pos[2]) * e2[2]) / n2;
              return r2[0] = this.pos[0] + this.dir[0] * i2, r2[1] = this.pos[1] + this.dir[1] * i2, r2[2] = this.pos[2] + this.dir[2] * i2, true;
            }
            closestPointOnSphere(t2, e2, r2) {
              if (function(t3, e3) {
                var r3 = t3[0], n3 = t3[1], i3 = t3[2], s3 = e3[0], a3 = e3[1], o3 = e3[2];
                return Math.abs(r3 - s3) <= Mo * Math.max(1, Math.abs(r3), Math.abs(s3)) && Math.abs(n3 - a3) <= Mo * Math.max(1, Math.abs(n3), Math.abs(a3)) && Math.abs(i3 - o3) <= Mo * Math.max(1, Math.abs(i3), Math.abs(o3));
              }(this.pos, t2) || 0 === e2)
                return r2[0] = r2[1] = r2[2] = 0, false;
              const [n2, i2, s2] = this.dir, a2 = this.pos[0] - t2[0], o2 = this.pos[1] - t2[1], l2 = this.pos[2] - t2[2], u2 = n2 * n2 + i2 * i2 + s2 * s2, c2 = 2 * (a2 * n2 + o2 * i2 + l2 * s2), h2 = c2 * c2 - 4 * u2 * (a2 * a2 + o2 * o2 + l2 * l2 - e2 * e2);
              if (h2 < 0) {
                const t3 = Math.max(-c2 / 2, 0), u3 = a2 + n2 * t3, h3 = o2 + i2 * t3, p2 = l2 + s2 * t3, f2 = Math.hypot(u3, h3, p2);
                return r2[0] = u3 * e2 / f2, r2[1] = h3 * e2 / f2, r2[2] = p2 * e2 / f2, false;
              }
              {
                const t3 = (-c2 - Math.sqrt(h2)) / (2 * u2);
                if (t3 < 0) {
                  const t4 = Math.hypot(a2, o2, l2);
                  return r2[0] = a2 * e2 / t4, r2[1] = o2 * e2 / t4, r2[2] = l2 * e2 / t4, false;
                }
                return r2[0] = a2 + n2 * t3, r2[1] = o2 + i2 * t3, r2[2] = l2 + s2 * t3, true;
              }
            }
          }
          class bl {
            constructor(t2, e2, r2, n2, i2) {
              this.TL = t2, this.TR = e2, this.BR = r2, this.BL = n2, this.horizon = i2;
            }
            static fromInvProjectionMatrix(t2, e2, r2) {
              const n2 = [-1, 1, 1], i2 = [1, 1, 1], s2 = [1, -1, 1], a2 = [-1, -1, 1], o2 = el(n2, n2, t2), l2 = el(i2, i2, t2), u2 = el(s2, s2, t2), c2 = el(a2, a2, t2);
              return new bl(o2, l2, u2, c2, e2 / r2);
            }
          }
          class wl {
            constructor(t2, e2) {
              this.points = t2, this.planes = e2;
            }
            static fromInvProjectionMatrix(t2, e2, r2, n2) {
              const i2 = Math.pow(2, r2), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r3) => {
                const s3 = ul([], r3, t2), a3 = 1 / s3[3] / e2 * i2;
                return function(t3, e3, r4) {
                  return t3[0] = e3[0] * r4[0], t3[1] = e3[1] * r4[1], t3[2] = e3[2] * r4[2], t3[3] = e3[3] * r4[3], t3;
                }(s3, s3, [a3, a3, n2 ? 1 / s3[3] : a3, a3]);
              }), a2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
                const e3 = Jo([], tl([], il([], s2[t3[0]], s2[t3[1]]), il([], s2[t3[2]], s2[t3[1]]))), r3 = -Qo(e3, s2[t3[1]]);
                return e3.concat(r3);
              });
              return new wl(s2, a2);
            }
          }
          class _l {
            static fromPoints(t2) {
              const e2 = [1 / 0, 1 / 0, 1 / 0], r2 = [-1 / 0, -1 / 0, -1 / 0];
              for (const n2 of t2)
                Ko(e2, e2, n2), Yo(r2, r2, n2);
              return new _l(e2, r2);
            }
            static applyTransform(t2, e2) {
              const r2 = t2.getCorners();
              for (let t3 = 0; t3 < r2.length; ++t3)
                el(r2[t3], r2[t3], e2);
              return _l.fromPoints(r2);
            }
            constructor(t2, e2) {
              this.min = t2, this.max = e2, this.center = Ho([], Go([], this.min, this.max), 0.5);
            }
            quadrant(t2) {
              const e2 = [t2 % 2 == 0, t2 < 2], r2 = Oo(this.min), n2 = Oo(this.max);
              for (let t3 = 0; t3 < e2.length; t3++)
                r2[t3] = e2[t3] ? this.min[t3] : this.center[t3], n2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
              return n2[2] = this.max[2], new _l(r2, n2);
            }
            distanceX(t2) {
              return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
            }
            distanceY(t2) {
              return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
            }
            distanceZ(t2) {
              return Math.max(Math.min(this.max[2], t2[2]), this.min[2]) - t2[2];
            }
            getCorners() {
              const t2 = this.min, e2 = this.max;
              return [[t2[0], t2[1], t2[2]], [e2[0], t2[1], t2[2]], [e2[0], e2[1], t2[2]], [t2[0], e2[1], t2[2]], [t2[0], t2[1], e2[2]], [e2[0], t2[1], e2[2]], [e2[0], e2[1], e2[2]], [t2[0], e2[1], e2[2]]];
            }
            intersects(t2) {
              const e2 = this.getCorners();
              let r2 = true;
              for (let n2 = 0; n2 < t2.planes.length; n2++) {
                const i2 = t2.planes[n2];
                let s2 = 0;
                for (let t3 = 0; t3 < e2.length; t3++)
                  s2 += Qo(i2, e2[t3]) + i2[3] >= 0;
                if (0 === s2)
                  return 0;
                s2 !== e2.length && (r2 = false);
              }
              if (r2)
                return 2;
              for (let e3 = 0; e3 < 3; e3++) {
                let r3 = Number.MAX_VALUE, n2 = -Number.MAX_VALUE;
                for (let i2 = 0; i2 < t2.points.length; i2++) {
                  const s2 = t2.points[i2][e3] - this.min[e3];
                  r3 = Math.min(r3, s2), n2 = Math.max(n2, s2);
                }
                if (n2 < 0 || r3 > this.max[e3] - this.min[e3])
                  return 0;
              }
              return 1;
            }
          }
          const Al = ko / Math.PI / 2, Sl = 64, kl = [Sl, 32, 16], Il = -Al, Ml = Al, Tl = [new _l([Il, Il, Il], [Ml, Ml, Ml]), new _l([Il, Il, Il], [0, 0, Ml]), new _l([0, Il, Il], [Ml, 0, Ml]), new _l([Il, 0, Il], [0, Ml, Ml]), new _l([0, 0, Il], [Ml, Ml, Ml])];
          function zl(t2) {
            return t2 * Al / tu;
          }
          function Bl(t2, e2, r2, n2 = true) {
            const i2 = Ho([], t2._camera.position, t2.worldSize), s2 = [e2, r2, 1, 1];
            ul(s2, s2, t2.pixelMatrixInverse), ol(s2, s2, 1 / s2[3]);
            const a2 = Jo([], il([], s2, i2)), o2 = t2.globeMatrix, l2 = [o2[12], o2[13], o2[14]], u2 = il([], l2, i2), c2 = qo(u2), h2 = Jo([], u2), p2 = t2.worldSize / (2 * Math.PI), f2 = Qo(h2, a2), d2 = Math.asin(p2 / c2);
            if (d2 < Math.acos(f2)) {
              if (!n2)
                return null;
              const t3 = [], e3 = [];
              Ho(t3, a2, c2 / f2), Jo(e3, il(e3, t3, u2)), Jo(a2, Go(a2, u2, Ho(a2, e3, Math.tan(d2) * c2)));
            }
            const y2 = [];
            new vl(i2, a2).closestPointOnSphere(l2, p2, y2);
            const m2 = Jo([], Y(o2, 0)), g2 = Jo([], Y(o2, 1)), x2 = Jo([], Y(o2, 2)), b2 = Qo(m2, y2), w2 = Qo(g2, y2), _2 = Qo(x2, y2), A2 = v(Math.asin(-w2 / p2));
            let k2 = v(Math.atan2(b2, _2));
            k2 = t2.center.lng + function(t3, e3) {
              const r3 = (e3 - t3 + 180) % 360 - 180;
              return r3 < -180 ? r3 + 360 : r3;
            }(t2.center.lng, k2);
            const I2 = iu(k2), M2 = S(su(A2), 0, 1);
            return new pu(I2, M2);
          }
          class El {
            constructor(t2, e2, r2) {
              this.a = il([], t2, r2), this.b = il([], e2, r2), this.center = r2;
              const n2 = Jo([], this.a), i2 = Jo([], this.b);
              this.angle = Math.acos(Qo(n2, i2));
            }
          }
          function Cl(t2, e2) {
            if (0 === t2.angle)
              return null;
            let r2;
            return r2 = 0 === t2.a[e2] ? 1 / t2.angle * 0.5 * Math.PI : 1 / t2.angle * Math.atan(t2.b[e2] / t2.a[e2] / Math.sin(t2.angle) - 1 / Math.tan(t2.angle)), r2 < 0 || r2 > 1 ? null : function(t3, e3, r3, n2) {
              const i2 = Math.sin(r3);
              return t3 * (Math.sin((1 - n2) * r3) / i2) + e3 * (Math.sin(n2 * r3) / i2);
            }(t2.a[e2], t2.b[e2], t2.angle, S(r2, 0, 1)) + t2.center[e2];
          }
          function Pl(t2) {
            if (t2.z <= 1)
              return Tl[t2.z + 2 * t2.y + t2.x];
            const e2 = jl(Rl(t2));
            return _l.fromPoints(e2);
          }
          function Dl(t2, e2, r2) {
            return Ho(t2, t2, 1 - r2), Wo(t2, t2, e2, r2);
          }
          function Vl(t2, e2) {
            const r2 = Kl(e2.zoom);
            if (0 === r2)
              return Pl(t2);
            const n2 = Rl(t2), i2 = jl(n2), s2 = iu(n2.getWest()) * e2.worldSize, a2 = iu(n2.getEast()) * e2.worldSize, o2 = su(n2.getNorth()) * e2.worldSize, l2 = su(n2.getSouth()) * e2.worldSize, u2 = [s2, o2, 0], c2 = [a2, o2, 0], h2 = [s2, l2, 0], p2 = [a2, l2, 0], f2 = Co([], e2.globeMatrix);
            return el(u2, u2, f2), el(c2, c2, f2), el(h2, h2, f2), el(p2, p2, f2), i2[0] = Dl(i2[0], h2, r2), i2[1] = Dl(i2[1], p2, r2), i2[2] = Dl(i2[2], c2, r2), i2[3] = Dl(i2[3], u2, r2), _l.fromPoints(i2);
          }
          function Ll(t2, e2, r2) {
            for (const n2 of t2)
              el(n2, n2, e2), Ho(n2, n2, r2);
          }
          function Fl(t2, e2, r2) {
            const n2 = e2 / t2.worldSize, i2 = t2.globeMatrix;
            if (r2.z <= 1) {
              const t3 = Pl(r2).getCorners();
              return Ll(t3, i2, n2), _l.fromPoints(t3);
            }
            const s2 = Rl(r2), a2 = jl(s2);
            Ll(a2, i2, n2);
            const o2 = Number.MAX_VALUE, l2 = [-o2, -o2, -o2], u2 = [o2, o2, o2];
            if (s2.contains(t2.center)) {
              for (const t3 of a2)
                Ko(u2, u2, t3), Yo(l2, l2, t3);
              l2[2] = 0;
              const e3 = t2.point, r3 = [e3.x * n2, e3.y * n2, 0];
              return Ko(u2, u2, r3), Yo(l2, l2, r3), new _l(u2, l2);
            }
            const c2 = [i2[12] * n2, i2[13] * n2, i2[14] * n2], h2 = s2.getCenter(), p2 = S(t2.center.lat, -cu, cu), f2 = S(h2.lat, -cu, cu), d2 = iu(t2.center.lng), y2 = su(p2);
            let m2 = d2 - iu(h2.lng);
            const g2 = y2 - su(f2);
            m2 > 0.5 ? m2 -= 1 : m2 < -0.5 && (m2 += 1);
            let v2 = 0;
            Math.abs(m2) > Math.abs(g2) ? v2 = m2 >= 0 ? 1 : 3 : (v2 = g2 >= 0 ? 0 : 2, Wo(c2, c2, [i2[4] * n2, i2[5] * n2, i2[6] * n2], -Math.sin(x(g2 >= 0 ? s2.getSouth() : s2.getNorth())) * Al));
            const b2 = a2[v2], w2 = a2[(v2 + 1) % 4], _2 = new El(b2, w2, c2), A2 = [Cl(_2, 0) || b2[0], Cl(_2, 1) || b2[1], Cl(_2, 2) || b2[2]], k2 = Kl(t2.zoom);
            if (k2 > 0) {
              const n3 = function({ x: t3, y: e3, z: r3 }, n4, i4, s3, a3) {
                const o3 = 1 / (1 << r3);
                let l3 = t3 * o3, u3 = l3 + o3, c3 = e3 * o3, h3 = c3 + o3, p3 = 0;
                const f3 = (l3 + u3) / 2 - s3;
                return f3 > 0.5 ? p3 = -1 : f3 < -0.5 && (p3 = 1), l3 = ((l3 + p3) * n4 - (s3 *= n4)) * i4 + s3, u3 = ((u3 + p3) * n4 - s3) * i4 + s3, c3 = (c3 * n4 - (a3 *= n4)) * i4 + a3, h3 = (h3 * n4 - a3) * i4 + a3, [[l3, h3, 0], [u3, h3, 0], [u3, c3, 0], [l3, c3, 0]];
              }(r2, e2, t2._pixelsPerMercatorPixel, d2, y2);
              for (let t3 = 0; t3 < a2.length; t3++)
                Dl(a2[t3], n3[t3], k2);
              const i3 = Go([], n3[v2], n3[(v2 + 1) % 4]);
              Ho(i3, i3, 0.5), Dl(A2, i3, k2);
            }
            for (const t3 of a2)
              Ko(u2, u2, t3), Yo(l2, l2, t3);
            return u2[2] = Math.min(b2[2], w2[2]), Ko(u2, u2, A2), Yo(l2, l2, A2), new _l(u2, l2);
          }
          function Rl({ x: t2, y: e2, z: r2 }) {
            const n2 = 1 / (1 << r2), i2 = new ru(ou(t2 * n2), lu((e2 + 1) * n2)), s2 = new ru(ou((t2 + 1) * n2), lu(e2 * n2));
            return new Io(i2, s2);
          }
          function jl(t2) {
            const e2 = x(t2.getNorth()), r2 = x(t2.getSouth()), n2 = Math.cos(e2), i2 = Math.cos(r2), s2 = Math.sin(e2), a2 = Math.sin(r2), o2 = t2.getWest(), l2 = t2.getEast();
            return [$l(i2, a2, o2), $l(i2, a2, l2), $l(n2, s2, l2), $l(n2, s2, o2)];
          }
          function $l(t2, e2, r2, n2 = Al) {
            return r2 = x(r2), [t2 * Math.sin(r2) * n2, -e2 * n2, t2 * Math.cos(r2) * n2];
          }
          function Ul(t2, e2, r2) {
            return $l(Math.cos(x(t2)), Math.sin(x(t2)), e2, r2);
          }
          function Ol(t2, e2, r2, n2) {
            const i2 = 1 << r2.z, s2 = (t2 / ko + r2.x) / i2;
            return Ul(lu((e2 / ko + r2.y) / i2), ou(s2), n2);
          }
          function ql({ min: t2, max: e2 }) {
            return 16383 / Math.max(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
          }
          const Nl = new Float64Array(16);
          function Gl(t2) {
            const e2 = ql(t2), r2 = Ro(Nl, [e2, e2, e2]);
            return Do(r2, r2, ((n2 = [])[0] = -(i2 = t2.min)[0], n2[1] = -i2[1], n2[2] = -i2[2], n2));
            var n2, i2;
          }
          function Zl(t2) {
            const e2 = (n2 = t2.min, (r2 = Nl)[0] = 1, r2[1] = 0, r2[2] = 0, r2[3] = 0, r2[4] = 0, r2[5] = 1, r2[6] = 0, r2[7] = 0, r2[8] = 0, r2[9] = 0, r2[10] = 1, r2[11] = 0, r2[12] = n2[0], r2[13] = n2[1], r2[14] = n2[2], r2[15] = 1, r2);
            var r2, n2;
            const i2 = 1 / ql(t2);
            return Vo(e2, e2, [i2, i2, i2]);
          }
          function Xl(t2, e2, r2, n2, i2) {
            const s2 = function(t3) {
              const e3 = ko / (2 * Math.PI);
              return t3 / (2 * Math.PI) / e3;
            }(r2), a2 = [t2, e2, -r2 / (2 * Math.PI)], o2 = Eo(new Float64Array(16));
            return Do(o2, o2, a2), Vo(o2, o2, [s2, s2, s2]), Lo(o2, o2, x(-i2)), Fo(o2, o2, x(-n2)), o2;
          }
          function Kl(t2) {
            return k(5, 6, t2);
          }
          function Yl(t2, e2) {
            const r2 = Ul(e2.lat, e2.lng), n2 = function(t3) {
              const e3 = Ul(t3._center.lat, t3._center.lng);
              let r3 = tl([], No(0, 1, 0), e3);
              const n3 = jo([], -t3.angle, e3);
              r3 = el(r3, r3, n3), jo(n3, -t3._pitch, r3);
              const i3 = Jo([], e3);
              return Ho(i3, i3, zl(t3.cameraToCenterDistance / t3.pixelsPerMeter)), el(i3, i3, n3), Go([], e3, i3);
            }(t2);
            return a2 = (i2 = Zo([], n2, r2))[0], o2 = i2[1], l2 = i2[2], u2 = (s2 = r2)[0], c2 = s2[1], h2 = s2[2], f2 = (p2 = Math.sqrt(a2 * a2 + o2 * o2 + l2 * l2) * Math.sqrt(u2 * u2 + c2 * c2 + h2 * h2)) && Qo(i2, s2) / p2, Math.acos(Math.min(Math.max(f2, -1), 1));
            var i2, s2, a2, o2, l2, u2, c2, h2, p2, f2;
          }
          function Hl(t2, e2) {
            return Yl(t2, e2) > Math.PI / 2 * 1.01;
          }
          const Wl = x(85), Jl = Math.cos(Wl), Ql = Math.sin(Wl), tu = 63710088e-1, eu = 2 * Math.PI * tu;
          class ru {
            constructor(t2, e2) {
              if (isNaN(t2) || isNaN(e2))
                throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
              if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
                throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
              return new ru(I(this.lng, -180, 180), this.lat);
            }
            toArray() {
              return [this.lng, this.lat];
            }
            toString() {
              return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t2) {
              const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
              return tu * Math.acos(Math.min(i2, 1));
            }
            toBounds(t2 = 0) {
              const e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
              return new Io(new ru(this.lng - r2, this.lat - e2), new ru(this.lng + r2, this.lat + e2));
            }
            toEcef(t2) {
              const e2 = zl(t2);
              return Ul(this.lat, this.lng, Al + e2);
            }
            static convert(t2) {
              if (t2 instanceof ru)
                return t2;
              if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
                return new ru(Number(t2[0]), Number(t2[1]));
              if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
                return new ru(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
              throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
          }
          function nu(t2) {
            return eu * Math.cos(t2 * Math.PI / 180);
          }
          function iu(t2) {
            return (180 + t2) / 360;
          }
          function su(t2) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
          }
          function au(t2, e2) {
            return t2 / nu(e2);
          }
          function ou(t2) {
            return 360 * t2 - 180;
          }
          function lu(t2) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
          }
          function uu(t2, e2) {
            return t2 * nu(lu(e2));
          }
          const cu = 85.051129;
          function hu(t2) {
            return 1 / Math.cos(t2 * Math.PI / 180);
          }
          class pu {
            constructor(t2, e2, r2 = 0) {
              this.x = +t2, this.y = +e2, this.z = +r2;
            }
            static fromLngLat(t2, e2 = 0) {
              const r2 = ru.convert(t2);
              return new pu(iu(r2.lng), su(r2.lat), au(e2, r2.lat));
            }
            toLngLat() {
              return new ru(ou(this.x), lu(this.y));
            }
            toAltitude() {
              return uu(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
              return 1 / eu * hu(lu(this.y));
            }
          }
          function fu(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = (e2 + n2) / 2, c2 = (r2 + i2) / 2, h2 = new d(u2, c2);
            o2(h2), function(t3, e3, r3, n3, i3, s3) {
              const a3 = r3 - i3, o3 = n3 - s3;
              return Math.abs((n3 - e3) * a3 - (r3 - t3) * o3) / Math.hypot(a3, o3);
            }(h2.x, h2.y, s2.x, s2.y, a2.x, a2.y) >= l2 ? (fu(t2, e2, r2, u2, c2, s2, h2, o2, l2), fu(t2, u2, c2, n2, i2, h2, a2, o2, l2)) : t2.push(a2);
          }
          function du(t2, e2, r2) {
            let n2 = t2[0], i2 = n2.x, s2 = n2.y;
            e2(n2);
            const a2 = [n2];
            for (let o2 = 1; o2 < t2.length; o2++) {
              const l2 = t2[o2], { x: u2, y: c2 } = l2;
              e2(l2), fu(a2, i2, s2, u2, c2, n2, l2, e2, r2), i2 = u2, s2 = c2, n2 = l2;
            }
            return a2;
          }
          function yu(t2, e2, r2, n2) {
            if (n2(e2, r2)) {
              const i2 = e2.add(r2)._mult(0.5);
              yu(t2, e2, i2, n2), yu(t2, i2, r2, n2);
            } else
              t2.push(r2);
          }
          function mu(t2, e2) {
            let r2 = t2[0];
            const n2 = [r2];
            for (let i2 = 1; i2 < t2.length; i2++) {
              const s2 = t2[i2];
              yu(n2, r2, s2, e2), r2 = s2;
            }
            return n2;
          }
          const gu = Math.pow(2, 14) - 1, xu = -gu - 1;
          function vu(t2, e2) {
            const r2 = Math.round(t2.x * e2), n2 = Math.round(t2.y * e2);
            return t2.x = S(r2, xu, gu), t2.y = S(n2, xu, gu), (r2 < t2.x || r2 > t2.x + 1 || n2 < t2.y || n2 > t2.y + 1) && U("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t2;
          }
          function bu(t2, e2, r2) {
            const n2 = t2.loadGeometry(), i2 = t2.extent, s2 = ko / i2;
            if (e2 && r2 && r2.projection.isReprojectedInTileSpace) {
              const s3 = 1 << e2.z, { scale: a2, x: o2, y: l2, projection: u2 } = r2, c2 = (t3) => {
                const r3 = ou((e2.x + t3.x / i2) / s3), n3 = lu((e2.y + t3.y / i2) / s3), c3 = u2.project(r3, n3);
                t3.x = (c3.x * a2 - o2) * i2, t3.y = (c3.y * a2 - l2) * i2;
              };
              for (let e3 = 0; e3 < n2.length; e3++)
                if (1 !== t2.type)
                  n2[e3] = du(n2[e3], c2, 1);
                else {
                  const t3 = [];
                  for (const r3 of n2[e3])
                    r3.x < 0 || r3.x >= i2 || r3.y < 0 || r3.y >= i2 || (c2(r3), t3.push(r3));
                  n2[e3] = t3;
                }
            }
            for (const t3 of n2)
              for (const e3 of t3)
                vu(e3, s2);
            return n2;
          }
          function wu(t2, e2) {
            return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? bu(t2) : [] };
          }
          function _u(t2, e2, r2, n2, i2) {
            t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
          }
          function Au(t2, e2, r2) {
            const n2 = 16384;
            t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
          }
          class Su {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.projection = t2.projection, this.layoutVertexArray = new sa(), this.indexArray = new wa(), this.segments = new So(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r2, n2) {
              const i2 = this.layers[0], s2 = [];
              let a2 = null;
              "circle" === i2.type && (a2 = i2.layout.get("circle-sort-key"));
              for (const { feature: e3, id: i3, index: o3, sourceLayerIndex: l2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u2 = wu(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new $s(this.zoom), u2, r2))
                  continue;
                const c2 = a2 ? a2.evaluate(u2, {}, r2) : void 0, h2 = { id: i3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o3, geometry: t3 ? u2.geometry : bu(e3, r2, n2), patterns: {}, sortKey: c2 };
                s2.push(h2);
              }
              a2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              let o2 = null;
              "globe" === n2.projection.name && (this.globeExtVertexArray = new pa(), o2 = n2.projection);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, l2 = t2[s3].feature;
                this.addFeature(n3, i3, s3, e2.availableImages, r2, o2), e2.featureIndex.insert(l2, i3, s3, a3, this.index);
              }
            }
            update(t2, e2, r2, n2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, _o.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Ao.members))), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
            addFeature(t2, e2, r2, n2, i2, s2) {
              for (const r3 of e2)
                for (const e3 of r3) {
                  const r4 = e3.x, n3 = e3.y;
                  if (r4 < 0 || r4 >= ko || n3 < 0 || n3 >= ko)
                    continue;
                  if (s2) {
                    const t3 = s2.projectTilePoint(r4, n3, i2), e4 = s2.upVector(i2, r4, n3), a3 = this.globeExtVertexArray;
                    Au(a3, t3, e4), Au(a3, t3, e4), Au(a3, t3, e4), Au(a3, t3, e4);
                  }
                  const a2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), o2 = a2.vertexLength;
                  _u(this.layoutVertexArray, r4, n3, -1, -1), _u(this.layoutVertexArray, r4, n3, 1, -1), _u(this.layoutVertexArray, r4, n3, 1, 1), _u(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(o2, o2 + 1, o2 + 2), this.indexArray.emplaceBack(o2, o2 + 2, o2 + 3), a2.vertexLength += 4, a2.primitiveLength += 2;
                }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2, i2);
            }
          }
          function ku(t2, e2) {
            for (let r2 = 0; r2 < t2.length; r2++)
              if (Du(e2, t2[r2]))
                return true;
            for (let r2 = 0; r2 < e2.length; r2++)
              if (Du(t2, e2[r2]))
                return true;
            return !!zu(t2, e2);
          }
          function Iu(t2, e2, r2) {
            return !!Du(t2, e2) || !!Eu(e2, t2, r2);
          }
          function Mu(t2, e2) {
            if (1 === t2.length)
              return Pu(e2, t2[0]);
            for (let r2 = 0; r2 < e2.length; r2++) {
              const n2 = e2[r2];
              for (let e3 = 0; e3 < n2.length; e3++)
                if (Du(t2, n2[e3]))
                  return true;
            }
            for (let r2 = 0; r2 < t2.length; r2++)
              if (Pu(e2, t2[r2]))
                return true;
            for (let r2 = 0; r2 < e2.length; r2++)
              if (zu(t2, e2[r2]))
                return true;
            return false;
          }
          function Tu(t2, e2, r2) {
            if (t2.length > 1) {
              if (zu(t2, e2))
                return true;
              for (let n2 = 0; n2 < e2.length; n2++)
                if (Eu(e2[n2], t2, r2))
                  return true;
            }
            for (let n2 = 0; n2 < t2.length; n2++)
              if (Eu(t2[n2], e2, r2))
                return true;
            return false;
          }
          function zu(t2, e2) {
            if (0 === t2.length || 0 === e2.length)
              return false;
            for (let r2 = 0; r2 < t2.length - 1; r2++) {
              const n2 = t2[r2], i2 = t2[r2 + 1];
              for (let t3 = 0; t3 < e2.length - 1; t3++)
                if (Bu(n2, i2, e2[t3], e2[t3 + 1]))
                  return true;
            }
            return false;
          }
          function Bu(t2, e2, r2, n2) {
            return O(t2, r2, n2) !== O(e2, r2, n2) && O(t2, e2, r2) !== O(t2, e2, n2);
          }
          function Eu(t2, e2, r2) {
            const n2 = r2 * r2;
            if (1 === e2.length)
              return t2.distSqr(e2[0]) < n2;
            for (let r3 = 1; r3 < e2.length; r3++)
              if (Cu(t2, e2[r3 - 1], e2[r3]) < n2)
                return true;
            return false;
          }
          function Cu(t2, e2, r2) {
            const n2 = e2.distSqr(r2);
            if (0 === n2)
              return t2.distSqr(e2);
            const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
            return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
          }
          function Pu(t2, e2) {
            let r2, n2, i2, s2 = false;
            for (let a2 = 0; a2 < t2.length; a2++) {
              r2 = t2[a2];
              for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++)
                n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
            }
            return s2;
          }
          function Du(t2, e2) {
            let r2 = false;
            for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
              const s2 = t2[n2], a2 = t2[i2];
              s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
            }
            return r2;
          }
          function Vu(t2, e2, r2, n2, i2) {
            for (const s3 of t2)
              if (e2 <= s3.x && r2 <= s3.y && n2 >= s3.x && i2 >= s3.y)
                return true;
            const s2 = [new d(e2, r2), new d(e2, i2), new d(n2, i2), new d(n2, r2)];
            if (t2.length > 2) {
              for (const e3 of s2)
                if (Du(t2, e3))
                  return true;
            }
            for (let e3 = 0; e3 < t2.length - 1; e3++)
              if (Lu(t2[e3], t2[e3 + 1], s2))
                return true;
            return false;
          }
          function Lu(t2, e2, r2) {
            const n2 = r2[0], i2 = r2[2];
            if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
              return false;
            const s2 = O(t2, e2, r2[0]);
            return s2 !== O(t2, e2, r2[1]) || s2 !== O(t2, e2, r2[2]) || s2 !== O(t2, e2, r2[3]);
          }
          function Fu(t2, e2, r2) {
            const n2 = e2.paint.get(t2).value;
            return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
          }
          function Ru(t2) {
            return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
          }
          function ju(t2, e2, r2, n2, i2) {
            if (!e2[0] && !e2[1])
              return t2;
            const s2 = d.convert(e2)._mult(i2);
            "viewport" === r2 && s2._rotate(-n2);
            const a2 = [];
            for (let e3 = 0; e3 < t2.length; e3++)
              a2.push(t2[e3].sub(s2));
            return a2;
          }
          function $u(t2, e2, r2, n2) {
            const i2 = d.convert(t2)._mult(n2);
            return "viewport" === e2 && i2._rotate(-r2), i2;
          }
          Oi(Su, "CircleBucket", { omit: ["layers"] });
          const Uu = new Js({ "circle-sort-key": new Hs(Ht.layout_circle["circle-sort-key"]) });
          var Ou = { paint: new Js({ "circle-radius": new Hs(Ht.paint_circle["circle-radius"]), "circle-color": new Hs(Ht.paint_circle["circle-color"]), "circle-blur": new Hs(Ht.paint_circle["circle-blur"]), "circle-opacity": new Hs(Ht.paint_circle["circle-opacity"]), "circle-translate": new Ys(Ht.paint_circle["circle-translate"]), "circle-translate-anchor": new Ys(Ht.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ys(Ht.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ys(Ht.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Hs(Ht.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Hs(Ht.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Hs(Ht.paint_circle["circle-stroke-opacity"]) }), layout: Uu };
          function qu(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            if (s2 && t2.queryGeometry.isAboveHorizon)
              return false;
            s2 && (l2 *= t2.pixelToTileUnitsFactor);
            const u2 = t2.tileID.canonical, c2 = r2.projection.upVectorScale(u2, r2.center.lat, r2.worldSize).metersToTile;
            for (const h2 of e2)
              for (const e3 of h2) {
                const h3 = e3.add(o2), p2 = i2 && r2.elevation ? r2.elevation.exaggeration() * i2.getElevationAt(h3.x, h3.y, true) : 0, f2 = r2.projection.projectTilePoint(h3.x, h3.y, u2);
                if (p2 > 0) {
                  const t3 = r2.projection.upVector(u2, h3.x, h3.y);
                  f2.x += t3[0] * c2 * p2, f2.y += t3[1] * c2 * p2, f2.z += t3[2] * c2 * p2;
                }
                const d2 = s2 ? h3 : Nu(f2.x, f2.y, f2.z, n2), y2 = s2 ? t2.tilespaceRays.map((t3) => Xu(t3, p2)) : t2.queryGeometry.screenGeometry, m2 = ul([], [f2.x, f2.y, f2.z, 1], n2);
                if (!a2 && s2 ? l2 *= m2[3] / r2.cameraToCenterDistance : a2 && !s2 && (l2 *= r2.cameraToCenterDistance / m2[3]), s2) {
                  const t3 = lu((e3.y / ko + u2.y) / (1 << u2.z));
                  l2 /= r2.projection.pixelsPerMeter(t3, 1) / au(1, t3);
                }
                if (Iu(y2, d2, l2))
                  return true;
              }
            return false;
          }
          function Nu(t2, e2, r2, n2) {
            const i2 = ul([], [t2, e2, r2, 1], n2);
            return new d(i2[0] / i2[3], i2[1] / i2[3]);
          }
          const Gu = No(0, 0, 0), Zu = No(0, 0, 1);
          function Xu(t2, e2) {
            const r2 = Uo();
            return Gu[2] = e2, t2.intersectsPlane(Gu, Zu, r2), new d(r2[0], r2[1]);
          }
          class Ku extends Su {
          }
          function Yu(t2, { width: e2, height: r2 }, n2, i2) {
            if (i2) {
              if (i2 instanceof Uint8ClampedArray)
                i2 = new Uint8Array(i2.buffer);
              else if (i2.length !== e2 * r2 * n2)
                throw new RangeError("mismatched image size");
            } else
              i2 = new Uint8Array(e2 * r2 * n2);
            return t2.width = e2, t2.height = r2, t2.data = i2, t2;
          }
          function Hu(t2, e2, r2) {
            const { width: n2, height: i2 } = e2;
            n2 === t2.width && i2 === t2.height || (Wu(t2, e2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n2), height: Math.min(t2.height, i2) }, r2), t2.width = n2, t2.height = i2, t2.data = e2.data);
          }
          function Wu(t2, e2, r2, n2, i2, s2) {
            if (0 === i2.width || 0 === i2.height)
              return e2;
            if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
              throw new RangeError("out of range source coordinates for image copy");
            if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
              throw new RangeError("out of range destination coordinates for image copy");
            const a2 = t2.data, o2 = e2.data;
            for (let l2 = 0; l2 < i2.height; l2++) {
              const u2 = ((r2.y + l2) * t2.width + r2.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
              for (let t3 = 0; t3 < i2.width * s2; t3++)
                o2[c2 + t3] = a2[u2 + t3];
            }
            return e2;
          }
          Oi(Ku, "HeatmapBucket", { omit: ["layers"] });
          class Ju {
            constructor(t2, e2) {
              Yu(this, t2, 1, e2);
            }
            resize(t2) {
              Hu(this, new Ju(t2), 1);
            }
            clone() {
              return new Ju({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r2, n2, i2) {
              Wu(t2, e2, r2, n2, i2, 1);
            }
          }
          class Qu {
            constructor(t2, e2) {
              Yu(this, t2, 4, e2);
            }
            resize(t2) {
              Hu(this, new Qu(t2), 4);
            }
            replace(t2, e2) {
              e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
            }
            clone() {
              return new Qu({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r2, n2, i2) {
              Wu(t2, e2, r2, n2, i2, 4);
            }
          }
          Oi(Ju, "AlphaImage"), Oi(Qu, "RGBAImage");
          var tc = { paint: new Js({ "heatmap-radius": new Hs(Ht.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Hs(Ht.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ys(Ht.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ws(Ht.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ys(Ht.paint_heatmap["heatmap-opacity"]) }) };
          function ec(t2) {
            const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Qu({ width: r2, height: n2 }), s2 = (r3, n3, s3) => {
              e2[t2.evaluationKey] = s3;
              const a2 = t2.expression.evaluate(e2);
              i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
            };
            if (t2.clips)
              for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2)
                for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
                  const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
                  s2(i3, a2, l2 * (1 - o2) + u2 * o2);
                }
            else
              for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4)
                s2(0, e3, t3 / (r2 - 1));
            return i2;
          }
          var rc = { paint: new Js({ "hillshade-illumination-direction": new Ys(Ht.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Ys(Ht.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ys(Ht.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ys(Ht.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ys(Ht.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ys(Ht.paint_hillshade["hillshade-accent-color"]) }) };
          const nc = na([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ic } = nc;
          var sc = {};
          function ac(t2, e2, r2) {
            r2 = r2 || 2;
            var n2, i2, s2, a2, o2, l2, u2, c2 = e2 && e2.length, h2 = c2 ? e2[0] * r2 : t2.length, p2 = oc(t2, 0, h2, r2, true), f2 = [];
            if (!p2 || p2.next === p2.prev)
              return f2;
            if (c2 && (p2 = function(t3, e3, r3, n3) {
              var i3, s3, a3, o3 = [];
              for (i3 = 0, s3 = e3.length; i3 < s3; i3++)
                (a3 = oc(t3, e3[i3] * n3, i3 < s3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(xc(a3));
              for (o3.sort(dc), i3 = 0; i3 < o3.length; i3++)
                r3 = yc(o3[i3], r3);
              return r3;
            }(t2, e2, p2, r2)), t2.length > 80 * r2) {
              n2 = s2 = t2[0], i2 = a2 = t2[1];
              for (var d2 = r2; d2 < h2; d2 += r2)
                (o2 = t2[d2]) < n2 && (n2 = o2), (l2 = t2[d2 + 1]) < i2 && (i2 = l2), o2 > s2 && (s2 = o2), l2 > a2 && (a2 = l2);
              u2 = 0 !== (u2 = Math.max(s2 - n2, a2 - i2)) ? 32767 / u2 : 0;
            }
            return uc(p2, f2, r2, n2, i2, u2, 0), f2;
          }
          function oc(t2, e2, r2, n2, i2) {
            var s2, a2;
            if (i2 === Ec(t2, e2, r2, n2) > 0)
              for (s2 = e2; s2 < r2; s2 += n2)
                a2 = Tc(s2, t2[s2], t2[s2 + 1], a2);
            else
              for (s2 = r2 - n2; s2 >= e2; s2 -= n2)
                a2 = Tc(s2, t2[s2], t2[s2 + 1], a2);
            return a2 && _c(a2, a2.next) && (zc(a2), a2 = a2.next), a2;
          }
          function lc(t2, e2) {
            if (!t2)
              return t2;
            e2 || (e2 = t2);
            var r2, n2 = t2;
            do {
              if (r2 = false, n2.steiner || !_c(n2, n2.next) && 0 !== wc(n2.prev, n2, n2.next))
                n2 = n2.next;
              else {
                if (zc(n2), (n2 = e2 = n2.prev) === n2.next)
                  break;
                r2 = true;
              }
            } while (r2 || n2 !== e2);
            return e2;
          }
          function uc(t2, e2, r2, n2, i2, s2, a2) {
            if (t2) {
              !a2 && s2 && function(t3, e3, r3, n3) {
                var i3 = t3;
                do {
                  0 === i3.z && (i3.z = gc(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
                } while (i3 !== t3);
                i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                  var e4, r4, n4, i4, s3, a3, o3, l3, u3 = 1;
                  do {
                    for (r4 = t4, t4 = null, s3 = null, a3 = 0; r4; ) {
                      for (a3++, n4 = r4, o3 = 0, e4 = 0; e4 < u3 && (o3++, n4 = n4.nextZ); e4++)
                        ;
                      for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                        0 !== o3 && (0 === l3 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = i4 : t4 = i4, i4.prevZ = s3, s3 = i4;
                      r4 = n4;
                    }
                    s3.nextZ = null, u3 *= 2;
                  } while (a3 > 1);
                }(i3);
              }(t2, n2, i2, s2);
              for (var o2, l2, u2 = t2; t2.prev !== t2.next; )
                if (o2 = t2.prev, l2 = t2.next, s2 ? hc(t2, n2, i2, s2) : cc(t2))
                  e2.push(o2.i / r2 | 0), e2.push(t2.i / r2 | 0), e2.push(l2.i / r2 | 0), zc(t2), t2 = l2.next, u2 = l2.next;
                else if ((t2 = l2) === u2) {
                  a2 ? 1 === a2 ? uc(t2 = pc(lc(t2), e2, r2), e2, r2, n2, i2, s2, 2) : 2 === a2 && fc(t2, e2, r2, n2, i2, s2) : uc(lc(t2), e2, r2, n2, i2, s2, 1);
                  break;
                }
            }
          }
          function cc(t2) {
            var e2 = t2.prev, r2 = t2, n2 = t2.next;
            if (wc(e2, r2, n2) >= 0)
              return false;
            for (var i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l2 = r2.y, u2 = n2.y, c2 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p2 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, d2 = n2.next; d2 !== e2; ) {
              if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && vc(i2, o2, s2, l2, a2, u2, d2.x, d2.y) && wc(d2.prev, d2, d2.next) >= 0)
                return false;
              d2 = d2.next;
            }
            return true;
          }
          function hc(t2, e2, r2, n2) {
            var i2 = t2.prev, s2 = t2, a2 = t2.next;
            if (wc(i2, s2, a2) >= 0)
              return false;
            for (var o2 = i2.x, l2 = s2.x, u2 = a2.x, c2 = i2.y, h2 = s2.y, p2 = a2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d2 = c2 < h2 ? c2 < p2 ? c2 : p2 : h2 < p2 ? h2 : p2, y2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, m2 = c2 > h2 ? c2 > p2 ? c2 : p2 : h2 > p2 ? h2 : p2, g2 = gc(f2, d2, e2, r2, n2), x2 = gc(y2, m2, e2, r2, n2), v2 = t2.prevZ, b2 = t2.nextZ; v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
              if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && vc(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && wc(v2.prev, v2, v2.next) >= 0)
                return false;
              if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && vc(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && wc(b2.prev, b2, b2.next) >= 0)
                return false;
              b2 = b2.nextZ;
            }
            for (; v2 && v2.z >= g2; ) {
              if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && vc(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && wc(v2.prev, v2, v2.next) >= 0)
                return false;
              v2 = v2.prevZ;
            }
            for (; b2 && b2.z <= x2; ) {
              if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && vc(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && wc(b2.prev, b2, b2.next) >= 0)
                return false;
              b2 = b2.nextZ;
            }
            return true;
          }
          function pc(t2, e2, r2) {
            var n2 = t2;
            do {
              var i2 = n2.prev, s2 = n2.next.next;
              !_c(i2, s2) && Ac(i2, n2, n2.next, s2) && Ic(i2, s2) && Ic(s2, i2) && (e2.push(i2.i / r2 | 0), e2.push(n2.i / r2 | 0), e2.push(s2.i / r2 | 0), zc(n2), zc(n2.next), n2 = t2 = s2), n2 = n2.next;
            } while (n2 !== t2);
            return lc(n2);
          }
          function fc(t2, e2, r2, n2, i2, s2) {
            var a2 = t2;
            do {
              for (var o2 = a2.next.next; o2 !== a2.prev; ) {
                if (a2.i !== o2.i && bc(a2, o2)) {
                  var l2 = Mc(a2, o2);
                  return a2 = lc(a2, a2.next), l2 = lc(l2, l2.next), uc(a2, e2, r2, n2, i2, s2, 0), void uc(l2, e2, r2, n2, i2, s2, 0);
                }
                o2 = o2.next;
              }
              a2 = a2.next;
            } while (a2 !== t2);
          }
          function dc(t2, e2) {
            return t2.x - e2.x;
          }
          function yc(t2, e2) {
            var r2 = function(t3, e3) {
              var r3, n3 = e3, i2 = t3.x, s2 = t3.y, a2 = -1 / 0;
              do {
                if (s2 <= n3.y && s2 >= n3.next.y && n3.next.y !== n3.y) {
                  var o2 = n3.x + (s2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
                  if (o2 <= i2 && o2 > a2 && (a2 = o2, r3 = n3.x < n3.next.x ? n3 : n3.next, o2 === i2))
                    return r3;
                }
                n3 = n3.next;
              } while (n3 !== e3);
              if (!r3)
                return null;
              var l2, u2 = r3, c2 = r3.x, h2 = r3.y, p2 = 1 / 0;
              n3 = r3;
              do {
                i2 >= n3.x && n3.x >= c2 && i2 !== n3.x && vc(s2 < h2 ? i2 : a2, s2, c2, h2, s2 < h2 ? a2 : i2, s2, n3.x, n3.y) && (l2 = Math.abs(s2 - n3.y) / (i2 - n3.x), Ic(n3, t3) && (l2 < p2 || l2 === p2 && (n3.x > r3.x || n3.x === r3.x && mc(r3, n3))) && (r3 = n3, p2 = l2)), n3 = n3.next;
              } while (n3 !== u2);
              return r3;
            }(t2, e2);
            if (!r2)
              return e2;
            var n2 = Mc(r2, t2);
            return lc(n2, n2.next), lc(r2, r2.next);
          }
          function mc(t2, e2) {
            return wc(t2.prev, t2, e2.prev) < 0 && wc(e2.next, t2, t2.next) < 0;
          }
          function gc(t2, e2, r2, n2, i2) {
            return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
          }
          function xc(t2) {
            var e2 = t2, r2 = t2;
            do {
              (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
            } while (e2 !== t2);
            return r2;
          }
          function vc(t2, e2, r2, n2, i2, s2, a2, o2) {
            return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
          }
          function bc(t2, e2) {
            return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
              var r2 = t3;
              do {
                if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Ac(r2, r2.next, t3, e3))
                  return true;
                r2 = r2.next;
              } while (r2 !== t3);
              return false;
            }(t2, e2) && (Ic(t2, e2) && Ic(e2, t2) && function(t3, e3) {
              var r2 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
              do {
                r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
              } while (r2 !== t3);
              return n2;
            }(t2, e2) && (wc(t2.prev, t2, e2.prev) || wc(t2, e2.prev, e2)) || _c(t2, e2) && wc(t2.prev, t2, t2.next) > 0 && wc(e2.prev, e2, e2.next) > 0);
          }
          function wc(t2, e2, r2) {
            return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
          }
          function _c(t2, e2) {
            return t2.x === e2.x && t2.y === e2.y;
          }
          function Ac(t2, e2, r2, n2) {
            var i2 = kc(wc(t2, e2, r2)), s2 = kc(wc(t2, e2, n2)), a2 = kc(wc(r2, n2, t2)), o2 = kc(wc(r2, n2, e2));
            return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !Sc(t2, r2, e2)) || !(0 !== s2 || !Sc(t2, n2, e2)) || !(0 !== a2 || !Sc(r2, t2, n2)) || !(0 !== o2 || !Sc(r2, e2, n2));
          }
          function Sc(t2, e2, r2) {
            return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
          }
          function kc(t2) {
            return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
          }
          function Ic(t2, e2) {
            return wc(t2.prev, t2, t2.next) < 0 ? wc(t2, e2, t2.next) >= 0 && wc(t2, t2.prev, e2) >= 0 : wc(t2, e2, t2.prev) < 0 || wc(t2, t2.next, e2) < 0;
          }
          function Mc(t2, e2) {
            var r2 = new Bc(t2.i, t2.x, t2.y), n2 = new Bc(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
            return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
          }
          function Tc(t2, e2, r2, n2) {
            var i2 = new Bc(t2, e2, r2);
            return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
          }
          function zc(t2) {
            t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
          }
          function Bc(t2, e2, r2) {
            this.i = t2, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
          }
          function Ec(t2, e2, r2, n2) {
            for (var i2 = 0, s2 = e2, a2 = r2 - n2; s2 < r2; s2 += n2)
              i2 += (t2[a2] - t2[s2]) * (t2[s2 + 1] + t2[a2 + 1]), a2 = s2;
            return i2;
          }
          function Cc(t2, e2, r2, n2, i2) {
            Pc(t2, e2, r2 || 0, n2 || t2.length - 1, i2 || Vc);
          }
          function Pc(t2, e2, r2, n2, i2) {
            for (; n2 > r2; ) {
              if (n2 - r2 > 600) {
                var s2 = n2 - r2 + 1, a2 = e2 - r2 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
                Pc(t2, e2, Math.max(r2, Math.floor(e2 - a2 * l2 / s2 + u2)), Math.min(n2, Math.floor(e2 + (s2 - a2) * l2 / s2 + u2)), i2);
              }
              var c2 = t2[e2], h2 = r2, p2 = n2;
              for (Dc(t2, r2, e2), i2(t2[n2], c2) > 0 && Dc(t2, r2, n2); h2 < p2; ) {
                for (Dc(t2, h2, p2), h2++, p2--; i2(t2[h2], c2) < 0; )
                  h2++;
                for (; i2(t2[p2], c2) > 0; )
                  p2--;
              }
              0 === i2(t2[r2], c2) ? Dc(t2, r2, p2) : Dc(t2, ++p2, n2), p2 <= e2 && (r2 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
            }
          }
          function Dc(t2, e2, r2) {
            var n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          function Vc(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function Lc(t2, e2) {
            const r2 = t2.length;
            if (r2 <= 1)
              return [t2];
            const n2 = [];
            let i2, s2;
            for (let e3 = 0; e3 < r2; e3++) {
              const r3 = q(t2[e3]);
              0 !== r3 && (t2[e3].area = Math.abs(r3), void 0 === s2 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
            }
            if (i2 && n2.push(i2), e2 > 1)
              for (let t3 = 0; t3 < n2.length; t3++)
                n2[t3].length <= e2 || (Cc(n2[t3], e2, 1, n2[t3].length - 1, Fc), n2[t3] = n2[t3].slice(0, e2));
            return n2;
          }
          function Fc(t2, e2) {
            return e2.area - t2.area;
          }
          function Rc(t2, e2, r2) {
            const n2 = r2.patternDependencies;
            let i2 = false;
            for (const r3 of e2) {
              const e3 = r3.paint.get(`${t2}-pattern`);
              e3.isConstant() || (i2 = true);
              const s2 = e3.constantOr(null);
              s2 && (i2 = true, n2[s2] = true);
            }
            return i2;
          }
          function jc(t2, e2, r2, n2, i2) {
            const s2 = i2.patternDependencies;
            for (const a2 of e2) {
              const e3 = a2.paint.get(`${t2}-pattern`).value;
              if ("constant" !== e3.kind) {
                let t3 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages);
                t3 = t3 && t3.name ? t3.name : t3, s2[t3] = true, r2.patterns[a2.id] = t3;
              }
            }
            return r2;
          }
          ({ get exports() {
            return sc;
          }, set exports(t2) {
            sc = t2;
          } }).exports = ac, sc.default = ac, ac.deviation = function(t2, e2, r2, n2) {
            var i2 = e2 && e2.length, s2 = Math.abs(Ec(t2, 0, i2 ? e2[0] * r2 : t2.length, r2));
            if (i2)
              for (var a2 = 0, o2 = e2.length; a2 < o2; a2++)
                s2 -= Math.abs(Ec(t2, e2[a2] * r2, a2 < o2 - 1 ? e2[a2 + 1] * r2 : t2.length, r2));
            var l2 = 0;
            for (a2 = 0; a2 < n2.length; a2 += 3) {
              var u2 = n2[a2] * r2, c2 = n2[a2 + 1] * r2, h2 = n2[a2 + 2] * r2;
              l2 += Math.abs((t2[u2] - t2[h2]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h2 + 1] - t2[u2 + 1]));
            }
            return 0 === s2 && 0 === l2 ? 0 : Math.abs((l2 - s2) / s2);
          }, ac.flatten = function(t2) {
            for (var e2 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
              for (var s2 = 0; s2 < t2[i2].length; s2++)
                for (var a2 = 0; a2 < e2; a2++)
                  r2.vertices.push(t2[i2][s2][a2]);
              i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
            }
            return r2;
          };
          class $c {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new sa(), this.indexArray = new wa(), this.indexArray2 = new Ma(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.segments = new So(), this.segments2 = new So(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t2.projection;
            }
            populate(t2, e2, r2, n2) {
              this.hasPattern = Rc("fill", this.layers, e2);
              const i2 = this.layers[0].layout.get("fill-sort-key"), s2 = [];
              for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, c2 = wu(a2, t3);
                if (!this.layers[0]._featureFilter.filter(new $s(this.zoom), c2, r2))
                  continue;
                const h2 = i2 ? i2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : bu(a2, r2, n2), patterns: {}, sortKey: h2 };
                s2.push(p2);
              }
              i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
                if (this.hasPattern) {
                  const t3 = jc("fill", this.layers, n3, this.zoom, e2);
                  this.patternFeatures.push(t3);
                } else
                  this.addFeature(n3, i3, s3, r2, {}, e2.availableImages);
                e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
              }
            }
            update(t2, e2, r2, n2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n2);
            }
            addFeatures(t2, e2, r2, n2, i2) {
              for (const t3 of this.patternFeatures)
                this.addFeature(t3, t3.geometry, t3.index, e2, r2, n2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ic), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t2, e2, r2, n2, i2, s2 = []) {
              for (const t3 of Lc(e2, 500)) {
                let e3 = 0;
                for (const r4 of t3)
                  e3 += r4.length;
                const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s3 = [];
                for (const e4 of t3) {
                  if (0 === e4.length)
                    continue;
                  e4 !== t3[0] && s3.push(i3.length / 2);
                  const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
                  this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
                  for (let t4 = 1; t4 < e4.length; t4++)
                    this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
                  r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
                }
                const a2 = sc(i3, s3);
                for (let t4 = 0; t4 < a2.length; t4 += 3)
                  this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
                r3.vertexLength += e3, r3.primitiveLength += a2.length / 3;
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2);
            }
          }
          Oi($c, "FillBucket", { omit: ["layers", "patternFeatures"] });
          const Uc = new Js({ "fill-sort-key": new Hs(Ht.layout_fill["fill-sort-key"]) });
          var Oc = { paint: new Js({ "fill-antialias": new Ys(Ht.paint_fill["fill-antialias"]), "fill-opacity": new Hs(Ht.paint_fill["fill-opacity"]), "fill-color": new Hs(Ht.paint_fill["fill-color"]), "fill-outline-color": new Hs(Ht.paint_fill["fill-outline-color"]), "fill-translate": new Ys(Ht.paint_fill["fill-translate"]), "fill-translate-anchor": new Ys(Ht.paint_fill["fill-translate-anchor"]), "fill-pattern": new Hs(Ht.paint_fill["fill-pattern"]) }), layout: Uc };
          const qc = na([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Nc = na([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Gc = na([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Zc } = qc;
          var Xc = {}, Kc = d, Yc = Hc;
          function Hc(t2, e2, r2, n2, i2) {
            this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(Wc, this, e2);
          }
          function Wc(t2, e2, r2) {
            1 == t2 ? e2.id = r2.readVarint() : 2 == t2 ? function(t3, e3) {
              for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
                var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
                e3.properties[n2] = i2;
              }
            }(r2, e2) : 3 == t2 ? e2.type = r2.readVarint() : 4 == t2 && (e2._geometry = r2.pos);
          }
          function Jc(t2) {
            for (var e2, r2, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
              n2 += ((r2 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
            return n2;
          }
          Hc.types = ["Unknown", "Point", "LineString", "Polygon"], Hc.prototype.loadGeometry = function() {
            var t2 = this._pbf;
            t2.pos = this._geometry;
            for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, s2 = 0, a2 = 0, o2 = []; t2.pos < r2; ) {
              if (i2 <= 0) {
                var l2 = t2.readVarint();
                n2 = 7 & l2, i2 = l2 >> 3;
              }
              if (i2--, 1 === n2 || 2 === n2)
                s2 += t2.readSVarint(), a2 += t2.readSVarint(), 1 === n2 && (e2 && o2.push(e2), e2 = []), e2.push(new Kc(s2, a2));
              else {
                if (7 !== n2)
                  throw new Error("unknown command " + n2);
                e2 && e2.push(e2[0].clone());
              }
            }
            return e2 && o2.push(e2), o2;
          }, Hc.prototype.bbox = function() {
            var t2 = this._pbf;
            t2.pos = this._geometry;
            for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e2; ) {
              if (n2 <= 0) {
                var c2 = t2.readVarint();
                r2 = 7 & c2, n2 = c2 >> 3;
              }
              if (n2--, 1 === r2 || 2 === r2)
                (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
              else if (7 !== r2)
                throw new Error("unknown command " + r2);
            }
            return [a2, l2, o2, u2];
          }, Hc.prototype.toGeoJSON = function(t2, e2, r2) {
            var n2, i2, s2 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e2, l2 = this.loadGeometry(), u2 = Hc.types[this.type];
            function c2(t3) {
              for (var e3 = 0; e3 < t3.length; e3++) {
                var r3 = t3[e3];
                t3[e3] = [360 * (r3.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s2) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var h2 = [];
                for (n2 = 0; n2 < l2.length; n2++)
                  h2[n2] = l2[n2][0];
                c2(l2 = h2);
                break;
              case 2:
                for (n2 = 0; n2 < l2.length; n2++)
                  c2(l2[n2]);
                break;
              case 3:
                for (l2 = function(t3) {
                  var e3 = t3.length;
                  if (e3 <= 1)
                    return [t3];
                  for (var r3, n3, i3 = [], s3 = 0; s3 < e3; s3++) {
                    var a3 = Jc(t3[s3]);
                    0 !== a3 && (void 0 === n3 && (n3 = a3 < 0), n3 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s3]]) : r3.push(t3[s3]));
                  }
                  return r3 && i3.push(r3), i3;
                }(l2), n2 = 0; n2 < l2.length; n2++)
                  for (i2 = 0; i2 < l2[n2].length; i2++)
                    c2(l2[n2][i2]);
            }
            1 === l2.length ? l2 = l2[0] : u2 = "Multi" + u2;
            var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
            return "id" in this && (p2.id = this.id), p2;
          };
          var Qc = Yc, th = eh;
          function eh(t2, e2) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(rh, this, e2), this.length = this._features.length;
          }
          function rh(t2, e2, r2) {
            15 === t2 ? e2.version = r2.readVarint() : 1 === t2 ? e2.name = r2.readString() : 5 === t2 ? e2.extent = r2.readVarint() : 2 === t2 ? e2._features.push(r2.pos) : 3 === t2 ? e2._keys.push(r2.readString()) : 4 === t2 && e2._values.push(function(t3) {
              for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
                var n2 = t3.readVarint() >> 3;
                e3 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
              }
              return e3;
            }(r2));
          }
          eh.prototype.feature = function(t2) {
            if (t2 < 0 || t2 >= this._features.length)
              throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t2];
            var e2 = this._pbf.readVarint() + this._pbf.pos;
            return new Qc(this._pbf, e2, this.extent, this._keys, this._values);
          };
          var nh = th;
          function ih(t2, e2, r2) {
            if (3 === t2) {
              var n2 = new nh(r2, r2.readVarint() + r2.pos);
              n2.length && (e2[n2.name] = n2);
            }
          }
          var sh = Xc.VectorTile = function(t2, e2) {
            this.layers = t2.readFields(ih, {}, e2);
          }, ah = Xc.VectorTileFeature = Yc;
          function oh(t2, e2, r2, n2) {
            const i2 = [], s2 = 0 === n2 ? (t3, e3, r3, n3, i3, s3) => {
              t3.push(new d(s3, r3 + (s3 - e3) / (n3 - e3) * (i3 - r3)));
            } : (t3, e3, r3, n3, i3, s3) => {
              t3.push(new d(e3 + (s3 - r3) / (i3 - r3) * (n3 - e3), s3));
            };
            for (const a2 of t2) {
              const t3 = [];
              for (const i3 of a2) {
                if (i3.length <= 2)
                  continue;
                const a3 = [];
                for (let t4 = 0; t4 < i3.length - 1; t4++) {
                  const o3 = i3[t4].x, l3 = i3[t4].y, u2 = i3[t4 + 1].x, c2 = i3[t4 + 1].y, h2 = 0 === n2 ? o3 : l3, p2 = 0 === n2 ? u2 : c2;
                  h2 < e2 ? p2 > e2 && s2(a3, o3, l3, u2, c2, e2) : h2 > r2 ? p2 < r2 && s2(a3, o3, l3, u2, c2, r2) : a3.push(i3[t4]), p2 < e2 && h2 >= e2 && s2(a3, o3, l3, u2, c2, e2), p2 > r2 && h2 <= r2 && s2(a3, o3, l3, u2, c2, r2);
                }
                let o2 = i3[i3.length - 1];
                const l2 = 0 === n2 ? o2.x : o2.y;
                l2 >= e2 && l2 <= r2 && a3.push(o2), a3.length && (o2 = a3[a3.length - 1], a3[0].x === o2.x && a3[0].y === o2.y || a3.push(a3[0]), t3.push(a3));
              }
              t3.length && i2.push(t3);
            }
            return i2;
          }
          Xc.VectorTileLayer = th;
          const lh = ah.types, uh = Math.pow(2, 13);
          function ch(t2, e2, r2, n2, i2, s2, a2, o2) {
            t2.emplaceBack((e2 << 1) + a2, (r2 << 1) + s2, (Math.floor(n2 * uh) << 1) + i2, Math.round(o2));
          }
          function hh(t2, e2, r2) {
            const n2 = 16384;
            t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
          }
          class ph {
            constructor() {
              this.acc = new d(0, 0), this.polyCount = [];
            }
            startRing(t2) {
              this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new d(t2.x, t2.y), this.max = new d(t2.x, t2.y));
            }
            append(t2, e2) {
              this.currentPolyCount.edges++, this.acc._add(t2);
              const r2 = this.min, n2 = this.max;
              t2.x < r2.x ? r2.x = t2.x : t2.x > n2.x && (n2.x = t2.x), t2.y < r2.y ? r2.y = t2.y : t2.y > n2.y && (n2.y = t2.y), ((0 === t2.x || t2.x === ko) && t2.x === e2.x) != ((0 === t2.y || t2.y === ko) && t2.y === e2.y) && this.processBorderOverlap(t2, e2), e2.x < 0 != t2.x < 0 && this.addBorderIntersection(0, Mr(e2.y, t2.y, (0 - e2.x) / (t2.x - e2.x))), e2.x > ko != t2.x > ko && this.addBorderIntersection(1, Mr(e2.y, t2.y, (ko - e2.x) / (t2.x - e2.x))), e2.y < 0 != t2.y < 0 && this.addBorderIntersection(2, Mr(e2.x, t2.x, (0 - e2.y) / (t2.y - e2.y))), e2.y > ko != t2.y > ko && this.addBorderIntersection(3, Mr(e2.x, t2.x, (ko - e2.y) / (t2.y - e2.y)));
            }
            addBorderIntersection(t2, e2) {
              this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
              const r2 = this.borders[t2];
              e2 < r2[0] && (r2[0] = e2), e2 > r2[1] && (r2[1] = e2);
            }
            processBorderOverlap(t2, e2) {
              if (t2.x === e2.x) {
                if (t2.y === e2.y)
                  return;
                const r2 = 0 === t2.x ? 0 : 1;
                this.addBorderIntersection(r2, e2.y), this.addBorderIntersection(r2, t2.y);
              } else {
                const r2 = 0 === t2.y ? 2 : 3;
                this.addBorderIntersection(r2, e2.x), this.addBorderIntersection(r2, t2.x);
              }
            }
            centroid() {
              const t2 = this.polyCount.reduce((t3, e2) => t3 + e2.edges, 0);
              return 0 !== t2 ? this.acc.div(t2)._round() : new d(0, 0);
            }
            span() {
              return new d(this.max.x - this.min.x, this.max.y - this.min.y);
            }
            intersectsCount() {
              return this.borders.reduce((t2, e2) => t2 + +(e2[0] !== Number.MAX_VALUE), 0);
            }
          }
          class fh {
            constructor(t2) {
              this.zoom = t2.zoom, this.canonical = t2.canonical, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t2.projection, this.layoutVertexArray = new oa(), this.centroidVertexArray = new $a(), this.indexArray = new wa(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.segments = new So(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.enableTerrain = t2.enableTerrain;
            }
            populate(t2, e2, r2, n2) {
              this.features = [], this.hasPattern = Rc("fill-extrusion", this.layers, e2), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function(t3) {
                const e3 = Math.exp(Math.PI * (1 - t3.y / (1 << t3.z) * 2));
                return 80150034 * e3 / (e3 * e3 + 1) / ko / (1 << t3.z);
              }(r2), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
              for (const { feature: i2, id: s2, index: a2, sourceLayerIndex: o2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, l2 = wu(i2, t3);
                if (!this.layers[0]._featureFilter.filter(new $s(this.zoom), l2, r2))
                  continue;
                const u2 = { id: s2, sourceLayerIndex: o2, index: a2, geometry: t3 ? l2.geometry : bu(i2, r2, n2), properties: i2.properties, type: i2.type, patterns: {} }, c2 = this.layoutVertexArray.length;
                this.hasPattern ? this.features.push(jc("fill-extrusion", this.layers, u2, this.zoom, e2)) : this.addFeature(u2, u2.geometry, a2, r2, {}, e2.availableImages, n2), e2.featureIndex.insert(i2, u2.geometry, a2, o2, this.index, c2);
              }
              this.sortBorders();
            }
            addFeatures(t2, e2, r2, n2, i2) {
              for (const t3 of this.features) {
                const { geometry: s2 } = t3;
                this.addFeature(t3, s2, t3.index, e2, r2, n2, i2);
              }
              this.sortBorders();
            }
            update(t2, e2, r2, n2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Zc), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t2.createVertexBuffer(this.layoutVertexExtArray, Gc.members, true))), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            uploadCentroid(t2) {
              0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Nc.members, true), this.needsCentroidUpdate = false);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = [new d(0, 0), new d(ko, ko)], l2 = a2.projection, u2 = "globe" === l2.name, c2 = this.enableTerrain && !u2 ? new ph() : null, h2 = "Polygon" === lh[t2.type];
              u2 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new pa());
              const p2 = Lc(e2, 500);
              for (let t3 = p2.length - 1; t3 >= 0; t3--) {
                const e3 = p2[t3];
                (0 === e3.length || (f2 = e3[0]).every((t4) => t4.x <= 0) || f2.every((t4) => t4.x >= ko) || f2.every((t4) => t4.y <= 0) || f2.every((t4) => t4.y >= ko)) && p2.splice(t3, 1);
              }
              var f2;
              let y2;
              if (u2)
                y2 = wh(p2, o2, n2);
              else {
                y2 = [];
                for (const t3 of p2)
                  y2.push({ polygon: t3, bounds: o2 });
              }
              const m2 = h2 ? this.edgeRadius : 0;
              for (const { polygon: t3, bounds: e3 } of y2) {
                let r3 = 0, i3 = 0;
                for (const e4 of t3)
                  h2 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), i3 += h2 ? e4.length - 1 : e4.length;
                const s3 = this.segments.prepareSegment((h2 ? 5 : 4) * i3, this.layoutVertexArray, this.indexArray);
                if (h2) {
                  const e4 = [], i4 = [];
                  r3 = s3.vertexLength;
                  for (const r4 of t3) {
                    let a4, o3;
                    r4.length && r4 !== t3[0] && i4.push(e4.length / 2), a4 = r4[1].sub(r4[0])._perp()._unit();
                    for (let t4 = 1; t4 < r4.length; t4++) {
                      const i5 = r4[t4], c3 = r4[t4 === r4.length - 1 ? 1 : t4 + 1];
                      let { x: h3, y: p3 } = i5;
                      if (m2) {
                        o3 = c3.sub(i5)._perp()._unit();
                        const t5 = a4.add(o3)._unit(), e5 = m2 * Math.min(4, 1 / (a4.x * t5.x + a4.y * t5.y));
                        h3 += e5 * t5.x, p3 += e5 * t5.y, a4 = o3;
                      }
                      ch(this.layoutVertexArray, h3, p3, 0, 0, 1, 1, 0), s3.vertexLength++, e4.push(i5.x, i5.y), u2 && hh(this.layoutVertexExtArray, l2.projectTilePoint(h3, p3, n2), l2.upVector(n2, h3, p3));
                    }
                  }
                  const a3 = sc(e4, i4);
                  for (let t4 = 0; t4 < a3.length; t4 += 3)
                    this.indexArray.emplaceBack(r3 + a3[t4], r3 + a3[t4 + 2], r3 + a3[t4 + 1]), s3.primitiveLength++;
                }
                for (const i4 of t3) {
                  c2 && i4.length && c2.startRing(i4[0]);
                  let t4, a3, o3, p3 = i4.length > 4 && xh(i4[i4.length - 2], i4[0], i4[1]), f3 = m2 ? yh(i4[i4.length - 2], i4[0], i4[1], m2) : 0;
                  a3 = i4[1].sub(i4[0])._perp()._unit();
                  let d2 = true;
                  for (let y3 = 1, g2 = 0; y3 < i4.length; y3++) {
                    let x2 = i4[y3 - 1], v2 = i4[y3];
                    const b2 = i4[y3 === i4.length - 1 ? 1 : y3 + 1];
                    if (c2 && h2 && c2.currentPolyCount.top++, gh(v2, x2, e3)) {
                      m2 && (a3 = b2.sub(v2)._perp()._unit(), d2 = !d2);
                      continue;
                    }
                    c2 && c2.append(v2, x2);
                    const w2 = v2.sub(x2)._perp(), _2 = w2.x / (Math.abs(w2.x) + Math.abs(w2.y)), A2 = w2.y > 0 ? 1 : 0, S2 = x2.dist(v2);
                    if (g2 + S2 > 32768 && (g2 = 0), m2) {
                      o3 = b2.sub(v2)._perp()._unit();
                      let t5 = mh(x2, v2, b2, dh(a3, o3), m2);
                      isNaN(t5) && (t5 = 0);
                      const e4 = v2.sub(x2)._unit();
                      x2 = x2.add(e4.mult(f3))._round(), v2 = v2.add(e4.mult(-t5))._round(), f3 = t5, a3 = o3;
                    }
                    const k2 = s3.vertexLength, I2 = i4.length > 4 && xh(x2, v2, b2);
                    let M2 = vh(g2, p3, d2);
                    if (ch(this.layoutVertexArray, x2.x, x2.y, _2, A2, 0, 0, M2), ch(this.layoutVertexArray, x2.x, x2.y, _2, A2, 0, 1, M2), g2 += S2, M2 = vh(g2, I2, !d2), p3 = I2, ch(this.layoutVertexArray, v2.x, v2.y, _2, A2, 0, 0, M2), ch(this.layoutVertexArray, v2.x, v2.y, _2, A2, 0, 1, M2), s3.vertexLength += 4, this.indexArray.emplaceBack(k2 + 0, k2 + 1, k2 + 2), this.indexArray.emplaceBack(k2 + 1, k2 + 3, k2 + 2), s3.primitiveLength += 2, m2) {
                      const n3 = r3 + (1 === y3 ? i4.length - 2 : y3 - 2), a4 = 1 === y3 ? r3 : n3 + 1;
                      if (this.indexArray.emplaceBack(k2 + 1, n3, k2 + 3), this.indexArray.emplaceBack(n3, a4, k2 + 3), s3.primitiveLength += 2, void 0 === t4 && (t4 = k2), !gh(b2, i4[y3], e3)) {
                        const e4 = y3 === i4.length - 1 ? t4 : s3.vertexLength;
                        this.indexArray.emplaceBack(k2 + 2, k2 + 3, e4), this.indexArray.emplaceBack(k2 + 3, e4 + 1, e4), this.indexArray.emplaceBack(k2 + 3, a4, e4 + 1), s3.primitiveLength += 3;
                      }
                      d2 = !d2;
                    }
                    if (u2) {
                      const t5 = this.layoutVertexExtArray, e4 = l2.projectTilePoint(x2.x, x2.y, n2), r4 = l2.projectTilePoint(v2.x, v2.y, n2), i5 = l2.upVector(n2, x2.x, x2.y), s4 = l2.upVector(n2, v2.x, v2.y);
                      hh(t5, e4, i5), hh(t5, e4, i5), hh(t5, r4, s4), hh(t5, r4, s4);
                    }
                  }
                  h2 && (r3 += i4.length - 1);
                }
              }
              if (c2 && c2.polyCount.length > 0) {
                if (c2.borders) {
                  c2.vertexArrayOffset = this.centroidVertexArray.length;
                  const t3 = c2.borders, e3 = this.featuresOnBorder.push(c2) - 1;
                  for (let r3 = 0; r3 < 4; r3++)
                    t3[r3][0] !== Number.MAX_VALUE && this.borders[r3].push(e3);
                }
                this.encodeCentroid(c2.borders ? void 0 : c2.centroid(), c2);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2);
            }
            sortBorders() {
              for (let t2 = 0; t2 < 4; t2++)
                this.borders[t2].sort((e2, r2) => this.featuresOnBorder[e2].borders[t2][0] - this.featuresOnBorder[r2].borders[t2][0]);
            }
            encodeCentroid(t2, e2, r2 = true) {
              let n2, i2;
              if (t2)
                if (0 !== t2.y) {
                  const r3 = e2.span()._mult(this.tileToMeter);
                  n2 = (Math.max(t2.x, 1) << 3) + Math.min(7, Math.round(r3.x / 10)), i2 = (Math.max(t2.y, 1) << 3) + Math.min(7, Math.round(r3.y / 10));
                } else
                  n2 = Math.ceil(7 * (t2.x + 450)), i2 = 0;
              else
                n2 = 0, i2 = +r2;
              let s2 = r2 ? this.centroidVertexArray.length : e2.vertexArrayOffset;
              for (const t3 of e2.polyCount) {
                r2 && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t3.edges + t3.top);
                for (let e3 = 0; e3 < t3.top; e3++)
                  this.centroidVertexArray.emplace(s2++, n2, i2);
                for (let e3 = 0; e3 < 2 * t3.edges; e3++)
                  this.centroidVertexArray.emplace(s2++, 0, i2), this.centroidVertexArray.emplace(s2++, n2, i2);
              }
            }
          }
          function dh(t2, e2) {
            const r2 = t2.add(e2)._unit();
            return t2.x * r2.x + t2.y * r2.y;
          }
          function yh(t2, e2, r2, n2) {
            const i2 = e2.sub(t2)._perp()._unit(), s2 = r2.sub(e2)._perp()._unit();
            return mh(t2, e2, r2, dh(i2, s2), n2);
          }
          function mh(t2, e2, r2, n2, i2) {
            const s2 = Math.sqrt(1 - n2 * n2);
            return Math.min(t2.dist(e2) / 3, e2.dist(r2) / 3, i2 * s2 / n2);
          }
          function gh(t2, e2, r2) {
            return t2.x < r2[0].x && e2.x < r2[0].x || t2.x > r2[1].x && e2.x > r2[1].x || t2.y < r2[0].y && e2.y < r2[0].y || t2.y > r2[1].y && e2.y > r2[1].y;
          }
          function xh(t2, e2, r2) {
            if (t2.x < 0 || t2.x >= ko || e2.x < 0 || e2.x >= ko || r2.x < 0 || r2.x >= ko)
              return false;
            const n2 = r2.sub(e2), i2 = n2.perp(), s2 = t2.sub(e2);
            return (n2.x * s2.x + n2.y * s2.y) / Math.sqrt((n2.x * n2.x + n2.y * n2.y) * (s2.x * s2.x + s2.y * s2.y)) > -0.866 && i2.x * s2.x + i2.y * s2.y < 0;
          }
          function vh(t2, e2, r2) {
            const n2 = e2 ? 2 | t2 : -3 & t2;
            return r2 ? 1 | n2 : -2 & n2;
          }
          function bh() {
            const t2 = Math.PI / 32, e2 = Math.tan(t2), r2 = tu;
            return r2 * Math.sqrt(1 + 2 * e2 * e2) - r2;
          }
          function wh(t2, e2, r2) {
            const n2 = 1 << r2.z, i2 = ou(r2.x / n2), s2 = ou((r2.x + 1) / n2), a2 = lu(r2.y / n2), o2 = lu((r2.y + 1) / n2);
            return function(t3, e3, r3, n3, i3 = 0, s3) {
              const a3 = [];
              if (!t3.length || !r3 || !n3)
                return a3;
              const o3 = (t4, e4) => {
                for (const r4 of t4)
                  a3.push({ polygon: r4, bounds: e4 });
              }, l2 = Math.ceil(Math.log2(r3)), u2 = Math.ceil(Math.log2(n3)), c2 = l2 - u2, h2 = [];
              for (let t4 = 0; t4 < Math.abs(c2); t4++)
                h2.push(c2 > 0 ? 0 : 1);
              for (let t4 = 0; t4 < Math.min(l2, u2); t4++)
                h2.push(0), h2.push(1);
              let p2 = t3;
              if (p2 = oh(p2, e3[0].y - i3, e3[1].y + i3, 1), p2 = oh(p2, e3[0].x - i3, e3[1].x + i3, 0), !p2.length)
                return a3;
              const f2 = [];
              for (h2.length ? f2.push({ polygons: p2, bounds: e3, depth: 0 }) : o3(p2, e3); f2.length; ) {
                const t4 = f2.pop(), e4 = t4.depth, r4 = h2[e4], n4 = t4.bounds[0], a4 = t4.bounds[1], l3 = 0 === r4 ? n4.x : n4.y, u3 = 0 === r4 ? a4.x : a4.y, c3 = s3 ? s3(r4, l3, u3) : 0.5 * (l3 + u3), p3 = oh(t4.polygons, l3 - i3, c3 + i3, r4), y2 = oh(t4.polygons, c3 - i3, u3 + i3, r4);
                if (p3.length) {
                  const t5 = [n4, new d(0 === r4 ? c3 : a4.x, 1 === r4 ? c3 : a4.y)];
                  h2.length > e4 + 1 ? f2.push({ polygons: p3, bounds: t5, depth: e4 + 1 }) : o3(p3, t5);
                }
                if (y2.length) {
                  const t5 = [new d(0 === r4 ? c3 : n4.x, 1 === r4 ? c3 : n4.y), a4];
                  h2.length > e4 + 1 ? f2.push({ polygons: y2, bounds: t5, depth: e4 + 1 }) : o3(y2, t5);
                }
              }
              return a3;
            }(t2, e2, Math.ceil((s2 - i2) / 11.25), Math.ceil((a2 - o2) / 11.25), 1, (t3, e3, i3) => {
              if (0 === t3)
                return 0.5 * (e3 + i3);
              {
                const t4 = lu((r2.y + e3 / ko) / n2);
                return (su(0.5 * (lu((r2.y + i3 / ko) / n2) + t4)) * n2 - r2.y) * ko;
              }
            });
          }
          Oi(fh, "FillExtrusionBucket", { omit: ["layers", "features"] }), Oi(ph, "PartMetadata");
          const _h = new Js({ "fill-extrusion-edge-radius": new Ys(Ht["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
          var Ah = { paint: new Js({ "fill-extrusion-opacity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]) }), layout: _h };
          function Sh(t2, e2, r2) {
            var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
            return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
          }
          class kh {
            constructor(t2, e2, r2) {
              this.z = t2, this.x = e2, this.y = r2, this.key = Th(0, t2, t2, e2, r2);
            }
            equals(t2) {
              return this.z === t2.z && this.x === t2.x && this.y === t2.y;
            }
            url(t2, e2) {
              const r2 = function(t3, e3, r3) {
                var n3 = Sh(256 * t3, 256 * (e3 = Math.pow(2, r3) - e3 - 1), r3), i2 = Sh(256 * (t3 + 1), 256 * (e3 + 1), r3);
                return n3[0] + "," + n3[1] + "," + i2[0] + "," + i2[1];
              }(this.x, this.y, this.z), n2 = function(t3, e3, r3) {
                let n3, i2 = "";
                for (let s2 = t3; s2 > 0; s2--)
                  n3 = 1 << s2 - 1, i2 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
                return i2;
              }(this.z, this.x, this.y);
              return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n2).replace("{bbox-epsg-3857}", r2);
            }
            toString() {
              return `${this.z}/${this.x}/${this.y}`;
            }
          }
          class Ih {
            constructor(t2, e2) {
              this.wrap = t2, this.canonical = e2, this.key = Th(t2, e2.z, e2.z, e2.x, e2.y);
            }
          }
          class Mh {
            constructor(t2, e2, r2, n2, i2) {
              this.overscaledZ = t2, this.wrap = e2, this.canonical = new kh(r2, +n2, +i2), this.key = 0 === e2 && t2 === r2 ? this.canonical.key : Th(e2, t2, r2, n2, i2);
            }
            equals(t2) {
              return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
            }
            scaledTo(t2) {
              const e2 = this.canonical.z - t2;
              return t2 > this.canonical.z ? new Mh(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Mh(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
            }
            calculateScaledKey(t2, e2 = true) {
              if (this.overscaledZ === t2 && e2)
                return this.key;
              if (t2 > this.canonical.z)
                return Th(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y);
              {
                const r2 = this.canonical.z - t2;
                return Th(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
              }
            }
            isChildOf(t2) {
              if (t2.wrap !== this.wrap)
                return false;
              const e2 = this.canonical.z - t2.canonical.z;
              return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
            }
            children(t2) {
              if (this.overscaledZ >= t2)
                return [new Mh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
              const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
              return [new Mh(e2, this.wrap, e2, r2, n2), new Mh(e2, this.wrap, e2, r2 + 1, n2), new Mh(e2, this.wrap, e2, r2, n2 + 1), new Mh(e2, this.wrap, e2, r2 + 1, n2 + 1)];
            }
            isLessThan(t2) {
              return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
            }
            wrapped() {
              return new Mh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t2) {
              return new Mh(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
              return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
              return new Ih(this.wrap, this.canonical);
            }
            toString() {
              return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
          }
          function Th(t2, e2, r2, n2, i2) {
            const s2 = 1 << Math.min(r2, 22);
            let a2 = s2 * (i2 % s2) + n2 % s2;
            return t2 && r2 < 22 && (a2 += s2 * s2 * ((t2 < 0 ? -2 * t2 - 1 : 2 * t2) % (1 << 2 * (22 - r2)))), 16 * (32 * a2 + r2) + (e2 - r2);
          }
          Oi(kh, "CanonicalTileID"), Oi(Mh, "OverscaledTileID", { omit: ["projMatrix"] });
          class zh extends d {
            constructor(t2, e2, r2) {
              super(t2, e2), this.z = r2;
            }
          }
          function Bh(t2, e2) {
            return t2.x * e2.x + t2.y * e2.y;
          }
          function Eh(t2, e2) {
            if (1 === t2.length) {
              let r2 = 0;
              const n2 = e2[r2++];
              let i2;
              for (; !i2 || n2.equals(i2); )
                if (i2 = e2[r2++], !i2)
                  return 1 / 0;
              for (; r2 < e2.length; r2++) {
                const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = Bh(o2, o2), h2 = Bh(o2, l2), p2 = Bh(l2, l2), f2 = Bh(u2, o2), d2 = Bh(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
                if (isFinite(x2))
                  return x2;
              }
              return 1 / 0;
            }
            {
              let t3 = 1 / 0;
              for (const r2 of e2)
                t3 = Math.min(t3, r2.z);
              return t3;
            }
          }
          function Ch(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = a2 * i2.getElevationAt(t2, e2, true, true), u2 = 0 !== s2[0], c2 = u2 ? 0 === s2[1] ? a2 * (s2[0] / 7 - 450) : a2 * function(t3, e3, r3) {
              const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), a3 = 10 * (e3[1] - 8 * i3), o3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r3), u3 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (a3 * l3 - 1)), h2 = t3.tileCoordToPixel(n3, i3), p2 = 2 * u3 + 1, f2 = 2 * c3 + 1, d2 = function(t4, e4, r4, n4, i4) {
                return [t4.getElevationAtPixel(e4, r4, true), t4.getElevationAtPixel(e4 + i4, r4, true), t4.getElevationAtPixel(e4, r4 + i4, true), t4.getElevationAtPixel(e4 + n4, r4 + i4, true)];
              }(t3, h2.x - u3, h2.y - c3, p2, f2), y2 = Math.abs(d2[0] - d2[1]), m2 = Math.abs(d2[2] - d2[3]), g2 = Math.abs(d2[0] - d2[2]) + Math.abs(d2[1] - d2[3]), x2 = Math.min(0.25, 0.5 * l3 * (y2 + m2) / p2), v2 = Math.min(0.25, 0.5 * l3 * g2 / f2);
              return o3 + Math.max(x2 * s3, v2 * a3);
            }(i2, s2, o2) : l2;
            return { base: l2 + (0 === r2) ? -1 : r2, top: u2 ? Math.max(c2 + n2, l2 + r2 + 2) : l2 + n2 };
          }
          const Ph = na([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: Dh } = Ph, Vh = na([{ name: "a_packed", components: 4, type: "Float32" }]), { members: Lh } = Vh, Fh = ah.types, Rh = Math.cos(Math.PI / 180 * 37.5);
          class jh {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.projection = t2.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
                this.gradients[t3.id] = {};
              }), this.layoutVertexArray = new la(), this.layoutVertexArray2 = new ua(), this.indexArray = new wa(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.segments = new So(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r2, n2) {
              this.hasPattern = Rc("line", this.layers, e2);
              const i2 = this.layers[0].layout.get("line-sort-key"), s2 = [];
              for (const { feature: e3, id: a3, index: o3, sourceLayerIndex: l3 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u2 = wu(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new $s(this.zoom), u2, r2))
                  continue;
                const c2 = i2 ? i2.evaluate(u2, {}, r2) : void 0, h2 = { id: a3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u2.geometry : bu(e3, r2, n2), patterns: {}, sortKey: c2 };
                s2.push(h2);
              }
              i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              const { lineAtlas: a2, featureIndex: o2 } = e2, l2 = this.addConstantDashes(a2);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: u2 } = n3;
                if (l2 && this.addFeatureDashes(n3, a2), this.hasPattern) {
                  const t3 = jc("line", this.layers, n3, this.zoom, e2);
                  this.patternFeatures.push(t3);
                } else
                  this.addFeature(n3, i3, s3, r2, a2.positions, e2.availableImages);
                o2.insert(t2[s3].feature, i3, s3, u2, this.index);
              }
            }
            addConstantDashes(t2) {
              let e2 = false;
              for (const r2 of this.layers) {
                const n2 = r2.paint.get("line-dasharray").value, i2 = r2.layout.get("line-cap").value;
                if ("constant" !== n2.kind || "constant" !== i2.kind)
                  e2 = true;
                else {
                  const e3 = i2.value, r3 = n2.value;
                  if (!r3)
                    continue;
                  t2.addDash(r3, e3);
                }
              }
              return e2;
            }
            addFeatureDashes(t2, e2) {
              const r2 = this.zoom;
              for (const n2 of this.layers) {
                const i2 = n2.paint.get("line-dasharray").value, s2 = n2.layout.get("line-cap").value;
                if ("constant" === i2.kind && "constant" === s2.kind)
                  continue;
                let a2, o2;
                if ("constant" === i2.kind) {
                  if (a2 = i2.value, !a2)
                    continue;
                } else
                  a2 = i2.evaluate({ zoom: r2 }, t2);
                o2 = "constant" === s2.kind ? s2.value : s2.evaluate({ zoom: r2 }, t2), e2.addDash(a2, o2), t2.patterns[n2.id] = e2.getKey(a2, o2);
              }
            }
            update(t2, e2, r2, n2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n2);
            }
            addFeatures(t2, e2, r2, n2, i2) {
              for (const t3 of this.patternFeatures)
                this.addFeature(t3, t3.geometry, t3.index, e2, r2, n2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Lh)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Dh), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t2) {
              if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end"))
                return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
            }
            addFeature(t2, e2, r2, n2, i2, s2) {
              const a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t2, {}), l2 = a2.get("line-cap").evaluate(t2, {}), u2 = a2.get("line-miter-limit"), c2 = a2.get("line-round-limit");
              this.lineClips = this.lineFeatureClips(t2);
              for (const r3 of e2)
                this.addLine(r3, t2, o2, l2, u2, c2);
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2);
            }
            addLine(t2, e2, r2, n2, i2, s2) {
              if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
                this.lineClipsArray.push(this.lineClips);
                for (let e3 = 0; e3 < t2.length - 1; e3++)
                  this.totalDistance += t2[e3].dist(t2[e3 + 1]);
                this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
              }
              const a2 = "Polygon" === Fh[e2.type];
              let o2 = t2.length;
              for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
                o2--;
              let l2 = 0;
              for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
                l2++;
              if (o2 < (a2 ? 3 : 2))
                return;
              "bevel" === r2 && (i2 = 1.05);
              const u2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
              let h2, p2, f2, d2, y2;
              this.e1 = this.e2 = -1, a2 && (h2 = t2[o2 - 2], y2 = t2[l2].sub(h2)._unit()._perp());
              for (let e3 = l2; e3 < o2; e3++) {
                if (f2 = e3 === o2 - 1 ? a2 ? t2[l2 + 1] : void 0 : t2[e3 + 1], f2 && t2[e3].equals(f2))
                  continue;
                y2 && (d2 = y2), h2 && (p2 = h2), h2 = t2[e3], y2 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y2;
                let m2 = d2.add(y2);
                0 === m2.x && 0 === m2.y || m2._unit();
                const g2 = d2.x * y2.x + d2.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < Rh && p2 && f2, _2 = d2.x * y2.y - d2.y * y2.x > 0;
                if (w2 && e3 > l2) {
                  const t3 = h2.dist(p2);
                  if (t3 > 2 * u2) {
                    const e4 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                    this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
                  }
                }
                const A2 = p2 && f2;
                let S2 = A2 ? r2 : a2 ? "butt" : n2;
                if (A2 && "round" === S2 && (v2 < s2 ? S2 = "miter" : v2 <= 2 && (S2 = "fakeround")), "miter" === S2 && v2 > i2 && (S2 = "bevel"), "bevel" === S2 && (v2 > 2 && (S2 = "flipbevel"), v2 < i2 && (S2 = "miter")), p2 && this.updateDistance(p2, h2), "miter" === S2)
                  m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
                else if ("flipbevel" === S2) {
                  if (v2 > 100)
                    m2 = y2.mult(-1);
                  else {
                    const t3 = v2 * d2.add(y2).mag() / d2.sub(y2).mag();
                    m2._perp()._mult(t3 * (_2 ? -1 : 1));
                  }
                  this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
                } else if ("bevel" === S2 || "fakeround" === S2) {
                  const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
                  if (p2 && this.addCurrentVertex(h2, d2, e4, r3, c2), "fakeround" === S2) {
                    const t4 = Math.round(180 * b2 / Math.PI / 20);
                    for (let e5 = 1; e5 < t4; e5++) {
                      let r4 = e5 / t4;
                      if (0.5 !== r4) {
                        const t5 = r4 - 0.5;
                        r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                      }
                      const n3 = y2.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                      this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                    }
                  }
                  f2 && this.addCurrentVertex(h2, y2, -e4, -r3, c2);
                } else if ("butt" === S2)
                  this.addCurrentVertex(h2, m2, 0, 0, c2);
                else if ("square" === S2) {
                  const t3 = p2 ? 1 : -1;
                  p2 || this.addCurrentVertex(h2, m2, t3, t3, c2), this.addCurrentVertex(h2, m2, 0, 0, c2), p2 && this.addCurrentVertex(h2, m2, t3, t3, c2);
                } else
                  "round" === S2 && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, true), this.addCurrentVertex(h2, y2, 0, 0, c2)));
                if (w2 && e3 < o2 - 1) {
                  const t3 = h2.dist(f2);
                  if (t3 > 2 * u2) {
                    const e4 = h2.add(f2.sub(h2)._mult(u2 / t3)._round());
                    this.updateDistance(h2, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h2 = e4;
                  }
                }
              }
            }
            addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
              const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
              this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2);
            }
            addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
              this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
              const l2 = o2.vertexLength++;
              this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l2), o2.primitiveLength++), s2 ? this.e2 = l2 : this.e1 = l2;
            }
            updateScaledDistance() {
              if (this.lineClips) {
                const t2 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t2 * this.lineClips.start + this.distance;
              } else
                this.lineSoFar = this.distance;
            }
            updateDistance(t2, e2) {
              this.distance += t2.dist(e2), this.updateScaledDistance();
            }
          }
          Oi(jh, "LineBucket", { omit: ["layers", "patternFeatures"] });
          const $h = new Js({ "line-cap": new Hs(Ht.layout_line["line-cap"]), "line-join": new Hs(Ht.layout_line["line-join"]), "line-miter-limit": new Ys(Ht.layout_line["line-miter-limit"]), "line-round-limit": new Ys(Ht.layout_line["line-round-limit"]), "line-sort-key": new Hs(Ht.layout_line["line-sort-key"]) });
          var Uh = { paint: new Js({ "line-opacity": new Hs(Ht.paint_line["line-opacity"]), "line-color": new Hs(Ht.paint_line["line-color"]), "line-translate": new Ys(Ht.paint_line["line-translate"]), "line-translate-anchor": new Ys(Ht.paint_line["line-translate-anchor"]), "line-width": new Hs(Ht.paint_line["line-width"]), "line-gap-width": new Hs(Ht.paint_line["line-gap-width"]), "line-offset": new Hs(Ht.paint_line["line-offset"]), "line-blur": new Hs(Ht.paint_line["line-blur"]), "line-dasharray": new Hs(Ht.paint_line["line-dasharray"]), "line-pattern": new Hs(Ht.paint_line["line-pattern"]), "line-gradient": new Ws(Ht.paint_line["line-gradient"]), "line-trim-offset": new Ys(Ht.paint_line["line-trim-offset"]) }), layout: $h };
          const Oh = new class extends Hs {
            possiblyEvaluate(t2, e2) {
              return e2 = new $s(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
            }
            evaluate(t2, e2, r2, n2) {
              return e2 = z({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
            }
          }(Uh.paint.properties["line-width"].specification);
          function qh(t2, e2) {
            return e2 > 0 ? e2 + 2 * t2 : t2;
          }
          Oh.useIntegerZoom = true;
          const Nh = na([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Gh = na([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Zh = na([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
          na([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
          const Xh = na([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), Kh = na([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
          na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
          const Yh = na([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Hh = na([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          na([{ name: "triangle", components: 3, type: "Uint16" }]), na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), na([{ type: "Float32", name: "offsetX" }]), na([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
          var Wh = 24;
          const Jh = 128;
          function Qh(t2, e2) {
            const { expression: r2 } = e2;
            if ("constant" === r2.kind)
              return { kind: "constant", layoutSize: r2.evaluate(new $s(t2 + 1)) };
            if ("source" === r2.kind)
              return { kind: "source" };
            {
              const { zoomStops: e3, interpolationType: n2 } = r2;
              let i2 = 0;
              for (; i2 < e3.length && e3[i2] <= t2; )
                i2++;
              i2 = Math.max(0, i2 - 1);
              let s2 = i2;
              for (; s2 < e3.length && e3[s2] < t2 + 1; )
                s2++;
              s2 = Math.min(e3.length - 1, s2);
              const a2 = e3[i2], o2 = e3[s2];
              return "composite" === r2.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new $s(a2)), maxSize: r2.evaluate(new $s(o2)), interpolationType: n2 };
            }
          }
          function tp(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
            return "source" === t2.kind ? n2 / Jh : "composite" === t2.kind ? Mr(n2 / Jh, i2 / Jh, r2) : e2;
          }
          function ep(t2, e2) {
            let r2 = 0, n2 = 0;
            if ("constant" === t2.kind)
              n2 = t2.layoutSize;
            else if ("source" !== t2.kind) {
              const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? S(Kr.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
              "camera" === t2.kind ? n2 = Mr(t2.minSize, t2.maxSize, o2) : r2 = o2;
            }
            return { uSizeT: r2, uSize: n2 };
          }
          var rp = Object.freeze({ __proto__: null, getSizeData: Qh, evaluateSizeForFeature: tp, evaluateSizeForZoom: ep, SIZE_PACK_FACTOR: Jh });
          function np(t2, e2, r2) {
            return t2.sections.forEach((t3) => {
              t3.text = function(t4, e3, r3) {
                const n2 = e3.layout.get("text-transform").evaluate(r3, {});
                return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), js.applyArabicShaping && (t4 = js.applyArabicShaping(t4)), t4;
              }(t3.text, e2, r2);
            }), t2;
          }
          const ip = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42", "\u2190": "\u2191", "\u2192": "\u2193" };
          function sp(t2) {
            return "\uFE36" === t2 || "\uFE48" === t2 || "\uFE38" === t2 || "\uFE44" === t2 || "\uFE42" === t2 || "\uFE3E" === t2 || "\uFE3C" === t2 || "\uFE3A" === t2 || "\uFE18" === t2 || "\uFE40" === t2 || "\uFE10" === t2 || "\uFE13" === t2 || "\uFE14" === t2 || "\uFF40" === t2 || "\uFFE3" === t2 || "\uFE11" === t2 || "\uFE12" === t2;
          }
          function ap(t2) {
            return "\uFE35" === t2 || "\uFE47" === t2 || "\uFE37" === t2 || "\uFE43" === t2 || "\uFE41" === t2 || "\uFE3D" === t2 || "\uFE3B" === t2 || "\uFE39" === t2 || "\uFE17" === t2 || "\uFE3F" === t2;
          }
          var op = cp, lp = function(t2, e2, r2, n2, i2) {
            var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h2];
            for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8)
              ;
            for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8)
              ;
            if (0 === s2)
              s2 = 1 - u2;
            else {
              if (s2 === l2)
                return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
              a2 += Math.pow(2, n2), s2 -= u2;
            }
            return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
          }, up = function(t2, e2, r2, n2, i2, s2) {
            var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
            for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
              ;
            for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8)
              ;
            t2[r2 + f2 - d2] |= 128 * y2;
          };
          function cp(t2) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          cp.Varint = 0, cp.Fixed64 = 1, cp.Bytes = 2, cp.Fixed32 = 5;
          var hp = 4294967296, pp = 1 / hp, fp = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
          function dp(t2) {
            return t2.type === cp.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
          }
          function yp(t2, e2, r2) {
            return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
          }
          function mp(t2, e2, r2) {
            var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
            r2.realloc(n2);
            for (var i2 = r2.pos - 1; i2 >= t2; i2--)
              r2.buf[i2 + n2] = r2.buf[i2];
          }
          function gp(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeVarint(t2[r2]);
          }
          function xp(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeSVarint(t2[r2]);
          }
          function vp(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeFloat(t2[r2]);
          }
          function bp(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeDouble(t2[r2]);
          }
          function wp(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeBoolean(t2[r2]);
          }
          function _p(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeFixed32(t2[r2]);
          }
          function Ap(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeSFixed32(t2[r2]);
          }
          function Sp(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeFixed64(t2[r2]);
          }
          function kp(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeSFixed64(t2[r2]);
          }
          function Ip(t2, e2) {
            return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
          }
          function Mp(t2, e2, r2) {
            t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
          }
          function Tp(t2, e2) {
            return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
          }
          function zp(t2, e2, r2) {
            e2.glyphs = [], 1 === t2 && r2.readMessage(Bp, e2);
          }
          function Bp(t2, e2, r2) {
            if (3 === t2) {
              const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(Ep, {});
              e2.glyphs.push({ id: t3, bitmap: new Ju({ width: i2 + 6, height: s2 + 6 }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
            } else
              4 === t2 ? e2.ascender = r2.readSVarint() : 5 === t2 && (e2.descender = r2.readSVarint());
          }
          function Ep(t2, e2, r2) {
            1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
          }
          function Cp(t2) {
            let e2 = 0, r2 = 0;
            for (const n3 of t2)
              e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
            t2.sort((t3, e3) => e3.h - t3.h);
            const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
            let i2 = 0, s2 = 0;
            for (const e3 of t2)
              for (let t3 = n2.length - 1; t3 >= 0; t3--) {
                const r3 = n2[t3];
                if (!(e3.w > r3.w || e3.h > r3.h)) {
                  if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                    const e4 = n2.pop();
                    t3 < n2.length && (n2[t3] = e4);
                  } else
                    e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
                  break;
                }
              }
            return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
          }
          cp.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(t2, e2, r2) {
            for (r2 = r2 || this.length; this.pos < r2; ) {
              var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
              this.type = 7 & n2, t2(i2, e2, this), this.pos === s2 && this.skip(n2);
            }
            return e2;
          }, readMessage: function(t2, e2) {
            return this.readFields(t2, e2, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var t2 = Ip(this.buf, this.pos);
            return this.pos += 4, t2;
          }, readSFixed32: function() {
            var t2 = Tp(this.buf, this.pos);
            return this.pos += 4, t2;
          }, readFixed64: function() {
            var t2 = Ip(this.buf, this.pos) + Ip(this.buf, this.pos + 4) * hp;
            return this.pos += 8, t2;
          }, readSFixed64: function() {
            var t2 = Ip(this.buf, this.pos) + Tp(this.buf, this.pos + 4) * hp;
            return this.pos += 8, t2;
          }, readFloat: function() {
            var t2 = lp(this.buf, this.pos, true, 23, 4);
            return this.pos += 4, t2;
          }, readDouble: function() {
            var t2 = lp(this.buf, this.pos, true, 52, 8);
            return this.pos += 8, t2;
          }, readVarint: function(t2) {
            var e2, r2, n2 = this.buf;
            return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
              var n3, i2, s2 = r3.buf;
              if (n3 = (112 & (i2 = s2[r3.pos++])) >> 4, i2 < 128)
                return yp(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r3.pos++])) << 3, i2 < 128)
                return yp(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r3.pos++])) << 10, i2 < 128)
                return yp(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r3.pos++])) << 17, i2 < 128)
                return yp(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r3.pos++])) << 24, i2 < 128)
                return yp(t3, n3, e3);
              if (n3 |= (1 & (i2 = s2[r3.pos++])) << 31, i2 < 128)
                return yp(t3, n3, e3);
              throw new Error("Expected varint not more than 10 bytes");
            }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
          }, readVarint64: function() {
            return this.readVarint(true);
          }, readSVarint: function() {
            var t2 = this.readVarint();
            return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
          }, readBoolean: function() {
            return Boolean(this.readVarint());
          }, readString: function() {
            var t2 = this.readVarint() + this.pos, e2 = this.pos;
            return this.pos = t2, t2 - e2 >= 12 && fp ? function(t3, e3, r2) {
              return fp.decode(t3.subarray(e3, r2));
            }(this.buf, e2, t2) : function(t3, e3, r2) {
              for (var n2 = "", i2 = e3; i2 < r2; ) {
                var s2, a2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
                if (i2 + c2 > r2)
                  break;
                1 === c2 ? l2 < 128 && (u2 = l2) : 2 === c2 ? 128 == (192 & (s2 = t3[i2 + 1])) && (u2 = (31 & l2) << 6 | 63 & s2) <= 127 && (u2 = null) : 3 === c2 ? (a2 = t3[i2 + 2], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && ((u2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : 4 === c2 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && 128 == (192 & o2) && ((u2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), null === u2 ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
              }
              return n2;
            }(this.buf, e2, t2);
          }, readBytes: function() {
            var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
            return this.pos = t2, e2;
          }, readPackedVarint: function(t2, e2) {
            if (this.type !== cp.Bytes)
              return t2.push(this.readVarint(e2));
            var r2 = dp(this);
            for (t2 = t2 || []; this.pos < r2; )
              t2.push(this.readVarint(e2));
            return t2;
          }, readPackedSVarint: function(t2) {
            if (this.type !== cp.Bytes)
              return t2.push(this.readSVarint());
            var e2 = dp(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSVarint());
            return t2;
          }, readPackedBoolean: function(t2) {
            if (this.type !== cp.Bytes)
              return t2.push(this.readBoolean());
            var e2 = dp(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readBoolean());
            return t2;
          }, readPackedFloat: function(t2) {
            if (this.type !== cp.Bytes)
              return t2.push(this.readFloat());
            var e2 = dp(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFloat());
            return t2;
          }, readPackedDouble: function(t2) {
            if (this.type !== cp.Bytes)
              return t2.push(this.readDouble());
            var e2 = dp(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readDouble());
            return t2;
          }, readPackedFixed32: function(t2) {
            if (this.type !== cp.Bytes)
              return t2.push(this.readFixed32());
            var e2 = dp(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFixed32());
            return t2;
          }, readPackedSFixed32: function(t2) {
            if (this.type !== cp.Bytes)
              return t2.push(this.readSFixed32());
            var e2 = dp(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSFixed32());
            return t2;
          }, readPackedFixed64: function(t2) {
            if (this.type !== cp.Bytes)
              return t2.push(this.readFixed64());
            var e2 = dp(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFixed64());
            return t2;
          }, readPackedSFixed64: function(t2) {
            if (this.type !== cp.Bytes)
              return t2.push(this.readSFixed64());
            var e2 = dp(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSFixed64());
            return t2;
          }, skip: function(t2) {
            var e2 = 7 & t2;
            if (e2 === cp.Varint)
              for (; this.buf[this.pos++] > 127; )
                ;
            else if (e2 === cp.Bytes)
              this.pos = this.readVarint() + this.pos;
            else if (e2 === cp.Fixed32)
              this.pos += 4;
            else {
              if (e2 !== cp.Fixed64)
                throw new Error("Unimplemented type: " + e2);
              this.pos += 8;
            }
          }, writeTag: function(t2, e2) {
            this.writeVarint(t2 << 3 | e2);
          }, realloc: function(t2) {
            for (var e2 = this.length || 16; e2 < this.pos + t2; )
              e2 *= 2;
            if (e2 !== this.length) {
              var r2 = new Uint8Array(e2);
              r2.set(this.buf), this.buf = r2, this.length = e2;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(t2) {
            this.realloc(4), Mp(this.buf, t2, this.pos), this.pos += 4;
          }, writeSFixed32: function(t2) {
            this.realloc(4), Mp(this.buf, t2, this.pos), this.pos += 4;
          }, writeFixed64: function(t2) {
            this.realloc(8), Mp(this.buf, -1 & t2, this.pos), Mp(this.buf, Math.floor(t2 * pp), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(t2) {
            this.realloc(8), Mp(this.buf, -1 & t2, this.pos), Mp(this.buf, Math.floor(t2 * pp), this.pos + 4), this.pos += 8;
          }, writeVarint: function(t2) {
            (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
              var r2, n2;
              if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
                throw new Error("Given varint doesn't fit into 10 bytes");
              e2.realloc(10), function(t4, e3, r3) {
                r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
              }(r2, 0, e2), function(t4, e3) {
                var r3 = (7 & t4) << 4;
                e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
              }(n2, e2);
            }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
          }, writeSVarint: function(t2) {
            this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
          }, writeBoolean: function(t2) {
            this.writeVarint(Boolean(t2));
          }, writeString: function(t2) {
            t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
            var e2 = this.pos;
            this.pos = function(t3, e3, r3) {
              for (var n2, i2, s2 = 0; s2 < e3.length; s2++) {
                if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
                  if (!i2) {
                    n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                    continue;
                  }
                  if (n2 < 56320) {
                    t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                    continue;
                  }
                  n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
                } else
                  i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
                n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
              }
              return r3;
            }(this.buf, t2, this.pos);
            var r2 = this.pos - e2;
            r2 >= 128 && mp(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
          }, writeFloat: function(t2) {
            this.realloc(4), up(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
          }, writeDouble: function(t2) {
            this.realloc(8), up(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
          }, writeBytes: function(t2) {
            var e2 = t2.length;
            this.writeVarint(e2), this.realloc(e2);
            for (var r2 = 0; r2 < e2; r2++)
              this.buf[this.pos++] = t2[r2];
          }, writeRawMessage: function(t2, e2) {
            this.pos++;
            var r2 = this.pos;
            t2(e2, this);
            var n2 = this.pos - r2;
            n2 >= 128 && mp(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
          }, writeMessage: function(t2, e2, r2) {
            this.writeTag(t2, cp.Bytes), this.writeRawMessage(e2, r2);
          }, writePackedVarint: function(t2, e2) {
            e2.length && this.writeMessage(t2, gp, e2);
          }, writePackedSVarint: function(t2, e2) {
            e2.length && this.writeMessage(t2, xp, e2);
          }, writePackedBoolean: function(t2, e2) {
            e2.length && this.writeMessage(t2, wp, e2);
          }, writePackedFloat: function(t2, e2) {
            e2.length && this.writeMessage(t2, vp, e2);
          }, writePackedDouble: function(t2, e2) {
            e2.length && this.writeMessage(t2, bp, e2);
          }, writePackedFixed32: function(t2, e2) {
            e2.length && this.writeMessage(t2, _p, e2);
          }, writePackedSFixed32: function(t2, e2) {
            e2.length && this.writeMessage(t2, Ap, e2);
          }, writePackedFixed64: function(t2, e2) {
            e2.length && this.writeMessage(t2, Sp, e2);
          }, writePackedSFixed64: function(t2, e2) {
            e2.length && this.writeMessage(t2, kp, e2);
          }, writeBytesField: function(t2, e2) {
            this.writeTag(t2, cp.Bytes), this.writeBytes(e2);
          }, writeFixed32Field: function(t2, e2) {
            this.writeTag(t2, cp.Fixed32), this.writeFixed32(e2);
          }, writeSFixed32Field: function(t2, e2) {
            this.writeTag(t2, cp.Fixed32), this.writeSFixed32(e2);
          }, writeFixed64Field: function(t2, e2) {
            this.writeTag(t2, cp.Fixed64), this.writeFixed64(e2);
          }, writeSFixed64Field: function(t2, e2) {
            this.writeTag(t2, cp.Fixed64), this.writeSFixed64(e2);
          }, writeVarintField: function(t2, e2) {
            this.writeTag(t2, cp.Varint), this.writeVarint(e2);
          }, writeSVarintField: function(t2, e2) {
            this.writeTag(t2, cp.Varint), this.writeSVarint(e2);
          }, writeStringField: function(t2, e2) {
            this.writeTag(t2, cp.Bytes), this.writeString(e2);
          }, writeFloatField: function(t2, e2) {
            this.writeTag(t2, cp.Fixed32), this.writeFloat(e2);
          }, writeDoubleField: function(t2, e2) {
            this.writeTag(t2, cp.Fixed64), this.writeDouble(e2);
          }, writeBooleanField: function(t2, e2) {
            this.writeVarintField(t2, Boolean(e2));
          } };
          class Pp {
            constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2 }) {
              this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2;
            }
            get tl() {
              return [this.paddedRect.x + 1, this.paddedRect.y + 1];
            }
            get br() {
              return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
            }
            get displaySize() {
              return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
            }
          }
          class Dp {
            constructor(t2, e2) {
              const r2 = {}, n2 = {};
              this.haveRenderCallbacks = [];
              const i2 = [];
              this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
              const { w: s2, h: a2 } = Cp(i2), o2 = new Qu({ width: s2 || 1, height: a2 || 1 });
              for (const e3 in t2) {
                const n3 = t2[e3], i3 = r2[e3].paddedRect;
                Qu.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
              }
              for (const t3 in e2) {
                const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + 1, a3 = i3.y + 1, l2 = r3.data.width, u2 = r3.data.height;
                Qu.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), Qu.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), Qu.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), Qu.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), Qu.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
              }
              this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
            }
            addImages(t2, e2, r2) {
              for (const n2 in t2) {
                const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
                r2.push(s2), e2[n2] = new Pp(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
              }
            }
            patchUpdatedImages(t2, e2) {
              this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t2.hasImage(e3)), t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
              for (const r2 in t2.updatedImages)
                this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
            }
            patchUpdatedImage(t2, e2, r2) {
              if (!t2 || !e2)
                return;
              if (t2.version === e2.version)
                return;
              t2.version = e2.version;
              const [n2, i2] = t2.tl;
              r2.update(e2.data, void 0, { x: n2, y: i2 });
            }
          }
          Oi(Pp, "ImagePosition"), Oi(Dp, "ImageAtlas");
          const Vp = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
          class Lp {
            constructor() {
              this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t2, e2) {
              const r2 = new Lp();
              return r2.scale = t2 || 1, r2.fontStack = e2, r2;
            }
            static forImage(t2) {
              const e2 = new Lp();
              return e2.imageName = t2, e2;
            }
          }
          class Fp {
            constructor() {
              this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t2, e2) {
              const r2 = new Fp();
              for (let n2 = 0; n2 < t2.sections.length; n2++) {
                const i2 = t2.sections[n2];
                i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
              }
              return r2;
            }
            length() {
              return this.text.length;
            }
            getSection(t2) {
              return this.sections[this.sectionIndex[t2]];
            }
            getSections() {
              return this.sections;
            }
            getSectionIndex(t2) {
              return this.sectionIndex[t2];
            }
            getCharCode(t2) {
              return this.text.charCodeAt(t2);
            }
            verticalizePunctuation(t2) {
              this.text = function(t3, e2) {
                let r2 = "";
                for (let n2 = 0; n2 < t3.length; n2++) {
                  const i2 = t3.charCodeAt(n2 + 1) || null, s2 = t3.charCodeAt(n2 - 1) || null;
                  r2 += !e2 && (i2 && Ss(i2) && !ip[t3[n2 + 1]] || s2 && Ss(s2) && !ip[t3[n2 - 1]]) || !ip[t3[n2]] ? t3[n2] : ip[t3[n2]];
                }
                return r2;
              }(this.text, t2);
            }
            trim() {
              let t2 = 0;
              for (let e3 = 0; e3 < this.text.length && jp[this.text.charCodeAt(e3)]; e3++)
                t2++;
              let e2 = this.text.length;
              for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && jp[this.text.charCodeAt(r2)]; r2--)
                e2--;
              this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
            }
            substring(t2, e2) {
              const r2 = new Fp();
              return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
            }
            toString() {
              return this.text;
            }
            getMaxScale() {
              return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
            }
            addTextSection(t2, e2) {
              this.text += t2.text, this.sections.push(Lp.forText(t2.scale, t2.fontStack || e2));
              const r2 = this.sections.length - 1;
              for (let e3 = 0; e3 < t2.text.length; ++e3)
                this.sectionIndex.push(r2);
            }
            addImageSection(t2) {
              const e2 = t2.image ? t2.image.name : "";
              if (0 === e2.length)
                return void U("Can't add FormattedSection with an empty image.");
              const r2 = this.getNextImageSectionCharCode();
              r2 ? (this.text += String.fromCharCode(r2), this.sections.push(Lp.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : U("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
              return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
          }
          function Rp(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2) {
            const y2 = Fp.fromFeature(t2, i2);
            h2 === Vp.vertical && y2.verticalizePunctuation(p2);
            let m2 = [];
            const g2 = function(t3, e3, r3, n3, i3, s3) {
              if (!t3)
                return [];
              const a3 = [], o3 = function(t4, e4, r4, n4, i4, s4) {
                let a4 = 0;
                for (let r5 = 0; r5 < t4.length(); r5++) {
                  const o4 = t4.getSection(r5);
                  a4 += Up(t4.getCharCode(r5), o4, n4, i4, e4, s4);
                }
                return a4 / Math.max(1, Math.ceil(a4 / r4));
              }(t3, e3, r3, n3, i3, s3), l3 = t3.text.indexOf("\u200B") >= 0;
              let u3 = 0;
              for (let r4 = 0; r4 < t3.length(); r4++) {
                const h3 = t3.getSection(r4), p3 = t3.getCharCode(r4);
                if (jp[p3] || (u3 += Up(p3, h3, n3, i3, e3, s3)), r4 < t3.length() - 1) {
                  const e4 = !((c3 = p3) < 11904 || !(ns(c3) || rs(c3) || ms(c3) || fs(c3) || os(c3) || Hi(c3) || is(c3) || Qi(c3) || ls(c3) || us(c3) || as(c3) || vs(c3) || ts(c3) || Ji(c3) || Wi(c3) || ss(c3) || es(c3) || ys(c3) || hs(c3) || cs(c3)));
                  ($p[p3] || e4 || h3.imageName) && a3.push(Np(r4 + 1, u3, o3, a3, qp(p3, t3.getCharCode(r4 + 1), e4 && l3), false));
                }
              }
              var c3;
              return Gp(Np(t3.length(), u3, o3, a3, 0, true));
            }(y2, u2, s2, e2, n2, f2), { processBidirectionalText: x2, processStyledBidirectionalText: v2 } = js;
            if (x2 && 1 === y2.sections.length) {
              const t3 = x2(y2.toString(), g2);
              for (const e3 of t3) {
                const t4 = new Fp();
                t4.text = e3, t4.sections = y2.sections;
                for (let r3 = 0; r3 < e3.length; r3++)
                  t4.sectionIndex.push(0);
                m2.push(t4);
              }
            } else if (v2) {
              const t3 = v2(y2.text, y2.sectionIndex, g2);
              for (const e3 of t3) {
                const t4 = new Fp();
                t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = y2.sections, m2.push(t4);
              }
            } else
              m2 = function(t3, e3) {
                const r3 = [], n3 = t3.text;
                let i3 = 0;
                for (const n4 of e3)
                  r3.push(t3.substring(i3, n4)), i3 = n4;
                return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
              }(y2, g2);
            const b2 = [], w2 = { positionedLines: b2, text: y2.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h2, iconsInText: false, verticalizable: false, hasBaseline: false };
            return function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3) {
              let p3 = 0, f3 = 0, d3 = 0;
              const y3 = "right" === o3 ? 1 : "left" === o3 ? 0 : 0.5;
              let m3 = false;
              for (const t4 of i3) {
                const r4 = t4.getSections();
                for (const t5 of r4) {
                  if (t5.imageName)
                    continue;
                  const r5 = e3[t5.fontStack];
                  if (r5 && (m3 = void 0 !== r5.ascender && void 0 !== r5.descender, !m3))
                    break;
                }
                if (!m3)
                  break;
              }
              let g3 = 0;
              for (const a4 of i3) {
                a4.trim();
                const i4 = a4.getMaxScale(), o4 = (i4 - 1) * Wh, v4 = { positionedGlyphs: [], lineOffset: 0 };
                t3.positionedLines[g3] = v4;
                const b4 = v4.positionedGlyphs;
                let w4 = 0;
                if (!a4.length()) {
                  f3 += s3, ++g3;
                  continue;
                }
                let _2 = 0, A2 = 0;
                for (let s4 = 0; s4 < a4.length(); s4++) {
                  const o5 = a4.getSection(s4), d4 = a4.getSectionIndex(s4), y4 = a4.getCharCode(s4);
                  let g4 = o5.scale, v5 = null, S3 = null, k2 = null, I2 = Wh, M2 = 0;
                  const T2 = !(l3 === Vp.horizontal || !c3 && !As(y4) || c3 && (jp[y4] || (x3 = y4, Xi(x3) || Ki(x3) || Yi(x3) || ds(x3) || xs(x3))));
                  if (o5.imageName) {
                    const e4 = n3[o5.imageName];
                    if (!e4)
                      continue;
                    k2 = o5.imageName, t3.iconsInText = t3.iconsInText || true, S3 = e4.paddedRect;
                    const r4 = e4.displaySize;
                    g4 = g4 * Wh / h3, v5 = { width: r4[0], height: r4[1], left: 1, top: -3, advance: T2 ? r4[1] : r4[0], localGlyph: false }, M2 = m3 ? -v5.height * g4 : i4 * Wh - 17 - r4[1] * g4, I2 = v5.advance;
                    const s5 = (T2 ? r4[0] : r4[1]) * g4 - Wh * i4;
                    s5 > 0 && s5 > w4 && (w4 = s5);
                  } else {
                    const t4 = r3[o5.fontStack];
                    if (!t4)
                      continue;
                    t4[y4] && (S3 = t4[y4]);
                    const n4 = e3[o5.fontStack];
                    if (!n4)
                      continue;
                    const s5 = n4.glyphs[y4];
                    if (!s5)
                      continue;
                    if (v5 = s5.metrics, I2 = 8203 !== y4 ? Wh : 0, m3) {
                      const t5 = void 0 !== n4.ascender ? Math.abs(n4.ascender) : 0, e4 = void 0 !== n4.descender ? Math.abs(n4.descender) : 0, r4 = (t5 + e4) * g4;
                      _2 < r4 && (_2 = r4, A2 = (t5 - e4) / 2 * g4), M2 = -t5 * g4;
                    } else
                      M2 = (i4 - g4) * Wh - 17;
                  }
                  T2 ? (t3.verticalizable = true, b4.push({ glyph: y4, imageName: k2, x: p3, y: f3 + M2, vertical: T2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: v5, rect: S3 }), p3 += I2 * g4 + u3) : (b4.push({ glyph: y4, imageName: k2, x: p3, y: f3 + M2, vertical: T2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: v5, rect: S3 }), p3 += v5.advance * g4 + u3);
                }
                0 !== b4.length && (d3 = Math.max(p3 - u3, d3), m3 ? Xp(b4, y3, w4, A2, s3 * i4 / 2) : Xp(b4, y3, w4, 0, s3 / 2)), p3 = 0;
                const S2 = s3 * i4 + w4;
                v4.lineOffset = Math.max(w4, o4), f3 += S2, ++g3;
              }
              var x3;
              const v3 = f3, { horizontalAlign: b3, verticalAlign: w3 } = Zp(a3);
              (function(t4, e4, r4, n4, i4, s4) {
                const a4 = (e4 - r4) * i4, o4 = -s4 * n4;
                for (const e5 of t4)
                  for (const t5 of e5.positionedGlyphs)
                    t5.x += a4, t5.y += o4;
              })(t3.positionedLines, y3, b3, w3, d3, v3), t3.top += -w3 * v3, t3.bottom = t3.top + v3, t3.left += -b3 * d3, t3.right = t3.left + d3, t3.hasBaseline = m3;
            }(w2, e2, r2, n2, m2, a2, o2, l2, h2, u2, p2, d2), !function(t3) {
              for (const e3 of t3)
                if (0 !== e3.positionedGlyphs.length)
                  return false;
              return true;
            }(b2) && w2;
          }
          const jp = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, $p = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
          function Up(t2, e2, r2, n2, i2, s2) {
            if (e2.imageName) {
              const t3 = n2[e2.imageName];
              return t3 ? t3.displaySize[0] * e2.scale * Wh / s2 + i2 : 0;
            }
            {
              const n3 = r2[e2.fontStack], s3 = n3 && n3.glyphs[t2];
              return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
            }
          }
          function Op(t2, e2, r2, n2) {
            const i2 = Math.pow(t2 - e2, 2);
            return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
          }
          function qp(t2, e2, r2) {
            let n2 = 0;
            return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
          }
          function Np(t2, e2, r2, n2, i2, s2) {
            let a2 = null, o2 = Op(e2, r2, i2, s2);
            for (const t3 of n2) {
              const n3 = Op(e2 - t3.x, r2, i2, s2) + t3.badness;
              n3 <= o2 && (a2 = t3, o2 = n3);
            }
            return { index: t2, x: e2, priorBreak: a2, badness: o2 };
          }
          function Gp(t2) {
            return t2 ? Gp(t2.priorBreak).concat(t2.index) : [];
          }
          function Zp(t2) {
            let e2 = 0.5, r2 = 0.5;
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                e2 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e2 = 0;
            }
            switch (t2) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r2 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r2 = 0;
            }
            return { horizontalAlign: e2, verticalAlign: r2 };
          }
          function Xp(t2, e2, r2, n2, i2) {
            if (!(e2 || r2 || n2 || i2))
              return;
            const s2 = t2.length - 1, a2 = t2[s2], o2 = (a2.x + a2.metrics.advance * a2.scale) * e2;
            for (let e3 = 0; e3 <= s2; e3++)
              t2[e3].x -= o2, t2[e3].y += r2 + n2 + i2;
          }
          function Kp(t2, e2, r2) {
            const { horizontalAlign: n2, verticalAlign: i2 } = Zp(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
            return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
          }
          function Yp(t2, e2, r2, n2, i2, s2) {
            const a2 = t2.image;
            let o2;
            if (a2.content) {
              const t3 = a2.content, e3 = a2.pixelRatio || 1;
              o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
            }
            const l2 = e2.left * s2, u2 = e2.right * s2;
            let c2, h2, p2, f2;
            "width" === r2 || "both" === r2 ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = f2 + a2.displaySize[0]);
            const d2 = e2.top * s2, y2 = e2.bottom * s2;
            return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
          }
          class Hp extends d {
            constructor(t2, e2, r2, n2, i2) {
              super(t2, e2), this.angle = n2, this.z = r2, void 0 !== i2 && (this.segment = i2);
            }
            clone() {
              return new Hp(this.x, this.y, this.z, this.angle, this.segment);
            }
          }
          function Wp(t2, e2, r2, n2, i2) {
            if (void 0 === e2.segment)
              return true;
            let s2 = e2, a2 = e2.segment + 1, o2 = 0;
            for (; o2 > -r2 / 2; ) {
              if (a2--, a2 < 0)
                return false;
              o2 -= t2[a2].dist(s2), s2 = t2[a2];
            }
            o2 += t2[a2].dist(t2[a2 + 1]), a2++;
            const l2 = [];
            let u2 = 0;
            for (; o2 < r2 / 2; ) {
              const e3 = t2[a2], r3 = t2[a2 + 1];
              if (!r3)
                return false;
              let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
              for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; )
                u2 -= l2.shift().angleDelta;
              if (u2 > i2)
                return false;
              a2++, o2 += e3.dist(r3);
            }
            return true;
          }
          function Jp(t2) {
            let e2 = 0;
            for (let r2 = 0; r2 < t2.length - 1; r2++)
              e2 += t2[r2].dist(t2[r2 + 1]);
            return e2;
          }
          function Qp(t2, e2, r2) {
            return t2 ? 0.6 * e2 * r2 : 0;
          }
          function tf(t2, e2) {
            return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
          }
          function ef(t2, e2, r2, n2, i2, s2) {
            const a2 = Qp(r2, i2, s2), o2 = tf(r2, n2) * s2;
            let l2 = 0;
            const u2 = Jp(t2) / 2;
            for (let r3 = 0; r3 < t2.length - 1; r3++) {
              const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
              if (l2 + s3 > u2) {
                const c2 = (u2 - l2) / s3, h2 = Mr(n3.x, i3.x, c2), p2 = Mr(n3.y, i3.y, c2), f2 = new Hp(h2, p2, 0, i3.angleTo(n3), r3);
                return !a2 || Wp(t2, f2, o2, a2, e2) ? f2 : void 0;
              }
              l2 += s3;
            }
          }
          function rf(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = Qp(n2, s2, a2), c2 = tf(n2, i2), h2 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
            return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), nf(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h2, p2, false, l2);
          }
          function nf(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = s2 / 2, c2 = Jp(t2);
            let h2 = 0, p2 = e2 - r2, f2 = [];
            for (let e3 = 0; e3 < t2.length - 1; e3++) {
              const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y2 = o3.angleTo(a3);
              for (; p2 + r2 < h2 + d2; ) {
                p2 += r2;
                const m2 = (p2 - h2) / d2, g2 = Mr(a3.x, o3.x, m2), x2 = Mr(a3.y, o3.y, m2);
                if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                  const r3 = new Hp(g2, x2, 0, y2, e3);
                  r3._round(), n2 && !Wp(t2, r3, s2, n2, i2) || f2.push(r3);
                }
              }
              h2 += d2;
            }
            return o2 || f2.length || a2 || (f2 = nf(t2, h2 / 2, r2, n2, i2, s2, a2, true, l2)), f2;
          }
          function sf(t2, e2, r2, n2, i2) {
            const s2 = [];
            for (let a2 = 0; a2 < t2.length; a2++) {
              const o2 = t2[a2];
              let l2;
              for (let t3 = 0; t3 < o2.length - 1; t3++) {
                let a3 = o2[t3], u2 = o2[t3 + 1];
                a3.x < e2 && u2.x < e2 || (a3.x < e2 ? a3 = new d(e2, a3.y + (e2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x < e2 && (u2 = new d(e2, a3.y + (e2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y < r2 && u2.y < r2 || (a3.y < r2 ? a3 = new d(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round() : u2.y < r2 && (u2 = new d(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round()), a3.x >= n2 && u2.x >= n2 || (a3.x >= n2 ? a3 = new d(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x >= n2 && (u2 = new d(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y >= i2 && u2.y >= i2 || (a3.y >= i2 ? a3 = new d(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round() : u2.y >= i2 && (u2 = new d(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round()), l2 && a3.equals(l2[l2.length - 1]) || (l2 = [a3], s2.push(l2)), l2.push(u2)))));
              }
            }
            return s2;
          }
          Oi(Hp, "Anchor");
          const af = 1e20;
          function of(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            for (let u2 = e2; u2 < e2 + n2; u2++)
              lf(t2, r2 * s2 + u2, s2, i2, a2, o2, l2);
            for (let u2 = r2; u2 < r2 + i2; u2++)
              lf(t2, u2 * s2 + e2, 1, n2, a2, o2, l2);
          }
          function lf(t2, e2, r2, n2, i2, s2, a2) {
            s2[0] = 0, a2[0] = -af, a2[1] = af, i2[0] = t2[e2];
            for (let o2 = 1, l2 = 0, u2 = 0; o2 < n2; o2++) {
              i2[o2] = t2[e2 + o2 * r2];
              const n3 = o2 * o2;
              do {
                const t3 = s2[l2];
                u2 = (i2[o2] - i2[t3] + n3 - t3 * t3) / (o2 - t3) / 2;
              } while (u2 <= a2[l2] && --l2 > -1);
              l2++, s2[l2] = o2, a2[l2] = u2, a2[l2 + 1] = af;
            }
            for (let o2 = 0, l2 = 0; o2 < n2; o2++) {
              for (; a2[l2 + 1] < o2; )
                l2++;
              const n3 = s2[l2], u2 = o2 - n3;
              t2[e2 + o2 * r2] = i2[n3] + u2 * u2;
            }
          }
          const uf = { none: 0, ideographs: 1, all: 2 };
          class cf {
            constructor(t2, e2, r2) {
              this.requestManager = t2, this.localGlyphMode = e2, this.localFontFamily = r2, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
            }
            setURL(t2) {
              this.url = t2;
            }
            getGlyphs(t2, e2) {
              const r2 = [];
              for (const e3 in t2)
                for (const n2 of t2[e3])
                  r2.push({ stack: e3, id: n2 });
              M(r2, ({ stack: t3, id: e3 }, r3) => {
                let n2 = this.entries[t3];
                n2 || (n2 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
                let i2 = n2.glyphs[e3];
                if (void 0 !== i2)
                  return void r3(null, { stack: t3, id: e3, glyph: i2 });
                if (i2 = this._tinySDF(n2, t3, e3), i2)
                  return n2.glyphs[e3] = i2, void r3(null, { stack: t3, id: e3, glyph: i2 });
                const s2 = Math.floor(e3 / 256);
                if (256 * s2 > 65535)
                  return void r3(new Error("glyphs > 65535 not supported"));
                if (n2.ranges[s2])
                  return void r3(null, { stack: t3, id: e3, glyph: i2 });
                let a2 = n2.requests[s2];
                a2 || (a2 = n2.requests[s2] = [], cf.loadGlyphRange(t3, s2, this.url, this.requestManager, (t4, e4) => {
                  if (e4) {
                    n2.ascender = e4.ascender, n2.descender = e4.descender;
                    for (const t5 in e4.glyphs)
                      this._doesCharSupportLocalGlyph(+t5) || (n2.glyphs[+t5] = e4.glyphs[+t5]);
                    n2.ranges[s2] = true;
                  }
                  for (const r4 of a2)
                    r4(t4, e4);
                  delete n2.requests[s2];
                })), a2.push((n3, i3) => {
                  n3 ? r3(n3) : i3 && r3(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
                });
              }, (t3, r3) => {
                if (t3)
                  e2(t3);
                else if (r3) {
                  const t4 = {};
                  for (const { stack: e3, id: n2, glyph: i2 } of r3)
                    void 0 === t4[e3] && (t4[e3] = {}), void 0 === t4[e3].glyphs && (t4[e3].glyphs = {}), t4[e3].glyphs[n2] = i2 && { id: i2.id, bitmap: i2.bitmap.clone(), metrics: i2.metrics }, t4[e3].ascender = this.entries[e3].ascender, t4[e3].descender = this.entries[e3].descender;
                  e2(null, t4);
                }
              });
            }
            _doesCharSupportLocalGlyph(t2) {
              return this.localGlyphMode !== uf.none && (this.localGlyphMode === uf.all ? !!this.localFontFamily : !!this.localFontFamily && (us(t2) || ps(t2) || ts(t2) || es(t2) || Qi(t2)));
            }
            _tinySDF(t2, e2, r2) {
              const n2 = this.localFontFamily;
              if (!n2 || !this._doesCharSupportLocalGlyph(r2))
                return;
              let i2 = t2.tinySDF;
              if (!i2) {
                let r3 = "400";
                /bold/i.test(e2) ? r3 = "900" : /medium/i.test(e2) ? r3 = "500" : /light/i.test(e2) && (r3 = "200"), i2 = t2.tinySDF = new cf.TinySDF({ fontFamily: n2, fontWeight: r3, fontSize: 48, buffer: 6, radius: 16 }), i2.fontWeight = r3;
              }
              if (this.localGlyphs[i2.fontWeight][r2])
                return this.localGlyphs[i2.fontWeight][r2];
              const s2 = String.fromCharCode(r2), { data: a2, width: o2, height: l2, glyphWidth: u2, glyphHeight: c2, glyphLeft: h2, glyphTop: p2, glyphAdvance: f2 } = i2.draw(s2);
              return this.localGlyphs[i2.fontWeight][r2] = { id: r2, bitmap: new Ju({ width: o2, height: l2 }, a2), metrics: { width: u2 / 2, height: c2 / 2, left: h2 / 2, top: p2 / 2 - 27, advance: f2 / 2, localGlyph: true } };
            }
          }
          function hf(t2, e2, r2, n2) {
            const i2 = [], s2 = t2.image, a2 = s2.pixelRatio, o2 = s2.paddedRect.w - 2, l2 = s2.paddedRect.h - 2, u2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h2 = s2.stretchX || [[0, o2]], p2 = s2.stretchY || [[0, l2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], y2 = h2.reduce(f2, 0), m2 = p2.reduce(f2, 0), g2 = o2 - y2, x2 = l2 - m2;
            let v2 = 0, b2 = y2, w2 = 0, _2 = m2, A2 = 0, S2 = g2, k2 = 0, I2 = x2;
            if (s2.content && n2) {
              const t3 = s2.content;
              v2 = pf(h2, 0, t3[0]), w2 = pf(p2, 0, t3[1]), b2 = pf(h2, t3[0], t3[2]), _2 = pf(p2, t3[1], t3[3]), A2 = t3[0] - v2, k2 = t3[1] - w2, S2 = t3[2] - t3[0] - b2, I2 = t3[3] - t3[1] - _2;
            }
            const M2 = (n3, i3, o3, l3) => {
              const h3 = df(n3.stretch - v2, b2, u2, t2.left), p3 = yf(n3.fixed - A2, S2, n3.stretch, y2), f3 = df(i3.stretch - w2, _2, c2, t2.top), g3 = yf(i3.fixed - k2, I2, i3.stretch, m2), x3 = df(o3.stretch - v2, b2, u2, t2.left), M3 = yf(o3.fixed - A2, S2, o3.stretch, y2), T2 = df(l3.stretch - w2, _2, c2, t2.top), z2 = yf(l3.fixed - k2, I2, l3.stretch, m2), B2 = new d(h3, f3), E2 = new d(x3, f3), C2 = new d(x3, T2), P2 = new d(h3, T2), D2 = new d(p3 / a2, g3 / a2), V2 = new d(M3 / a2, z2 / a2), L2 = e2 * Math.PI / 180;
              if (L2) {
                const t3 = Math.sin(L2), e3 = Math.cos(L2), r3 = [e3, -t3, t3, e3];
                B2._matMult(r3), E2._matMult(r3), P2._matMult(r3), C2._matMult(r3);
              }
              const F2 = n3.stretch + n3.fixed, R2 = i3.stretch + i3.fixed;
              return { tl: B2, tr: E2, bl: P2, br: C2, tex: { x: s2.paddedRect.x + 1 + F2, y: s2.paddedRect.y + 1 + R2, w: o3.stretch + o3.fixed - F2, h: l3.stretch + l3.fixed - R2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: D2, pixelOffsetBR: V2, minFontScaleX: S2 / a2 / u2, minFontScaleY: I2 / a2 / c2, isSDF: r2 };
            };
            if (n2 && (s2.stretchX || s2.stretchY)) {
              const t3 = ff(h2, g2, y2), e3 = ff(p2, x2, m2);
              for (let r3 = 0; r3 < t3.length - 1; r3++) {
                const n3 = t3[r3], s3 = t3[r3 + 1];
                for (let t4 = 0; t4 < e3.length - 1; t4++)
                  i2.push(M2(n3, e3[t4], s3, e3[t4 + 1]));
              }
            } else
              i2.push(M2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
            return i2;
          }
          function pf(t2, e2, r2) {
            let n2 = 0;
            for (const i2 of t2)
              n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
            return n2;
          }
          function ff(t2, e2, r2) {
            const n2 = [{ fixed: -1, stretch: 0 }];
            for (const [e3, r3] of t2) {
              const t3 = n2[n2.length - 1];
              n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
            }
            return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
          }
          function df(t2, e2, r2, n2) {
            return t2 / e2 * r2 + n2;
          }
          function yf(t2, e2, r2, n2) {
            return t2 - e2 * r2 / n2;
          }
          function mf(t2, e2, r2, n2) {
            const i2 = e2 + t2.positionedLines[n2].lineOffset;
            return 0 === n2 ? r2 + i2 / 2 : r2 + (i2 + (e2 + t2.positionedLines[n2 - 1].lineOffset)) / 2;
          }
          cf.loadGlyphRange = function(t2, e2, r2, n2, i2) {
            const s2 = 256 * e2, a2 = s2 + 255, o2 = n2.transformRequest(n2.normalizeGlyphsURL(r2).replace("{fontstack}", t2).replace("{range}", `${s2}-${a2}`), st.Glyphs);
            ut(o2, (t3, e3) => {
              if (t3)
                i2(t3);
              else if (e3) {
                const t4 = {}, r3 = function(t5) {
                  return new op(t5).readFields(zp, {});
                }(e3);
                for (const e4 of r3.glyphs)
                  t4[e4.id] = e4;
                i2(null, { glyphs: t4, ascender: r3.ascender, descender: r3.descender });
              }
            });
          }, cf.TinySDF = class {
            constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: r2 = 8, cutoff: n2 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: a2 = "normal" } = {}) {
              this.buffer = e2, this.cutoff = n2, this.radius = r2;
              const o2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(o2), u2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
              u2.font = `${a2} ${s2} ${t2}px ${i2}`, u2.textBaseline = "alphabetic", u2.textAlign = "left", u2.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2);
            }
            _createCanvas(t2) {
              const e2 = document.createElement("canvas");
              return e2.width = e2.height = t2, e2;
            }
            draw(t2) {
              const { width: e2, actualBoundingBoxAscent: r2, actualBoundingBoxDescent: n2, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t2), a2 = Math.ceil(r2), o2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s2 - i2))), l2 = Math.min(this.size - this.buffer, a2 + Math.ceil(n2)), u2 = o2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, h2 = Math.max(u2 * c2, 0), p2 = new Uint8ClampedArray(h2), f2 = { data: p2, width: u2, height: c2, glyphWidth: o2, glyphHeight: l2, glyphTop: a2, glyphLeft: 0, glyphAdvance: e2 };
              if (0 === o2 || 0 === l2)
                return f2;
              const { ctx: d2, buffer: y2, gridInner: m2, gridOuter: g2 } = this;
              d2.clearRect(y2, y2, o2, l2), d2.fillText(t2, y2, y2 + a2);
              const x2 = d2.getImageData(y2, y2, o2, l2);
              g2.fill(af, 0, h2), m2.fill(0, 0, h2);
              for (let t3 = 0; t3 < l2; t3++)
                for (let e3 = 0; e3 < o2; e3++) {
                  const r3 = x2.data[4 * (t3 * o2 + e3) + 3] / 255;
                  if (0 === r3)
                    continue;
                  const n3 = (t3 + y2) * u2 + e3 + y2;
                  if (1 === r3)
                    g2[n3] = 0, m2[n3] = af;
                  else {
                    const t4 = 0.5 - r3;
                    g2[n3] = t4 > 0 ? t4 * t4 : 0, m2[n3] = t4 < 0 ? t4 * t4 : 0;
                  }
                }
              of(g2, 0, 0, u2, c2, u2, this.f, this.v, this.z), of(m2, y2, y2, o2, l2, u2, this.f, this.v, this.z);
              for (let t3 = 0; t3 < h2; t3++) {
                const e3 = Math.sqrt(g2[t3]) - Math.sqrt(m2[t3]);
                p2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
              }
              return f2;
            }
          };
          class gf {
            constructor(t2 = [], e2 = xf) {
              if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
                for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
                  this._down(t3);
            }
            push(t2) {
              this.data.push(t2), this.length++, this._up(this.length - 1);
            }
            pop() {
              if (0 === this.length)
                return;
              const t2 = this.data[0], e2 = this.data.pop();
              return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
            }
            peek() {
              return this.data[0];
            }
            _up(t2) {
              const { data: e2, compare: r2 } = this, n2 = e2[t2];
              for (; t2 > 0; ) {
                const i2 = t2 - 1 >> 1, s2 = e2[i2];
                if (r2(n2, s2) >= 0)
                  break;
                e2[t2] = s2, t2 = i2;
              }
              e2[t2] = n2;
            }
            _down(t2) {
              const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
              for (; t2 < n2; ) {
                let n3 = 1 + (t2 << 1), s2 = e2[n3];
                const a2 = n3 + 1;
                if (a2 < this.length && r2(e2[a2], s2) < 0 && (n3 = a2, s2 = e2[a2]), r2(s2, i2) >= 0)
                  break;
                e2[t2] = s2, t2 = n3;
              }
              e2[t2] = i2;
            }
          }
          function xf(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function vf(t2, e2 = 1, r2 = false) {
            let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
            const o2 = t2[0];
            for (let t3 = 0; t3 < o2.length; t3++) {
              const e3 = o2[t3];
              (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
            }
            const l2 = Math.min(s2 - n2, a2 - i2);
            let u2 = l2 / 2;
            const c2 = new gf([], bf);
            if (0 === l2)
              return new d(n2, i2);
            for (let e3 = n2; e3 < s2; e3 += l2)
              for (let r3 = i2; r3 < a2; r3 += l2)
                c2.push(new wf(e3 + u2, r3 + u2, u2, t2));
            let h2 = function(t3) {
              let e3 = 0, r3 = 0, n3 = 0;
              const i3 = t3[0];
              for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
                const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
                r3 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
              }
              return new wf(r3 / e3, n3 / e3, 0, t3);
            }(t2), p2 = c2.length;
            for (; c2.length; ) {
              const n3 = c2.pop();
              (n3.d > h2.d || !h2.d) && (h2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h2.d <= e2 || (u2 = n3.h / 2, c2.push(new wf(n3.p.x - u2, n3.p.y - u2, u2, t2)), c2.push(new wf(n3.p.x + u2, n3.p.y - u2, u2, t2)), c2.push(new wf(n3.p.x - u2, n3.p.y + u2, u2, t2)), c2.push(new wf(n3.p.x + u2, n3.p.y + u2, u2, t2)), p2 += 4);
            }
            return r2 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h2.d}`)), h2.p;
          }
          function bf(t2, e2) {
            return e2.max - t2.max;
          }
          class wf {
            constructor(t2, e2, r2, n2) {
              this.p = new d(t2, e2), this.h = r2, this.d = function(t3, e3) {
                let r3 = false, n3 = 1 / 0;
                for (let i2 = 0; i2 < e3.length; i2++) {
                  const s2 = e3[i2];
                  for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                    const i4 = s2[e4], o2 = s2[a2];
                    i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Cu(t3, i4, o2));
                  }
                }
                return (r3 ? 1 : -1) * Math.sqrt(n3);
              }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
            }
          }
          const _f = Number.POSITIVE_INFINITY, Af = Math.sqrt(2);
          function Sf(t2, [e2, r2]) {
            let n2 = 0, i2 = 0;
            if (r2 === _f) {
              e2 < 0 && (e2 = 0);
              const r3 = e2 / Af;
              switch (t2) {
                case "top-right":
                case "top-left":
                  i2 = r3 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                  i2 = 7 - r3;
                  break;
                case "bottom":
                  i2 = 7 - e2;
                  break;
                case "top":
                  i2 = e2 - 7;
              }
              switch (t2) {
                case "top-right":
                case "bottom-right":
                  n2 = -r3;
                  break;
                case "top-left":
                case "bottom-left":
                  n2 = r3;
                  break;
                case "left":
                  n2 = e2;
                  break;
                case "right":
                  n2 = -e2;
              }
            } else {
              switch (e2 = Math.abs(e2), r2 = Math.abs(r2), t2) {
                case "top-right":
                case "top-left":
                case "top":
                  i2 = r2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i2 = 7 - r2;
              }
              switch (t2) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n2 = -e2;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n2 = e2;
              }
            }
            return [n2, i2];
          }
          function kf(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            t2.createArrays(), t2.tilePixelRatio = ko / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
            const c2 = t2.layers[0].layout, h2 = t2.layers[0]._unevaluatedLayout._values, p2 = {};
            if ("composite" === t2.textSizeData.kind) {
              const { minZoom: e3, maxZoom: r3 } = t2.textSizeData;
              p2.compositeTextSizes = [h2["text-size"].possiblyEvaluate(new $s(e3), o2), h2["text-size"].possiblyEvaluate(new $s(r3), o2)];
            }
            if ("composite" === t2.iconSizeData.kind) {
              const { minZoom: e3, maxZoom: r3 } = t2.iconSizeData;
              p2.compositeIconSizes = [h2["icon-size"].possiblyEvaluate(new $s(e3), o2), h2["icon-size"].possiblyEvaluate(new $s(r3), o2)];
            }
            p2.layoutTextSize = h2["text-size"].possiblyEvaluate(new $s(l2 + 1), o2), p2.layoutIconSize = h2["icon-size"].possiblyEvaluate(new $s(l2 + 1), o2), p2.textMaxSize = h2["text-size"].possiblyEvaluate(new $s(18), o2);
            const f2 = "map" === c2.get("text-rotation-alignment") && "point" !== c2.get("symbol-placement"), d2 = c2.get("text-size");
            for (const s3 of t2.features) {
              const l3 = c2.get("text-font").evaluate(s3, {}, o2).join(","), h3 = d2.evaluate(s3, {}, o2), y2 = p2.layoutTextSize.evaluate(s3, {}, o2), m2 = (p2.layoutIconSize.evaluate(s3, {}, o2), { horizontal: {}, vertical: void 0 }), g2 = s3.text;
              let x2, v2 = [0, 0];
              if (g2) {
                const n3 = g2.toString(), a3 = c2.get("text-letter-spacing").evaluate(s3, {}, o2) * Wh, u3 = c2.get("text-line-height").evaluate(s3, {}, o2) * Wh, p3 = ws(n3) ? a3 : 0, d3 = c2.get("text-anchor").evaluate(s3, {}, o2), x3 = c2.get("text-variable-anchor");
                if (!x3) {
                  const t3 = c2.get("text-radial-offset").evaluate(s3, {}, o2);
                  v2 = t3 ? Sf(d3, [t3 * Wh, _f]) : c2.get("text-offset").evaluate(s3, {}, o2).map((t4) => t4 * Wh);
                }
                let b3 = f2 ? "center" : c2.get("text-justify").evaluate(s3, {}, o2);
                const w3 = "point" === c2.get("symbol-placement"), _2 = w3 ? c2.get("text-max-width").evaluate(s3, {}, o2) * Wh : 1 / 0, A2 = (s4) => {
                  t2.allowVerticalPlacement && bs(n3) && (m2.vertical = Rp(g2, e2, r2, i2, l3, _2, u3, d3, s4, p3, v2, Vp.vertical, true, y2, h3));
                };
                if (!f2 && x3) {
                  const t3 = "auto" === b3 ? x3.map((t4) => If(t4)) : [b3];
                  let n4 = false;
                  for (let s4 = 0; s4 < t3.length; s4++) {
                    const a4 = t3[s4];
                    if (!m2.horizontal[a4])
                      if (n4)
                        m2.horizontal[a4] = m2.horizontal[0];
                      else {
                        const t4 = Rp(g2, e2, r2, i2, l3, _2, u3, "center", a4, p3, v2, Vp.horizontal, false, y2, h3);
                        t4 && (m2.horizontal[a4] = t4, n4 = 1 === t4.positionedLines.length);
                      }
                  }
                  A2("left");
                } else {
                  if ("auto" === b3 && (b3 = If(d3)), w3 || c2.get("text-writing-mode").indexOf("horizontal") >= 0 || !bs(n3)) {
                    const t3 = Rp(g2, e2, r2, i2, l3, _2, u3, d3, b3, p3, v2, Vp.horizontal, false, y2, h3);
                    t3 && (m2.horizontal[b3] = t3);
                  }
                  A2(w3 ? "left" : b3);
                }
              }
              let b2 = false;
              if (s3.icon && s3.icon.name) {
                const e3 = n2[s3.icon.name];
                e3 && (x2 = Kp(i2[s3.icon.name], c2.get("icon-offset").evaluate(s3, {}, o2), c2.get("icon-anchor").evaluate(s3, {}, o2)), b2 = e3.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = e3.sdf : t2.sdfIcons !== e3.sdf && U("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e3.pixelRatio !== t2.pixelRatio || 0 !== c2.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true));
              }
              const w2 = Bf(m2.horizontal) || m2.vertical;
              t2.iconsInText || (t2.iconsInText = !!w2 && w2.iconsInText), (w2 || x2) && Mf(t2, s3, m2, x2, n2, p2, y2, 0, v2, b2, a2, o2, u2);
            }
            s2 && t2.generateCollisionDebugBuffers(l2, t2.collisionBoxArray);
          }
          function If(t2) {
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function Mf(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            let f2 = s2.textMaxSize.evaluate(e2, {}, h2);
            void 0 === f2 && (f2 = a2);
            const d2 = t2.layers[0].layout, y2 = d2.get("icon-offset").evaluate(e2, {}, h2), m2 = Bf(r2.horizontal) || r2.vertical, g2 = "globe" === p2.name, v2 = a2 / 24, b2 = t2.tilePixelRatio * f2 / 24, w2 = (z2 = t2.overscaling, t2.zoom > 18 && z2 > 2 && (z2 >>= 1), Math.max(ko / (512 * z2), 1) * d2.get("symbol-spacing")), _2 = d2.get("text-padding") * t2.tilePixelRatio, A2 = d2.get("icon-padding") * t2.tilePixelRatio, S2 = x(d2.get("text-max-angle")), k2 = "map" === d2.get("text-rotation-alignment") && "point" !== d2.get("symbol-placement"), I2 = "map" === d2.get("icon-rotation-alignment") && "point" !== d2.get("symbol-placement"), M2 = d2.get("symbol-placement"), T2 = w2 / 2;
            var z2;
            const B2 = d2.get("icon-text-fit");
            let E2;
            n2 && "none" !== B2 && (t2.allowVerticalPlacement && r2.vertical && (E2 = Yp(n2, r2.vertical, B2, d2.get("icon-text-fit-padding"), y2, v2)), m2 && (n2 = Yp(n2, m2, B2, d2.get("icon-text-fit-padding"), y2, v2)));
            const C2 = (a3, o3, f3) => {
              if (o3.x < 0 || o3.x >= ko || o3.y < 0 || o3.y >= ko)
                return;
              let d3 = null;
              if (g2) {
                const { x: t3, y: e3, z: r3 } = p2.projectTilePoint(o3.x, o3.y, f3);
                d3 = { anchor: new Hp(t3, e3, r3, 0, void 0), up: p2.upVector(f3, o3.x, o3.y) };
              }
              !function(t3, e3, r3, n3, i3, s3, a4, o4, l3, u3, c3, h3, p3, f4, d4, y3, m3, g3, x2, v3, b3, w3, _3, A3, S3) {
                const k3 = t3.addToLineVertexArray(e3, n3);
                let I3, M3, T3, z3, B3, E3, C3, P2 = 0, D2 = 0, V2 = 0, L2 = 0, F2 = -1, R2 = -1;
                const j2 = {};
                let $2 = qa("");
                const O2 = r3 ? r3.anchor : e3;
                let q2 = 0, N2 = 0;
                if (void 0 === l3._unevaluatedLayout.getValue("text-radial-offset") ? [q2, N2] = l3.layout.get("text-offset").evaluate(b3, {}, S3).map((t4) => t4 * Wh) : (q2 = l3.layout.get("text-radial-offset").evaluate(b3, {}, S3) * Wh, N2 = _f), t3.allowVerticalPlacement && i3.vertical) {
                  const t4 = i3.vertical;
                  if (d4)
                    E3 = Cf(t4), o4 && (C3 = Cf(o4));
                  else {
                    const r4 = l3.layout.get("text-rotate").evaluate(b3, {}, S3) + 90;
                    T3 = Ef(u3, O2, e3, c3, h3, p3, t4, f4, r4, y3), o4 && (z3 = Ef(u3, O2, e3, c3, h3, p3, o4, g3, r4));
                  }
                }
                if (s3) {
                  const n4 = l3.layout.get("icon-rotate").evaluate(b3, {}, S3), i4 = "none" !== l3.layout.get("icon-text-fit"), a5 = hf(s3, n4, _3, i4), f5 = o4 ? hf(o4, n4, _3, i4) : void 0;
                  M3 = Ef(u3, O2, e3, c3, h3, p3, s3, g3, n4), P2 = 4 * a5.length;
                  const d5 = t3.iconSizeData;
                  let y4 = null;
                  "source" === d5.kind ? (y4 = [Jh * l3.layout.get("icon-size").evaluate(b3, {}, S3)], y4[0] > Tf && U(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d5.kind && (y4 = [Jh * w3.compositeIconSizes[0].evaluate(b3, {}, S3), Jh * w3.compositeIconSizes[1].evaluate(b3, {}, S3)], (y4[0] > Tf || y4[1] > Tf) && U(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, a5, y4, v3, x2, b3, false, r3, e3, k3.lineStartIndex, k3.lineLength, -1, A3, S3), F2 = t3.icon.placedSymbolArray.length - 1, f5 && (D2 = 4 * f5.length, t3.addSymbols(t3.icon, f5, y4, v3, x2, b3, Vp.vertical, r3, e3, k3.lineStartIndex, k3.lineLength, -1, A3, S3), R2 = t3.icon.placedSymbolArray.length - 1);
                }
                for (const n4 in i3.horizontal) {
                  const s4 = i3.horizontal[n4];
                  I3 || ($2 = qa(s4.text), d4 ? B3 = Cf(s4) : I3 = Ef(u3, O2, e3, c3, h3, p3, s4, f4, l3.layout.get("text-rotate").evaluate(b3, {}, S3), y3));
                  const o5 = 1 === s4.positionedLines.length;
                  if (V2 += zf(t3, r3, e3, s4, a4, l3, d4, b3, y3, k3, i3.vertical ? Vp.horizontal : Vp.horizontalOnly, o5 ? Object.keys(i3.horizontal) : [n4], j2, F2, w3, A3, S3), o5)
                    break;
                }
                i3.vertical && (L2 += zf(t3, r3, e3, i3.vertical, a4, l3, d4, b3, y3, k3, Vp.vertical, ["vertical"], j2, R2, w3, A3, S3));
                let G2 = -1;
                const Z2 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
                G2 = Z2(B3, G2), G2 = Z2(E3, G2), G2 = Z2(C3, G2);
                const X2 = G2 > -1 ? 1 : 0;
                t3.glyphOffsetArray.length >= hd.MAX_GLYPHS && U("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b3.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, b3.sortKey), t3.symbolInstances.emplaceBack(O2.x, O2.y, O2.z, e3.x, e3.y, j2.right >= 0 ? j2.right : -1, j2.center >= 0 ? j2.center : -1, j2.left >= 0 ? j2.left : -1, j2.vertical >= 0 ? j2.vertical : -1, F2, R2, $2, void 0 !== I3 ? I3 : t3.collisionBoxArray.length, void 0 !== I3 ? I3 + 1 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 + 1 : t3.collisionBoxArray.length, void 0 !== M3 ? M3 : t3.collisionBoxArray.length, void 0 !== M3 ? M3 + 1 : t3.collisionBoxArray.length, z3 || t3.collisionBoxArray.length, z3 ? z3 + 1 : t3.collisionBoxArray.length, c3, V2, L2, P2, D2, X2, 0, q2, N2, G2);
              }(t2, o3, d3, a3, r2, n2, i2, E2, t2.layers[0], t2.collisionBoxArray, e2.index, e2.sourceLayerIndex, t2.index, _2, k2, l2, 0, A2, I2, y2, e2, s2, u2, c2, h2);
            };
            if ("line" === M2)
              for (const i3 of sf(e2.geometry, 0, 0, ko, ko)) {
                const e3 = rf(i3, w2, S2, r2.vertical || m2, n2, 24, b2, t2.overscaling, ko);
                for (const r3 of e3) {
                  const e4 = m2;
                  e4 && Pf(t2, e4.text, T2, r3) || C2(i3, r3, h2);
                }
              }
            else if ("line-center" === M2) {
              for (const t3 of e2.geometry)
                if (t3.length > 1) {
                  const e3 = ef(t3, S2, r2.vertical || m2, n2, 24, b2);
                  e3 && C2(t3, e3, h2);
                }
            } else if ("Polygon" === e2.type)
              for (const t3 of Lc(e2.geometry, 0)) {
                const e3 = vf(t3, 16);
                C2(t3[0], new Hp(e3.x, e3.y, 0, 0, void 0), h2);
              }
            else if ("LineString" === e2.type)
              for (const t3 of e2.geometry)
                C2(t3, new Hp(t3[0].x, t3[0].y, 0, 0, void 0), h2);
            else if ("Point" === e2.type)
              for (const t3 of e2.geometry)
                for (const e3 of t3)
                  C2([e3], new Hp(e3.x, e3.y, 0, 0, void 0), h2);
          }
          const Tf = 32640;
          function zf(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, y2, m2, g2) {
            const x2 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
              const l3 = [];
              if (0 === e3.positionedLines.length)
                return l3;
              const u3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = function(t4) {
                const e4 = t4[0], r4 = t4[1], n4 = e4 * r4;
                return n4 > 0 ? [e4, -r4] : n4 < 0 ? [-e4, r4] : 0 === e4 ? [r4, e4] : [r4, -e4];
              }(r3);
              let h3 = Math.abs(e3.top - e3.bottom);
              for (const t4 of e3.positionedLines)
                h3 -= t4.lineOffset;
              const p3 = e3.positionedLines.length, f3 = h3 / p3;
              let y3 = e3.top - r3[1];
              for (let t4 = 0; t4 < p3; ++t4) {
                const n4 = e3.positionedLines[t4];
                y3 = mf(e3, f3, y3, t4);
                for (const t5 of n4.positionedGlyphs) {
                  if (!t5.rect)
                    continue;
                  const n5 = t5.rect || {};
                  let s4 = 4, h4 = true, p4 = 1, f4 = 0;
                  if (t5.imageName) {
                    const e4 = a3[t5.imageName];
                    if (!e4)
                      continue;
                    if (e4.sdf) {
                      U("SDF images are not supported in formatted text and will be ignored.");
                      continue;
                    }
                    h4 = false, p4 = e4.pixelRatio, s4 = 1 / p4;
                  }
                  const m3 = (i3 || o3) && t5.vertical, g3 = t5.metrics.advance * t5.scale / 2, x3 = t5.metrics, v3 = t5.rect;
                  if (null === v3)
                    continue;
                  o3 && e3.verticalizable && (f4 = t5.imageName ? g3 - t5.metrics.width * t5.scale / 2 : 0);
                  const b3 = i3 ? [t5.x + g3, t5.y] : [0, 0];
                  let w2 = [0, 0], _2 = [0, 0], A2 = false;
                  i3 || (m3 ? (_2 = [t5.x + g3 + c3[0], t5.y + c3[1] - f4], A2 = true) : w2 = [t5.x + g3 + r3[0], t5.y + r3[1] - f4]);
                  const S2 = v3.w * t5.scale / (p4 * (t5.localGlyph ? 2 : 1)), k2 = v3.h * t5.scale / (p4 * (t5.localGlyph ? 2 : 1));
                  let I2, M2, T2, z2;
                  if (m3) {
                    const e4 = t5.y - y3, r4 = new d(-g3, g3 - e4), n6 = -Math.PI / 2, i4 = new d(..._2);
                    I2 = new d(-g3 + w2[0], w2[1]), I2._rotateAround(n6, r4)._add(i4), I2.x += -e4 + g3, I2.y -= (x3.left - s4) * t5.scale;
                    const a4 = t5.imageName ? x3.advance * t5.scale : Wh * t5.scale, o4 = String.fromCharCode(t5.glyph);
                    sp(o4) ? I2.x += (1 - s4) * t5.scale : ap(o4) ? I2.x += a4 - x3.height * t5.scale + (-s4 - 1) * t5.scale : I2.x += t5.imageName || x3.width + 2 * s4 === v3.w && x3.height + 2 * s4 === v3.h ? (a4 - k2) / 2 : (a4 - (x3.height + 2 * s4) * t5.scale) / 2, M2 = new d(I2.x, I2.y - S2), T2 = new d(I2.x + k2, I2.y), z2 = new d(I2.x + k2, I2.y - S2);
                  } else {
                    const e4 = (x3.left - s4) * t5.scale - g3 + w2[0], r4 = (-x3.top - s4) * t5.scale + w2[1], n6 = e4 + S2, i4 = r4 + k2;
                    I2 = new d(e4, r4), M2 = new d(n6, r4), T2 = new d(e4, i4), z2 = new d(n6, i4);
                  }
                  if (u3) {
                    let t6;
                    t6 = i3 ? new d(0, 0) : A2 ? new d(c3[0], c3[1]) : new d(r3[0], r3[1]), I2._rotateAround(u3, t6), M2._rotateAround(u3, t6), T2._rotateAround(u3, t6), z2._rotateAround(u3, t6);
                  }
                  const B2 = new d(0, 0), E2 = new d(0, 0);
                  l3.push({ tl: I2, tr: M2, bl: T2, br: z2, tex: n5, writingMode: e3.writingMode, glyphOffset: b3, sectionIndex: t5.sectionIndex, isSDF: h4, pixelOffsetTL: B2, pixelOffsetBR: E2, minFontScaleX: 0, minFontScaleY: 0 });
                }
              }
              return l3;
            }(0, n2, l2, s2, a2, o2, i2, t2.allowVerticalPlacement), v2 = t2.textSizeData;
            let b2 = null;
            "source" === v2.kind ? (b2 = [Jh * s2.layout.get("text-size").evaluate(o2, {}, g2)], b2[0] > Tf && U(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === v2.kind && (b2 = [Jh * y2.compositeTextSizes[0].evaluate(o2, {}, g2), Jh * y2.compositeTextSizes[1].evaluate(o2, {}, g2)], (b2[0] > Tf || b2[1] > Tf) && U(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t2.addSymbols(t2.text, x2, b2, l2, a2, o2, c2, e2, r2, u2.lineStartIndex, u2.lineLength, f2, m2, g2);
            for (const e3 of h2)
              p2[e3] = t2.text.placedSymbolArray.length - 1;
            return 4 * x2.length;
          }
          function Bf(t2) {
            for (const e2 in t2)
              return t2[e2];
            return null;
          }
          function Ef(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            let c2 = a2.top, h2 = a2.bottom, p2 = a2.left, f2 = a2.right;
            const y2 = a2.collisionPadding;
            if (y2 && (p2 -= y2[0], c2 -= y2[1], f2 += y2[2], h2 += y2[3]), l2) {
              const t3 = new d(p2, c2), e3 = new d(f2, c2), r3 = new d(p2, h2), n3 = new d(f2, h2), i3 = x(l2);
              let s3 = new d(0, 0);
              u2 && (s3 = new d(u2[0], u2[1])), t3._rotateAround(i3, s3), e3._rotateAround(i3, s3), r3._rotateAround(i3, s3), n3._rotateAround(i3, s3), p2 = Math.min(t3.x, e3.x, r3.x, n3.x), f2 = Math.max(t3.x, e3.x, r3.x, n3.x), c2 = Math.min(t3.y, e3.y, r3.y, n3.y), h2 = Math.max(t3.y, e3.y, r3.y, n3.y);
            }
            return t2.emplaceBack(e2.x, e2.y, e2.z, r2.x, r2.y, p2, c2, f2, h2, o2, n2, i2, s2), t2.length - 1;
          }
          function Cf(t2) {
            t2.collisionPadding && (t2.top -= t2.collisionPadding[1], t2.bottom += t2.collisionPadding[3]);
            const e2 = t2.bottom - t2.top;
            return e2 > 0 ? Math.max(10, e2) : null;
          }
          function Pf(t2, e2, r2, n2) {
            const i2 = t2.compareText;
            if (e2 in i2) {
              const t3 = i2[e2];
              for (let e3 = t3.length - 1; e3 >= 0; e3--)
                if (n2.dist(t3[e3]) < r2)
                  return true;
            } else
              i2[e2] = [];
            return i2[e2].push(n2), false;
          }
          function Df(t2, e2) {
            const r2 = t2.fovAboveCenter, n2 = t2.elevation ? t2.elevation.getMinElevationBelowMSL() * e2 : 0, i2 = (t2._camera.position[2] * t2.worldSize - n2) / Math.cos(t2._pitch), s2 = Math.sin(r2) * i2 / Math.sin(Math.max(Math.PI / 2 - t2._pitch - r2, 0.01)), a2 = Math.sin(t2._pitch) * s2 + i2;
            return Math.min(1.01 * a2, i2 * (1 / t2._horizonShift));
          }
          function Vf(t2, e2) {
            if (!e2.isReprojectedInTileSpace)
              return { scale: 1 << t2.z, x: t2.x, y: t2.y, x2: t2.x + 1, y2: t2.y + 1, projection: e2 };
            const r2 = Math.pow(2, -t2.z), n2 = t2.x * r2, i2 = (t2.x + 1) * r2, s2 = t2.y * r2, a2 = (t2.y + 1) * r2, o2 = ou(n2), l2 = ou(i2), u2 = lu(s2), c2 = lu(a2), h2 = e2.project(o2, u2), p2 = e2.project(l2, u2), f2 = e2.project(l2, c2), d2 = e2.project(o2, c2);
            let y2 = Math.min(h2.x, p2.x, f2.x, d2.x), m2 = Math.min(h2.y, p2.y, f2.y, d2.y), g2 = Math.max(h2.x, p2.x, f2.x, d2.x), x2 = Math.max(h2.y, p2.y, f2.y, d2.y);
            const v2 = r2 / 16;
            function b2(t3, r3, n3, i3, s3, a3) {
              const o3 = (n3 + s3) / 2, l3 = (i3 + a3) / 2, u3 = e2.project(ou(o3), lu(l3)), c3 = Math.max(0, y2 - u3.x, m2 - u3.y, u3.x - g2, u3.y - x2);
              y2 = Math.min(y2, u3.x), g2 = Math.max(g2, u3.x), m2 = Math.min(m2, u3.y), x2 = Math.max(x2, u3.y), c3 > v2 && (b2(t3, u3, n3, i3, o3, l3), b2(u3, r3, o3, l3, s3, a3));
            }
            b2(h2, p2, n2, s2, i2, s2), b2(p2, f2, i2, s2, i2, a2), b2(f2, d2, i2, a2, n2, a2), b2(d2, h2, n2, a2, n2, s2), y2 -= v2, m2 -= v2, g2 += v2, x2 += v2;
            const w2 = 1 / Math.max(g2 - y2, x2 - m2);
            return { scale: w2, x: y2 * w2, y: m2 * w2, x2: g2 * w2, y2: x2 * w2, projection: e2 };
          }
          const Lf = Eo(new Float32Array(16));
          class Ff {
            constructor(t2) {
              this.spec = t2, this.name = t2.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
            }
            project(t2, e2) {
              return { x: 0, y: 0, z: 0 };
            }
            unproject(t2, e2) {
              return new ru(0, 0);
            }
            projectTilePoint(t2, e2, r2) {
              return { x: t2, y: e2, z: 0 };
            }
            locationPoint(t2, e2, r2 = true) {
              return t2._coordinatePoint(t2.locationCoordinate(e2), r2);
            }
            pixelsPerMeter(t2, e2) {
              return au(1, t2) * e2;
            }
            pixelSpaceConversion(t2, e2, r2) {
              return 1;
            }
            farthestPixelDistance(t2) {
              return Df(t2, t2.pixelsPerMeter);
            }
            pointCoordinate(t2, e2, r2, n2) {
              const i2 = t2.horizonLineFromTop(false), s2 = new d(e2, Math.max(i2, r2));
              return t2.rayIntersectionCoordinate(t2.pointRayIntersection(s2, n2));
            }
            pointCoordinate3D(t2, e2, r2) {
              const n2 = new d(e2, r2);
              if (t2.elevation)
                return t2.elevation.pointCoordinate(n2);
              {
                const e3 = this.pointCoordinate(t2, n2.x, n2.y, 0);
                return [e3.x, e3.y, e3.z];
              }
            }
            isPointAboveHorizon(t2, e2) {
              if (t2.elevation)
                return !this.pointCoordinate3D(t2, e2.x, e2.y);
              const r2 = t2.horizonLineFromTop();
              return e2.y < r2;
            }
            createInversionMatrix(t2, e2) {
              return Lf;
            }
            createTileMatrix(t2, e2, r2) {
              let n2, i2, s2;
              const a2 = r2.canonical, o2 = Eo(new Float64Array(16));
              if (this.isReprojectedInTileSpace) {
                const l2 = Vf(a2, this);
                n2 = 1, i2 = l2.x + r2.wrap * l2.scale, s2 = l2.y, Vo(o2, o2, [n2 / l2.scale, n2 / l2.scale, t2.pixelsPerMeter / e2]);
              } else
                n2 = e2 / t2.zoomScale(a2.z), i2 = (a2.x + Math.pow(2, a2.z) * r2.wrap) * n2, s2 = a2.y * n2;
              return Do(o2, o2, [i2, s2, 0]), Vo(o2, o2, [n2 / ko, n2 / ko, 1]), o2;
            }
            upVector(t2, e2, r2) {
              return [0, 0, 1];
            }
            upVectorScale(t2, e2, r2) {
              return { metersToTile: 1 };
            }
          }
          class Rf extends Ff {
            constructor(t2) {
              super(t2), this.range = [4, 7], this.center = t2.center || [-96, 37.5];
              const [e2, r2] = this.parallels = t2.parallels || [29.5, 45.5], n2 = Math.sin(x(e2));
              this.n = (n2 + Math.sin(x(r2))) / 2, this.c = 1 + n2 * (2 * this.n - n2), this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t2, e2) {
              const { n: r2, c: n2, r0: i2 } = this, s2 = x(t2 - this.center[0]), a2 = x(e2), o2 = Math.sqrt(n2 - 2 * r2 * Math.sin(a2)) / r2;
              return { x: o2 * Math.sin(s2 * r2), y: o2 * Math.cos(s2 * r2) - i2, z: 0 };
            }
            unproject(t2, e2) {
              const { n: r2, c: n2, r0: i2 } = this, s2 = i2 + e2;
              let a2 = Math.atan2(t2, Math.abs(s2)) * Math.sign(s2);
              s2 * r2 < 0 && (a2 -= Math.PI * Math.sign(t2) * Math.sign(s2));
              const o2 = x(this.center[0]) * r2;
              a2 = I(a2, -Math.PI - o2, Math.PI - o2);
              const l2 = S(v(a2 / r2) + this.center[0], -180, 180), u2 = Math.asin(S((n2 - (t2 * t2 + s2 * s2) * r2 * r2) / (2 * r2), -1, 1)), c2 = S(v(u2), -cu, cu);
              return new ru(l2, c2);
            }
          }
          const jf = 1.340264, $f = -0.081106, Uf = 893e-6, Of = 3796e-6, qf = Math.sqrt(3) / 2;
          class Nf extends Ff {
            project(t2, e2) {
              e2 = e2 / 180 * Math.PI, t2 = t2 / 180 * Math.PI;
              const r2 = Math.asin(qf * Math.sin(e2)), n2 = r2 * r2, i2 = n2 * n2 * n2;
              return { x: 0.5 * (t2 * Math.cos(r2) / (qf * (jf + 3 * $f * n2 + i2 * (7 * Uf + 9 * Of * n2))) / Math.PI + 0.5), y: 1 - 0.5 * (r2 * (jf + $f * n2 + i2 * (Uf + Of * n2)) / Math.PI + 1), z: 0 };
            }
            unproject(t2, e2) {
              t2 = (2 * t2 - 0.5) * Math.PI;
              let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = r2 * r2, i2 = n2 * n2 * n2;
              for (let t3, s3, a3, o3 = 0; o3 < 12 && (s3 = r2 * (jf + $f * n2 + i2 * (Uf + Of * n2)) - e2, a3 = jf + 3 * $f * n2 + i2 * (7 * Uf + 9 * Of * n2), t3 = s3 / a3, r2 = S(r2 - t3, -Math.PI / 3, Math.PI / 3), n2 = r2 * r2, i2 = n2 * n2 * n2, !(Math.abs(t3) < 1e-12)); ++o3)
                ;
              const s2 = qf * t2 * (jf + 3 * $f * n2 + i2 * (7 * Uf + 9 * Of * n2)) / Math.cos(r2), a2 = Math.asin(Math.sin(r2) / qf), o2 = S(180 * s2 / Math.PI, -180, 180), l2 = S(180 * a2 / Math.PI, -cu, cu);
              return new ru(o2, l2);
            }
          }
          class Gf extends Ff {
            constructor(t2) {
              super(t2), this.wrap = true, this.supportsWorldCopies = true;
            }
            project(t2, e2) {
              return { x: 0.5 + t2 / 360, y: 0.5 - e2 / 360, z: 0 };
            }
            unproject(t2, e2) {
              const r2 = 360 * (t2 - 0.5), n2 = S(360 * (0.5 - e2), -cu, cu);
              return new ru(r2, n2);
            }
          }
          const Zf = Math.PI / 2;
          function Xf(t2) {
            return Math.tan((Zf + t2) / 2);
          }
          class Kf extends Ff {
            constructor(t2) {
              super(t2), this.center = t2.center || [0, 30];
              const [e2, r2] = this.parallels = t2.parallels || [30, 30];
              let n2 = x(e2), i2 = x(r2);
              this.southernCenter = n2 + i2 < 0, this.southernCenter && (n2 = -n2, i2 = -i2);
              const s2 = Math.cos(n2), a2 = Xf(n2);
              this.n = n2 === i2 ? Math.sin(n2) : Math.log(s2 / Math.cos(i2)) / Math.log(Xf(i2) / a2), this.f = s2 * Math.pow(Xf(n2), this.n) / this.n;
            }
            project(t2, e2) {
              e2 = x(e2), this.southernCenter && (e2 = -e2), t2 = x(t2 - this.center[0]);
              const r2 = 1e-6, { n: n2, f: i2 } = this;
              i2 > 0 ? e2 < -Zf + r2 && (e2 = -Zf + r2) : e2 > Zf - r2 && (e2 = Zf - r2);
              const s2 = i2 / Math.pow(Xf(e2), n2);
              let a2 = s2 * Math.sin(n2 * t2), o2 = i2 - s2 * Math.cos(n2 * t2);
              return a2 = 0.5 * (a2 / Math.PI + 0.5), o2 = 0.5 * (o2 / Math.PI + 0.5), { x: a2, y: this.southernCenter ? o2 : 1 - o2, z: 0 };
            }
            unproject(t2, e2) {
              t2 = (2 * t2 - 0.5) * Math.PI, this.southernCenter && (e2 = 1 - e2), e2 = (2 * (1 - e2) - 0.5) * Math.PI;
              const { n: r2, f: n2 } = this, i2 = n2 - e2, s2 = Math.sign(i2), a2 = Math.sign(r2) * Math.sqrt(t2 * t2 + i2 * i2);
              let o2 = Math.atan2(t2, Math.abs(i2)) * s2;
              i2 * r2 < 0 && (o2 -= Math.PI * Math.sign(t2) * s2);
              const l2 = S(v(o2 / r2) + this.center[0], -180, 180), u2 = S(v(2 * Math.atan(Math.pow(n2 / a2, 1 / r2)) - Zf), -cu, cu);
              return new ru(l2, this.southernCenter ? -u2 : u2);
            }
          }
          class Yf extends Ff {
            constructor(t2) {
              super(t2), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
            }
            project(t2, e2) {
              return { x: iu(t2), y: su(e2), z: 0 };
            }
            unproject(t2, e2) {
              const r2 = ou(t2), n2 = lu(e2);
              return new ru(r2, n2);
            }
          }
          const Hf = x(cu);
          class Wf extends Ff {
            project(t2, e2) {
              const r2 = (e2 = x(e2)) * e2, n2 = r2 * r2;
              return { x: 0.5 * ((t2 = x(t2)) * (0.8707 - 0.131979 * r2 + n2 * (n2 * (3971e-6 * r2 - 1529e-6 * n2) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e2 * (1.007226 + r2 * (0.015085 + n2 * (0.028874 * r2 - 0.044475 - 5916e-6 * n2))) / Math.PI + 1), z: 0 };
            }
            unproject(t2, e2) {
              t2 = (2 * t2 - 0.5) * Math.PI;
              let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = 25, i2 = 0, s2 = r2 * r2;
              do {
                s2 = r2 * r2;
                const t3 = s2 * s2;
                i2 = (r2 * (1.007226 + s2 * (0.015085 + t3 * (0.028874 * s2 - 0.044475 - 5916e-6 * t3))) - e2) / (1.007226 + s2 * (0.045255 + t3 * (0.259866 * s2 - 0.311325 - 5916e-6 * 11 * t3))), r2 = S(r2 - i2, -Hf, Hf);
              } while (Math.abs(i2) > 1e-6 && --n2 > 0);
              s2 = r2 * r2;
              const a2 = S(v(t2 / (0.8707 + s2 * (s2 * (s2 * s2 * s2 * (3971e-6 - 1529e-6 * s2) - 0.013791) - 0.131979))), -180, 180), o2 = v(r2);
              return new ru(a2, o2);
            }
          }
          const Jf = x(cu);
          class Qf extends Ff {
            project(t2, e2) {
              e2 = x(e2), t2 = x(t2);
              const r2 = Math.cos(e2), n2 = 2 / Math.PI, i2 = Math.acos(r2 * Math.cos(t2 / 2)), s2 = Math.sin(i2) / i2, a2 = 0.5 * (t2 * n2 + 2 * r2 * Math.sin(t2 / 2) / s2) || 0, o2 = 0.5 * (e2 + Math.sin(e2) / s2) || 0;
              return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 1), z: 0 };
            }
            unproject(t2, e2) {
              let r2 = t2 = (2 * t2 - 0.5) * Math.PI, n2 = e2 = (2 * (1 - e2) - 1) * Math.PI, i2 = 25;
              const s2 = 1e-6;
              let a2 = 0, o2 = 0;
              do {
                const i3 = Math.cos(n2), s3 = Math.sin(n2), l2 = 2 * s3 * i3, u2 = s3 * s3, c2 = i3 * i3, h2 = Math.cos(r2 / 2), p2 = Math.sin(r2 / 2), f2 = 2 * h2 * p2, d2 = p2 * p2, y2 = 1 - c2 * h2 * h2, m2 = y2 ? 1 / y2 : 0, g2 = y2 ? Math.acos(i3 * h2) * Math.sqrt(1 / y2) : 0, x2 = 0.5 * (2 * g2 * i3 * p2 + 2 * r2 / Math.PI) - t2, v2 = 0.5 * (g2 * s3 + n2) - e2, b2 = 0.5 * m2 * (c2 * d2 + g2 * i3 * h2 * u2) + 1 / Math.PI, w2 = m2 * (f2 * l2 / 4 - g2 * s3 * p2), _2 = 0.125 * m2 * (l2 * p2 - g2 * s3 * c2 * f2), A2 = 0.5 * m2 * (u2 * h2 + g2 * d2 * i3) + 0.5, k2 = w2 * _2 - A2 * b2;
                a2 = (v2 * w2 - x2 * A2) / k2, o2 = (x2 * _2 - v2 * b2) / k2, r2 = S(r2 - a2, -Math.PI, Math.PI), n2 = S(n2 - o2, -Jf, Jf);
              } while ((Math.abs(a2) > s2 || Math.abs(o2) > s2) && --i2 > 0);
              return new ru(v(r2), v(n2));
            }
          }
          class td extends Ff {
            constructor(t2) {
              super(t2), this.center = t2.center || [0, 0], this.parallels = t2.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(x(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
            }
            project(t2, e2) {
              const { scale: r2, cosPhi: n2 } = this;
              return { x: x(t2) * n2 * r2 + 0.5, y: -Math.sin(x(e2)) / n2 * r2 + 0.5, z: 0 };
            }
            unproject(t2, e2) {
              const { scale: r2, cosPhi: n2 } = this, i2 = -(e2 - 0.5) / r2, s2 = S(v((t2 - 0.5) / r2) / n2, -180, 180), a2 = Math.asin(S(i2 * n2, -1, 1)), o2 = S(v(a2), -cu, cu);
              return new ru(s2, o2);
            }
          }
          class ed extends Yf {
            constructor(t2) {
              super(t2), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
            }
            projectTilePoint(t2, e2, r2) {
              const n2 = Ol(t2, e2, r2);
              return el(n2, n2, Gl(Pl(r2))), { x: n2[0], y: n2[1], z: n2[2] };
            }
            locationPoint(t2, e2) {
              const r2 = Ul(e2.lat, e2.lng), n2 = Jo([], r2), i2 = t2.elevation ? t2.elevation.getAtPointOrZero(t2.locationCoordinate(e2), t2._centerAltitude) : t2._centerAltitude;
              Wo(r2, r2, n2, au(1, 0) * ko * i2);
              const s2 = Eo(new Float64Array(16));
              return Po(s2, t2.pixelMatrix, t2.globeMatrix), el(r2, r2, s2), new d(r2[0], r2[1]);
            }
            pixelsPerMeter(t2, e2) {
              return au(1, 0) * e2;
            }
            pixelSpaceConversion(t2, e2, r2) {
              const n2 = au(1, t2) * e2, i2 = Mr(au(1, 45) * e2, n2, r2);
              return this.pixelsPerMeter(t2, e2) / i2;
            }
            createTileMatrix(t2, e2, r2) {
              const n2 = Zl(Pl(r2.canonical));
              return Po(new Float64Array(16), t2.globeMatrix, n2);
            }
            createInversionMatrix(t2, e2) {
              const { center: r2 } = t2, n2 = Gl(Pl(e2));
              return Fo(n2, n2, x(r2.lng)), Lo(n2, n2, x(r2.lat)), Vo(n2, n2, [t2._pixelsPerMercatorPixel, t2._pixelsPerMercatorPixel, 1]), Float32Array.from(n2);
            }
            pointCoordinate(t2, e2, r2, n2) {
              return Bl(t2, e2, r2, true) || new pu(0, 0);
            }
            pointCoordinate3D(t2, e2, r2) {
              const n2 = this.pointCoordinate(t2, e2, r2, 0);
              return [n2.x, n2.y, n2.z];
            }
            isPointAboveHorizon(t2, e2) {
              return !Bl(t2, e2.x, e2.y, false);
            }
            farthestPixelDistance(t2) {
              const e2 = function(t3, e3) {
                const r3 = t3.cameraToCenterDistance, n2 = t3._centerAltitude * e3, i2 = t3._camera, s2 = t3._camera.forward(), a2 = Go([], Ho([], s2, -r3), [0, 0, n2]), o2 = t3.worldSize / (2 * Math.PI), l2 = [0, 0, -o2], u2 = t3.width / t3.height, c2 = Math.tan(t3.fovAboveCenter), h2 = Ho([], i2.up(), c2), p2 = Ho([], i2.right(), c2 * u2), f2 = Jo([], Go([], Go([], s2, h2), p2)), d2 = [];
                let y2;
                if (new vl(a2, f2).closestPointOnSphere(l2, o2, d2)) {
                  const e4 = Go([], d2, l2), r4 = il([], e4, a2);
                  y2 = Math.cos(t3.fovAboveCenter) * qo(r4);
                } else {
                  const t4 = il([], a2, l2), e4 = il([], l2, a2);
                  Jo(e4, e4);
                  const r4 = qo(t4) - o2;
                  y2 = Math.sqrt(r4 * (r4 + 2 * o2));
                  const n3 = Math.acos(y2 / (o2 + r4)) - Math.acos(Qo(s2, e4));
                  y2 *= Math.cos(n3);
                }
                return 1.01 * y2;
              }(t2, this.pixelsPerMeter(t2.center.lat, t2.worldSize)), r2 = Kl(t2.zoom);
              if (r2 > 0) {
                const n2 = Df(t2, au(1, t2.center.lat) * t2.worldSize), i2 = t2.worldSize / (2 * Math.PI), s2 = Math.max(t2.width, t2.height) / t2.worldSize * Math.PI;
                return Mr(e2, n2 + i2 * (1 - Math.cos(s2)), Math.pow(r2, 10));
              }
              return e2;
            }
            upVector(t2, e2, r2) {
              return Ol(e2, r2, t2, 1);
            }
            upVectorScale(t2) {
              return { metersToTile: zl(ql(Pl(t2))) };
            }
          }
          function rd(t2) {
            const e2 = t2.parallels, r2 = !!e2 && Math.abs(e2[0] + e2[1]) < 0.01;
            switch (t2.name) {
              case "mercator":
                return new Yf(t2);
              case "equirectangular":
                return new Gf(t2);
              case "naturalEarth":
                return new Wf(t2);
              case "equalEarth":
                return new Nf(t2);
              case "winkelTripel":
                return new Qf(t2);
              case "albers":
                return r2 ? new td(t2) : new Rf(t2);
              case "lambertConformalConic":
                return r2 ? new td(t2) : new Kf(t2);
              case "globe":
                return new ed(t2);
            }
            throw new Error(`Invalid projection name: ${t2.name}`);
          }
          const nd = ah.types, id = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function sd(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f2 = o2 ? Math.min(Tf, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(Tf, Math.round(o2[1])) : 0;
            t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
          }
          function ad(t2, e2, r2, n2, i2, s2, a2) {
            t2.emplaceBack(e2, r2, n2, i2, s2, a2);
          }
          function od(t2, e2, r2, n2, i2) {
            t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2);
          }
          function ld(t2) {
            for (const e2 of t2.sections)
              if (Ms(e2.text))
                return true;
            return false;
          }
          class ud {
            constructor(t2) {
              this.layoutVertexArray = new fa(), this.indexArray = new wa(), this.programConfigurations = t2, this.segments = new So(), this.dynamicLayoutVertexArray = new ua(), this.opacityVertexArray = new ya(), this.placedSymbolArray = new Pa(), this.globeExtVertexArray = new da();
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }
            upload(t2, e2, r2, n2) {
              this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Nh.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, Zh.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, id, true), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Gh.members, true)), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
          }
          Oi(ud, "SymbolBuffers");
          class cd {
            constructor(t2, e2, r2) {
              this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new So(), this.collisionVertexArray = new va(), this.collisionVertexArrayExt = new ba();
            }
            upload(t2) {
              this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Xh.members, true), this.collisionVertexBufferExt = t2.createVertexBuffer(this.collisionVertexArrayExt, Kh.members, true);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
          }
          Oi(cd, "CollisionBuffers");
          class hd {
            constructor(t2) {
              this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Eo([]), this.placementViewportMatrix = Eo([]);
              const e2 = this.layers[0]._unevaluatedLayout._values;
              this.textSizeData = Qh(this.zoom, e2["text-size"]), this.iconSizeData = Qh(this.zoom, e2["icon-size"]);
              const r2 = this.layers[0].layout, n2 = r2.get("symbol-sort-key"), i2 = r2.get("symbol-z-order");
              this.canOverlap = r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r2.get("text-writing-mode").map((t3) => Vp[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t2.sourceID, this.projection = t2.projection;
            }
            createArrays() {
              this.text = new ud(new fo(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new ud(new fo(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new La(), this.lineVertexArray = new Fa(), this.symbolInstances = new Va();
            }
            calculateGlyphDependencies(t2, e2, r2, n2, i2) {
              for (let r3 = 0; r3 < t2.length; r3++)
                if (e2[t2.charCodeAt(r3)] = true, n2 && i2) {
                  const n3 = ip[t2.charAt(r3)];
                  n3 && (e2[n3.charCodeAt(0)] = true);
                }
            }
            populate(t2, e2, r2, n2) {
              const i2 = this.layers[0], s2 = i2.layout, a2 = "globe" === this.projection.name, o2 = s2.get("text-font"), l2 = s2.get("text-field"), u2 = s2.get("icon-image"), c2 = ("constant" !== l2.value.kind || l2.value.value instanceof Be && !l2.value.value.isEmpty() || l2.value.value.toString().length > 0) && ("constant" !== o2.value.kind || o2.value.value.length > 0), h2 = "constant" !== u2.value.kind || !!u2.value.value || Object.keys(u2.parameters).length > 0, p2 = s2.get("symbol-sort-key");
              if (this.features = [], !c2 && !h2)
                return;
              const f2 = e2.iconDependencies, d2 = e2.glyphDependencies, y2 = e2.availableImages, m2 = new $s(this.zoom);
              for (const { feature: e3, id: l3, index: u3, sourceLayerIndex: g2 } of t2) {
                const t3 = i2._featureFilter.needGeometry, x2 = wu(e3, t3);
                if (!i2._featureFilter.filter(m2, x2, r2))
                  continue;
                if (t3 || (x2.geometry = bu(e3, r2, n2)), a2 && 1 !== e3.type && r2.z <= 5) {
                  const t4 = x2.geometry, e4 = 0.98078528056, n3 = (t5, n4) => Qo(Ol(t5.x, t5.y, r2, 1), Ol(n4.x, n4.y, r2, 1)) < e4;
                  for (let e5 = 0; e5 < t4.length; e5++)
                    t4[e5] = mu(t4[e5], n3);
                }
                let v2, b2;
                if (c2) {
                  const t4 = i2.getValueAndResolveTokens("text-field", x2, r2, y2), e4 = Be.factory(t4);
                  ld(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Fs() || this.hasRTLText && js.isParsed()) && (v2 = np(e4, i2, x2));
                }
                if (h2) {
                  const t4 = i2.getValueAndResolveTokens("icon-image", x2, r2, y2);
                  b2 = t4 instanceof Ee ? t4 : Ee.fromString(t4);
                }
                if (!v2 && !b2)
                  continue;
                const w2 = this.sortFeaturesByKey ? p2.evaluate(x2, {}, r2) : void 0;
                if (this.features.push({ id: l3, text: v2, icon: b2, index: u3, sourceLayerIndex: g2, geometry: x2.geometry, properties: e3.properties, type: nd[e3.type], sortKey: w2 }), b2 && (f2[b2.name] = true), v2) {
                  const t4 = o2.evaluate(x2, {}, r2).join(","), e4 = "map" === s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Vp.vertical) >= 0;
                  for (const r3 of v2.sections)
                    if (r3.image)
                      f2[r3.image.name] = true;
                    else {
                      const n3 = bs(v2.toString()), i3 = r3.fontStack || t4, s3 = d2[i3] = d2[i3] || {};
                      this.calculateGlyphDependencies(r3.text, s3, e4, this.allowVerticalPlacement, n3);
                    }
                }
              }
              "line" === s2.get("symbol-placement") && (this.features = function(t3) {
                const e3 = {}, r3 = {}, n3 = [];
                let i3 = 0;
                function s3(e4) {
                  n3.push(t3[e4]), i3++;
                }
                function a3(t4, e4, i4) {
                  const s4 = r3[t4];
                  return delete r3[t4], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
                }
                function o3(t4, r4, i4) {
                  const s4 = e3[r4];
                  return delete e3[r4], e3[t4] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
                }
                function l3(t4, e4, r4) {
                  const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                  return `${t4}:${n4.x}:${n4.y}`;
                }
                for (let u3 = 0; u3 < t3.length; u3++) {
                  const c3 = t3[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                  if (!p3) {
                    s3(u3);
                    continue;
                  }
                  const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
                  if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                    const t4 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t4].geometry);
                    delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t4].geometry = null;
                  } else
                    f3 in r3 ? a3(f3, d3, h3) : d3 in e3 ? o3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
                }
                return n3.filter((t4) => t4.geometry);
              }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
            }
            update(t2, e2, r2, n2) {
              this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2, n2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2, n2));
            }
            isEmpty() {
              return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
              return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t2) {
              !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
            }
            destroyDebugData() {
              this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            getProjection() {
              return this.projectionInstance || (this.projectionInstance = rd(this.projection)), this.projectionInstance;
            }
            destroy() {
              this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t2, e2) {
              const r2 = this.lineVertexArray.length;
              if (void 0 !== t2.segment)
                for (const { x: t3, y: r3 } of e2)
                  this.lineVertexArray.emplaceBack(t3, r3);
              return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
            }
            addSymbols(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2) {
              const d2 = t2.indexArray, y2 = t2.layoutVertexArray, m2 = t2.globeExtVertexArray, g2 = t2.segments.prepareSegment(4 * e2.length, y2, d2, this.canOverlap ? s2.sortKey : void 0), x2 = this.glyphOffsetArray.length, v2 = g2.vertexLength, b2 = this.allowVerticalPlacement && a2 === Vp.vertical ? Math.PI / 2 : 0, w2 = s2.text && s2.text.sections;
              for (let n3 = 0; n3 < e2.length; n3++) {
                const { tl: i3, tr: a3, bl: u3, br: c3, tex: h3, pixelOffsetTL: x3, pixelOffsetBR: v3, minFontScaleX: _3, minFontScaleY: A2, glyphOffset: S2, isSDF: k2, sectionIndex: I2 } = e2[n3], M2 = g2.vertexLength, T2 = S2[1];
                if (sd(y2, l2.x, l2.y, i3.x, T2 + i3.y, h3.x, h3.y, r2, k2, x3.x, x3.y, _3, A2), sd(y2, l2.x, l2.y, a3.x, T2 + a3.y, h3.x + h3.w, h3.y, r2, k2, v3.x, x3.y, _3, A2), sd(y2, l2.x, l2.y, u3.x, T2 + u3.y, h3.x, h3.y + h3.h, r2, k2, x3.x, v3.y, _3, A2), sd(y2, l2.x, l2.y, c3.x, T2 + c3.y, h3.x + h3.w, h3.y + h3.h, r2, k2, v3.x, v3.y, _3, A2), o2) {
                  const { x: e3, y: r3, z: n4 } = o2.anchor, [i4, s3, a4] = o2.up;
                  ad(m2, e3, r3, n4, i4, s3, a4), ad(m2, e3, r3, n4, i4, s3, a4), ad(m2, e3, r3, n4, i4, s3, a4), ad(m2, e3, r3, n4, i4, s3, a4), od(t2.dynamicLayoutVertexArray, e3, r3, n4, b2);
                } else
                  od(t2.dynamicLayoutVertexArray, l2.x, l2.y, l2.z, b2);
                d2.emplaceBack(M2, M2 + 1, M2 + 2), d2.emplaceBack(M2 + 1, M2 + 2, M2 + 3), g2.vertexLength += 4, g2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S2[0]), n3 !== e2.length - 1 && I2 === e2[n3 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(y2.length, s2, s2.index, {}, p2, f2, w2 && w2[I2]);
              }
              const _2 = o2 ? o2.anchor : l2;
              t2.placedSymbolArray.emplaceBack(_2.x, _2.y, _2.z, l2.x, l2.y, x2, this.glyphOffsetArray.length - x2, v2, u2, c2, l2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], a2, 0, false, 0, h2, 0);
            }
            _commitLayoutVertex(t2, e2, r2, n2, i2, s2, a2) {
              t2.emplaceBack(e2, r2, n2, i2, s2, Math.round(a2.x), Math.round(a2.y));
            }
            _addCollisionDebugVertices(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = r2.segments.prepareSegment(4, r2.layoutVertexArray, r2.indexArray), l2 = o2.vertexLength, u2 = a2.tileAnchorX, c2 = a2.tileAnchorY;
              for (let t3 = 0; t3 < 4; t3++)
                r2.collisionVertexArray.emplaceBack(0, 0, 0, 0);
              r2.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, -t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, t2.padding, -t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, t2.padding, t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, t2.padding), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x1, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x2, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x2, t2.y2)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x1, t2.y2)), o2.vertexLength += 4;
              const h2 = r2.indexArray;
              h2.emplaceBack(l2, l2 + 1), h2.emplaceBack(l2 + 1, l2 + 2), h2.emplaceBack(l2 + 2, l2 + 3), h2.emplaceBack(l2 + 3, l2), o2.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
                this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
              }
            }
            _addIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2.placedIconSymbolIndex);
                this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
              }
            }
            generateCollisionDebugBuffers(t2, e2) {
              this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new cd(ga, Yh.members, Ma), this.iconCollisionBox = new cd(ga, Yh.members, Ma);
              const r2 = ep(this.iconSizeData, t2), n2 = ep(this.textSizeData, t2);
              for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
                const s2 = this.symbolInstances.get(i2);
                this._addTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r2, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r2, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
              }
            }
            getSymbolInstanceTextSize(t2, e2, r2, n2) {
              const i2 = this.text.placedSymbolArray.get(e2.rightJustifiedTextSymbolIndex >= 0 ? e2.rightJustifiedTextSymbolIndex : e2.centerJustifiedTextSymbolIndex >= 0 ? e2.centerJustifiedTextSymbolIndex : e2.leftJustifiedTextSymbolIndex >= 0 ? e2.leftJustifiedTextSymbolIndex : e2.verticalPlacedTextSymbolIndex >= 0 ? e2.verticalPlacedTextSymbolIndex : n2), s2 = tp(this.textSizeData, t2, i2) / Wh;
              return this.tilePixelRatio * s2;
            }
            getSymbolInstanceIconSize(t2, e2, r2) {
              const n2 = this.icon.placedSymbolArray.get(r2), i2 = tp(this.iconSizeData, t2, n2);
              return this.tilePixelRatio * i2;
            }
            _commitDebugCollisionVertexUpdate(t2, e2, r2) {
              t2.emplaceBack(e2, -r2, -r2), t2.emplaceBack(e2, r2, -r2), t2.emplaceBack(e2, r2, r2), t2.emplaceBack(e2, -r2, r2);
            }
            _updateTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
                this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding);
              }
            }
            _updateIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2);
                this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding);
              }
            }
            updateCollisionDebugBuffers(t2, e2) {
              if (!this.hasDebugData())
                return;
              this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
              const r2 = ep(this.iconSizeData, t2), n2 = ep(this.textSizeData, t2);
              for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
                const s2 = this.symbolInstances.get(i2);
                this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r2, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r2, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2.placedIconSymbolIndex);
              }
              this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
              const u2 = {};
              if (e2 < r2) {
                const { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(e2);
                u2.textBox = { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.textFeatureIndex = f2;
              }
              if (n2 < i2) {
                const { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(n2);
                u2.verticalTextBox = { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.verticalTextFeatureIndex = f2;
              }
              if (s2 < a2) {
                const { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(s2);
                u2.iconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.iconFeatureIndex = f2;
              }
              if (o2 < l2) {
                const { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(o2);
                u2.verticalIconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.verticalIconFeatureIndex = f2;
              }
              return u2;
            }
            deserializeCollisionBoxes(t2) {
              this.collisionArrays = [];
              for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
                const r2 = this.symbolInstances.get(e2);
                this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
              }
            }
            hasTextData() {
              return this.text.segments.get().length > 0;
            }
            hasIconData() {
              return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
              return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
              return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
              return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t2, e2) {
              const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
              for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4)
                t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
            }
            getSortedSymbolIndexes(t2) {
              if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
                return this.symbolInstanceIndexes;
              const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
              for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
                s2.push(t3);
                const a2 = this.symbolInstances.get(t3);
                n2.push(0 | Math.round(e2 * a2.tileAnchorX + r2 * a2.tileAnchorY)), i2.push(a2.featureIndex);
              }
              return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
            }
            addToSortKeyRanges(t2, e2) {
              const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
              r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
            }
            sortFeatures(t2) {
              if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                for (const t3 of this.symbolInstanceIndexes) {
                  const e2 = this.symbolInstances.get(t3);
                  this.featureSortOrder.push(e2.featureIndex);
                  const { rightJustifiedTextSymbolIndex: r2, centerJustifiedTextSymbolIndex: n2, leftJustifiedTextSymbolIndex: i2, verticalPlacedTextSymbolIndex: s2, placedIconSymbolIndex: a2, verticalPlacedIconSymbolIndex: o2 } = e2;
                  r2 >= 0 && this.addIndicesForPlacedSymbol(this.text, r2), n2 >= 0 && n2 !== r2 && this.addIndicesForPlacedSymbol(this.text, n2), i2 >= 0 && i2 !== n2 && i2 !== r2 && this.addIndicesForPlacedSymbol(this.text, i2), s2 >= 0 && this.addIndicesForPlacedSymbol(this.text, s2), a2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o2);
                }
                this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
              }
            }
          }
          Oi(hd, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), hd.MAX_GLYPHS = 65535, hd.addDynamicAttributes = od;
          const pd = new Js({ "symbol-placement": new Ys(Ht.layout_symbol["symbol-placement"]), "symbol-spacing": new Ys(Ht.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ys(Ht.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Hs(Ht.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ys(Ht.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Ys(Ht.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Ys(Ht.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ys(Ht.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ys(Ht.layout_symbol["icon-rotation-alignment"]), "icon-size": new Hs(Ht.layout_symbol["icon-size"]), "icon-text-fit": new Ys(Ht.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ys(Ht.layout_symbol["icon-text-fit-padding"]), "icon-image": new Hs(Ht.layout_symbol["icon-image"]), "icon-rotate": new Hs(Ht.layout_symbol["icon-rotate"]), "icon-padding": new Ys(Ht.layout_symbol["icon-padding"]), "icon-keep-upright": new Ys(Ht.layout_symbol["icon-keep-upright"]), "icon-offset": new Hs(Ht.layout_symbol["icon-offset"]), "icon-anchor": new Hs(Ht.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ys(Ht.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ys(Ht.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ys(Ht.layout_symbol["text-rotation-alignment"]), "text-field": new Hs(Ht.layout_symbol["text-field"]), "text-font": new Hs(Ht.layout_symbol["text-font"]), "text-size": new Hs(Ht.layout_symbol["text-size"]), "text-max-width": new Hs(Ht.layout_symbol["text-max-width"]), "text-line-height": new Hs(Ht.layout_symbol["text-line-height"]), "text-letter-spacing": new Hs(Ht.layout_symbol["text-letter-spacing"]), "text-justify": new Hs(Ht.layout_symbol["text-justify"]), "text-radial-offset": new Hs(Ht.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ys(Ht.layout_symbol["text-variable-anchor"]), "text-anchor": new Hs(Ht.layout_symbol["text-anchor"]), "text-max-angle": new Ys(Ht.layout_symbol["text-max-angle"]), "text-writing-mode": new Ys(Ht.layout_symbol["text-writing-mode"]), "text-rotate": new Hs(Ht.layout_symbol["text-rotate"]), "text-padding": new Ys(Ht.layout_symbol["text-padding"]), "text-keep-upright": new Ys(Ht.layout_symbol["text-keep-upright"]), "text-transform": new Hs(Ht.layout_symbol["text-transform"]), "text-offset": new Hs(Ht.layout_symbol["text-offset"]), "text-allow-overlap": new Ys(Ht.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Ys(Ht.layout_symbol["text-ignore-placement"]), "text-optional": new Ys(Ht.layout_symbol["text-optional"]) });
          var fd = { paint: new Js({ "icon-opacity": new Hs(Ht.paint_symbol["icon-opacity"]), "icon-color": new Hs(Ht.paint_symbol["icon-color"]), "icon-halo-color": new Hs(Ht.paint_symbol["icon-halo-color"]), "icon-halo-width": new Hs(Ht.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Hs(Ht.paint_symbol["icon-halo-blur"]), "icon-translate": new Ys(Ht.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ys(Ht.paint_symbol["icon-translate-anchor"]), "text-opacity": new Hs(Ht.paint_symbol["text-opacity"]), "text-color": new Hs(Ht.paint_symbol["text-color"], { runtimeType: le, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new Hs(Ht.paint_symbol["text-halo-color"]), "text-halo-width": new Hs(Ht.paint_symbol["text-halo-width"]), "text-halo-blur": new Hs(Ht.paint_symbol["text-halo-blur"]), "text-translate": new Ys(Ht.paint_symbol["text-translate"]), "text-translate-anchor": new Ys(Ht.paint_symbol["text-translate-anchor"]) }), layout: pd };
          class dd {
            constructor(t2) {
              this.type = t2.property.overrides ? t2.property.overrides.runtimeType : ie, this.defaultValue = t2;
            }
            evaluate(t2) {
              if (t2.formattedSection) {
                const e2 = this.defaultValue.property.overrides;
                if (e2 && e2.hasOverride(t2.formattedSection))
                  return e2.getOverride(t2.formattedSection);
              }
              return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t2) {
              this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return null;
            }
          }
          Oi(dd, "FormatSectionOverride", { omit: ["defaultValue"] });
          class yd extends wo {
            constructor(t2) {
              super(t2, fd);
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
              const r2 = this.layout.get("text-writing-mode");
              if (r2) {
                const t3 = [];
                for (const e3 of r2)
                  t3.indexOf(e3) < 0 && t3.push(e3);
                this.layout._values["text-writing-mode"] = t3;
              } else
                this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
              this._setPaintOverrides();
            }
            getValueAndResolveTokens(t2, e2, r2, n2) {
              const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
              return s2.isDataDriven() || Nn(s2.value) || !i2 ? i2 : function(t3, e3) {
                return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
              }(e2.properties, i2);
            }
            createBucket(t2) {
              return new hd(t2);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            _setPaintOverrides() {
              for (const t2 of fd.paint.overridableProperties) {
                if (!yd.hasPaintOverride(this.layout, t2))
                  continue;
                const e2 = this.paint.get(t2), r2 = new dd(e2), n2 = new qn(r2, e2.property.specification);
                let i2 = null;
                i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new Zn("source", n2) : new Xn("composite", n2, e2.value.zoomStops, e2.value._interpolationType), this.paint._values[t2] = new Xs(e2.property, i2, e2.parameters);
              }
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && yd.hasPaintOverride(this.layout, t2);
            }
            static hasPaintOverride(t2, e2) {
              const r2 = t2.get("text-field"), n2 = fd.paint.properties[e2];
              let i2 = false;
              const s2 = (t3) => {
                for (const e3 of t3)
                  if (n2.overrides && n2.overrides.hasOverride(e3))
                    return void (i2 = true);
              };
              if ("constant" === r2.value.kind && r2.value.value instanceof Be)
                s2(r2.value.value.sections);
              else if ("source" === r2.value.kind) {
                const t3 = (e4) => {
                  i2 || (e4 instanceof Fe && De(e4.value) === pe ? s2(e4.value.sections) : e4 instanceof Oe ? s2(e4.sections) : e4.eachChild(t3));
                }, e3 = r2.value;
                e3._styleExpression && t3(e3._styleExpression.expression);
              }
              return i2;
            }
            getProgramConfiguration(t2) {
              return new po(this, t2);
            }
          }
          var md = { paint: new Js({ "background-color": new Ys(Ht.paint_background["background-color"]), "background-pattern": new Ys(Ht.paint_background["background-pattern"]), "background-opacity": new Ys(Ht.paint_background["background-opacity"]) }) }, gd = { paint: new Js({ "raster-opacity": new Ys(Ht.paint_raster["raster-opacity"]), "raster-hue-rotate": new Ys(Ht.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ys(Ht.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ys(Ht.paint_raster["raster-brightness-max"]), "raster-saturation": new Ys(Ht.paint_raster["raster-saturation"]), "raster-contrast": new Ys(Ht.paint_raster["raster-contrast"]), "raster-resampling": new Ys(Ht.paint_raster["raster-resampling"]), "raster-fade-duration": new Ys(Ht.paint_raster["raster-fade-duration"]) }) };
          class xd extends wo {
            constructor(t2) {
              super(t2, {}), this.implementation = t2;
            }
            is3D() {
              return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
              return void 0 !== this.implementation.prerender;
            }
            isLayerDraped() {
              return void 0 !== this.implementation.renderToTile;
            }
            shouldRedrape() {
              return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
              return false;
            }
            serialize() {
            }
            onAdd(t2) {
              this.implementation.onAdd && this.implementation.onAdd(t2, t2.painter.context.gl);
            }
            onRemove(t2) {
              this.implementation.onRemove && this.implementation.onRemove(t2, t2.painter.context.gl);
            }
          }
          var vd = { paint: new Js({ "sky-type": new Ys(Ht.paint_sky["sky-type"]), "sky-atmosphere-sun": new Ys(Ht.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Ys(Ht.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Ys(Ht.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Ys(Ht.paint_sky["sky-gradient-radius"]), "sky-gradient": new Ws(Ht.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Ys(Ht.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Ys(Ht.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Ys(Ht.paint_sky["sky-opacity"]) }) };
          function bd(t2, e2, r2) {
            const n2 = [0, 0, 1], i2 = hl([]);
            return fl(i2, i2, r2 ? -x(t2) + Math.PI : x(t2)), pl(i2, i2, -x(e2)), rl(n2, n2, i2), Jo(n2, n2);
          }
          const wd = { circle: class extends wo {
            constructor(t2) {
              super(t2, Ou);
            }
            createBucket(t2) {
              return new Su(t2);
            }
            queryRadius(t2) {
              const e2 = t2;
              return Fu("circle-radius", this, e2) + Fu("circle-stroke-width", this, e2) + Ru(this.paint.get("circle-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = $u(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2);
              return qu(t2, n2, s2, a2, o2, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l2, u2);
            }
            getProgramIds() {
              return ["circle"];
            }
            getProgramConfiguration(t2) {
              return new po(this, t2);
            }
          }, heatmap: class extends wo {
            createBucket(t2) {
              return new Ku(t2);
            }
            constructor(t2) {
              super(t2, tc), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "heatmap-color" === t2 && this._updateColorRamp();
            }
            _updateColorRamp() {
              this.colorRamp = ec({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }
            resize() {
              this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
            }
            queryRadius(t2) {
              return Fu("heatmap-radius", this, t2);
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = this.paint.get("heatmap-radius").evaluate(e2, r2);
              return qu(t2, n2, s2, a2, o2, true, true, new d(0, 0), l2);
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
            }
            getProgramIds() {
              return ["heatmap", "heatmapTexture"];
            }
            getProgramConfiguration(t2) {
              return new po(this, t2);
            }
          }, hillshade: class extends wo {
            constructor(t2) {
              super(t2, rc);
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
            }
            getProgramIds() {
              return ["hillshade", "hillshadePrepare"];
            }
          }, fill: class extends wo {
            constructor(t2) {
              super(t2, Oc);
            }
            getProgramIds() {
              const t2 = this.paint.get("fill-pattern"), e2 = t2 && t2.constantOr(1), r2 = [e2 ? "fillPattern" : "fill"];
              return this.paint.get("fill-antialias") && r2.push(e2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r2;
            }
            getProgramConfiguration(t2) {
              return new po(this, t2);
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2);
              const r2 = this.paint._values["fill-outline-color"];
              "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }
            createBucket(t2) {
              return new $c(t2);
            }
            queryRadius() {
              return Ru(this.paint.get("fill-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
              return !t2.queryGeometry.isAboveHorizon && Mu(ju(t2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), n2);
            }
            isTileClipped() {
              return true;
            }
          }, "fill-extrusion": class extends wo {
            constructor(t2) {
              super(t2, Ah);
            }
            createBucket(t2) {
              return new fh(t2);
            }
            queryRadius() {
              return Ru(this.paint.get("fill-extrusion-translate"));
            }
            is3D() {
              return true;
            }
            getProgramIds() {
              return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
            }
            getProgramConfiguration(t2) {
              return new po(this, t2);
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
              const u2 = $u(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p2 = [0, 0], f2 = o2 && s2.elevation, y2 = s2.elevation ? s2.elevation.exaggeration() : 1, m2 = t2.tile.getBucket(this);
              if (f2 && m2 instanceof fh) {
                const t3 = m2.centroidVertexArray, e3 = l2 + 1;
                e3 < t3.length && (p2[0] = t3.geta_centroid_pos0(e3), p2[1] = t3.geta_centroid_pos1(e3));
              }
              if (0 === p2[0] && 1 === p2[1])
                return false;
              "globe" === s2.projection.name && (n2 = wh([n2], [new d(0, 0), new d(ko, ko)], t2.tileID.canonical).map((t3) => t3.polygon).flat());
              const g2 = f2 ? o2 : null, [x2, v2] = function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3) {
                return "globe" === t3.projection.name ? function(t4, e4, r4, n4, i4, s4, a4, o4, l4, u4, c4) {
                  const h3 = [], p3 = [], f3 = t4.projection.upVectorScale(c4, t4.center.lat, t4.worldSize).metersToTile, d2 = [0, 0, 0, 1], y3 = [0, 0, 0, 1], m3 = (t5, e5, r5, n5) => {
                    t5[0] = e5, t5[1] = r5, t5[2] = n5, t5[3] = 1;
                  }, g3 = bh();
                  r4 > 0 && (r4 += g3), n4 += g3;
                  for (const g4 of e4) {
                    const e5 = [], x3 = [];
                    for (const h4 of g4) {
                      const p4 = h4.x + i4.x, g5 = h4.y + i4.y, v3 = t4.projection.projectTilePoint(p4, g5, c4), b3 = t4.projection.upVector(c4, h4.x, h4.y);
                      let w2 = r4, _2 = n4;
                      if (a4) {
                        const t5 = Ch(p4, g5, r4, n4, a4, o4, l4, u4);
                        w2 += t5.base, _2 += t5.top;
                      }
                      0 !== r4 ? m3(d2, v3.x + b3[0] * f3 * w2, v3.y + b3[1] * f3 * w2, v3.z + b3[2] * f3 * w2) : m3(d2, v3.x, v3.y, v3.z), m3(y3, v3.x + b3[0] * f3 * _2, v3.y + b3[1] * f3 * _2, v3.z + b3[2] * f3 * _2), el(d2, d2, s4), el(y3, y3, s4), e5.push(new zh(d2[0], d2[1], d2[2])), x3.push(new zh(y3[0], y3[1], y3[2]));
                    }
                    h3.push(e5), p3.push(x3);
                  }
                  return [h3, p3];
                }(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3) : a3 ? function(t4, e4, r4, n4, i4, s4, a4, o4, l4) {
                  const u4 = [], c4 = [], h3 = [0, 0, 0, 1];
                  for (const p3 of t4) {
                    const t5 = [], f3 = [];
                    for (const u5 of p3) {
                      const c5 = u5.x + n4.x, p4 = u5.y + n4.y, d2 = Ch(c5, p4, e4, r4, s4, a4, o4, l4);
                      h3[0] = c5, h3[1] = p4, h3[2] = d2.base, h3[3] = 1, ul(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                      const y3 = new zh(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                      h3[0] = c5, h3[1] = p4, h3[2] = d2.top, h3[3] = 1, ul(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                      const m3 = new zh(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                      t5.push(y3), f3.push(m3);
                    }
                    u4.push(t5), c4.push(f3);
                  }
                  return [u4, c4];
                }(e3, r3, n3, i3, s3, a3, o3, l3, u3) : function(t4, e4, r4, n4, i4) {
                  const s4 = [], a4 = [], o4 = i4[8] * e4, l4 = i4[9] * e4, u4 = i4[10] * e4, c4 = i4[11] * e4, h3 = i4[8] * r4, p3 = i4[9] * r4, f3 = i4[10] * r4, d2 = i4[11] * r4;
                  for (const e5 of t4) {
                    const t5 = [], r5 = [];
                    for (const s5 of e5) {
                      const e6 = s5.x + n4.x, a5 = s5.y + n4.y, y3 = i4[0] * e6 + i4[4] * a5 + i4[12], m3 = i4[1] * e6 + i4[5] * a5 + i4[13], g3 = i4[2] * e6 + i4[6] * a5 + i4[14], x3 = i4[3] * e6 + i4[7] * a5 + i4[15], v3 = y3 + o4, b3 = m3 + l4, w2 = g3 + u4, _2 = Math.max(x3 + c4, 1e-5), A2 = y3 + h3, S2 = m3 + p3, k2 = g3 + f3, I2 = Math.max(x3 + d2, 1e-5);
                      t5.push(new zh(v3 / _2, b3 / _2, w2 / _2)), r5.push(new zh(A2 / I2, S2 / I2, k2 / I2));
                    }
                    s4.push(t5), a4.push(r5);
                  }
                  return [s4, a4];
                }(e3, r3, n3, i3, s3);
              }(s2, n2, h2, c2, u2, a2, g2, p2, y2, s2.center.lat, t2.tileID.canonical), b2 = t2.queryGeometry;
              return function(t3, e3, r3) {
                let n3 = 1 / 0;
                Mu(r3, e3) && (n3 = Eh(r3, e3[0]));
                for (let i3 = 0; i3 < e3.length; i3++) {
                  const s3 = e3[i3], a3 = t3[i3];
                  for (let t4 = 0; t4 < s3.length - 1; t4++) {
                    const e4 = s3[t4], i4 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                    ku(r3, i4) && (n3 = Math.min(n3, Eh(r3, i4)));
                  }
                }
                return n3 !== 1 / 0 && n3;
              }(x2, v2, b2.isPointQuery() ? b2.screenBounds : b2.screenGeometry);
            }
          }, line: class extends wo {
            constructor(t2) {
              super(t2, Uh), this.gradientVersion = 0;
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              if ("line-gradient" === t2) {
                const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
                this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof Ir, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
              }
            }
            gradientExpression() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }
            widthExpression() {
              return this._transitionablePaint._values["line-width"].value.expression;
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = Oh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
            }
            createBucket(t2) {
              return new jh(t2);
            }
            getProgramIds() {
              return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
            }
            getProgramConfiguration(t2) {
              return new po(this, t2);
            }
            queryRadius(t2) {
              const e2 = t2, r2 = qh(Fu("line-width", this, e2), Fu("line-gap-width", this, e2)), n2 = Fu("line-offset", this, e2);
              return r2 / 2 + Math.abs(n2) + Ru(this.paint.get("line-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
              if (t2.queryGeometry.isAboveHorizon)
                return false;
              const a2 = ju(t2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), o2 = t2.pixelToTileUnitsFactor / 2 * qh(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), l2 = this.paint.get("line-offset").evaluate(e2, r2);
              return l2 && (n2 = function(t3, e3) {
                const r3 = [], n3 = new d(0, 0);
                for (let i3 = 0; i3 < t3.length; i3++) {
                  const s3 = t3[i3], a3 = [];
                  for (let t4 = 0; t4 < s3.length; t4++) {
                    const r4 = s3[t4 - 1], i4 = s3[t4], o3 = s3[t4 + 1], l3 = 0 === t4 ? n3 : i4.sub(r4)._unit()._perp(), u2 = t4 === s3.length - 1 ? n3 : o3.sub(i4)._unit()._perp(), c2 = l3._add(u2)._unit();
                    c2._mult(1 / (c2.x * u2.x + c2.y * u2.y)), a3.push(c2._mult(e3)._add(i4));
                  }
                  r3.push(a3);
                }
                return r3;
              }(n2, l2 * t2.pixelToTileUnitsFactor)), function(t3, e3, r3) {
                for (let n3 = 0; n3 < e3.length; n3++) {
                  const i3 = e3[n3];
                  if (t3.length >= 3) {
                    for (let e4 = 0; e4 < i3.length; e4++)
                      if (Du(t3, i3[e4]))
                        return true;
                  }
                  if (Tu(t3, i3, r3))
                    return true;
                }
                return false;
              }(a2, n2, o2);
            }
            isTileClipped() {
              return true;
            }
          }, symbol: yd, background: class extends wo {
            constructor(t2) {
              super(t2, md);
            }
            getProgramIds() {
              return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
            }
          }, raster: class extends wo {
            constructor(t2) {
              super(t2, gd);
            }
            getProgramIds() {
              return ["raster"];
            }
          }, sky: class extends wo {
            constructor(t2) {
              super(t2, vd), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "sky-gradient" === t2 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t2 && "sky-atmosphere-halo-color" !== t2 && "sky-atmosphere-color" !== t2 && "sky-atmosphere-sun-intensity" !== t2 || (this._skyboxInvalidated = true);
            }
            _updateColorRamp() {
              this.colorRamp = ec({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
            }
            needsSkyboxCapture(t2) {
              if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
                return true;
              if (!this.paint.get("sky-atmosphere-sun")) {
                const e2 = t2.style.light.properties.get("position");
                return this._lightPosition.azimuthal !== e2.azimuthal || this._lightPosition.polar !== e2.polar;
              }
              return false;
            }
            getCenter(t2, e2) {
              if ("atmosphere" === this.paint.get("sky-type")) {
                const r3 = this.paint.get("sky-atmosphere-sun"), n2 = !r3, i2 = t2.style.light, s2 = i2.properties.get("position");
                return n2 && "viewport" === i2.properties.get("anchor") && U("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n2 ? bd(s2.azimuthal, 90 - s2.polar, e2) : bd(r3[0], 90 - r3[1], e2);
              }
              const r2 = this.paint.get("sky-gradient-center");
              return bd(r2[0], 90 - r2[1], e2);
            }
            is3D() {
              return false;
            }
            isSky() {
              return true;
            }
            markSkyboxValid(t2) {
              this._skyboxInvalidated = false, this._lightPosition = t2.style.light.properties.get("position");
            }
            hasOffscreenPass() {
              return true;
            }
            getProgramIds() {
              const t2 = this.paint.get("sky-type");
              return "atmosphere" === t2 ? ["skyboxCapture", "skybox"] : "gradient" === t2 ? ["skyboxGradient"] : null;
            }
          } };
          class _d {
            constructor(t2, e2, r2, n2) {
              this.context = t2, this.format = r2, this.texture = t2.gl.createTexture(), this.update(e2, n2);
            }
            update(t2, r2, n2) {
              const { width: i2, height: s2 } = t2, { context: a2 } = this, { gl: o2 } = a2, { HTMLImageElement: l2, HTMLCanvasElement: u2, HTMLVideoElement: c2, ImageData: h2, ImageBitmap: p2 } = e;
              if (o2.bindTexture(o2.TEXTURE_2D, this.texture), a2.pixelStoreUnpackFlipY.set(false), a2.pixelStoreUnpack.set(1), a2.pixelStoreUnpackPremultiplyAlpha.set(this.format === o2.RGBA && (!r2 || false !== r2.premultiply)), n2 || this.size && this.size[0] === i2 && this.size[1] === s2) {
                const { x: e2, y: r3 } = n2 || { x: 0, y: 0 };
                t2 instanceof l2 || t2 instanceof u2 || t2 instanceof c2 || t2 instanceof h2 || p2 && t2 instanceof p2 ? o2.texSubImage2D(o2.TEXTURE_2D, 0, e2, r3, o2.RGBA, o2.UNSIGNED_BYTE, t2) : o2.texSubImage2D(o2.TEXTURE_2D, 0, e2, r3, i2, s2, o2.RGBA, o2.UNSIGNED_BYTE, t2.data);
              } else
                this.size = [i2, s2], t2 instanceof l2 || t2 instanceof u2 || t2 instanceof c2 || t2 instanceof h2 || p2 && t2 instanceof p2 ? o2.texImage2D(o2.TEXTURE_2D, 0, this.format, this.format, o2.UNSIGNED_BYTE, t2) : o2.texImage2D(o2.TEXTURE_2D, 0, this.format, i2, s2, 0, this.format, o2.UNSIGNED_BYTE, t2.data);
              this.useMipmap = Boolean(r2 && r2.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o2.generateMipmap(o2.TEXTURE_2D);
            }
            bind(t2, e2) {
              const { context: r2 } = this, { gl: n2 } = r2;
              n2.bindTexture(n2.TEXTURE_2D, this.texture), t2 !== this.filter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, this.useMipmap ? t2 === n2.NEAREST ? n2.NEAREST_MIPMAP_NEAREST : n2.LINEAR_MIPMAP_NEAREST : t2), this.filter = t2), e2 !== this.wrap && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e2), this.wrap = e2);
            }
            isSizePowerOfTwo() {
              return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
              const { gl: t2 } = this.context;
              t2.deleteTexture(this.texture), this.texture = null;
            }
          }
          class Ad {
            constructor(t2) {
              this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                this._triggered = false, this._callback();
              });
            }
            trigger() {
              this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
                this._triggered = false, this._callback();
              }, 0));
            }
            remove() {
              this._channel = void 0, this._callback = () => {
              };
            }
          }
          class Sd {
            constructor() {
              this.tasks = {}, this.taskQueue = [], V(["process"], this), this.invoker = new Ad(this.process), this.nextId = 0;
            }
            add(t2, e2) {
              const r2 = this.nextId++, n2 = function({ type: t3, isSymbolTile: e3, zoom: r3 }) {
                return r3 = r3 || 0, "message" === t3 ? 0 : "maybePrepare" !== t3 || e3 ? "parseTile" !== t3 || e3 ? "parseTile" === t3 && e3 ? 300 - r3 : "maybePrepare" === t3 && e3 ? 400 - r3 : 500 : 200 - r3 : 100 - r3;
              }(e2);
              if (0 === n2) {
                N();
                try {
                  t2();
                } finally {
                }
                return { cancel: () => {
                } };
              }
              return this.tasks[r2] = { fn: t2, metadata: e2, priority: n2, id: r2 }, this.taskQueue.push(r2), this.invoker.trigger(), { cancel: () => {
                delete this.tasks[r2];
              } };
            }
            process() {
              N();
              try {
                if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length)
                  return;
                const t2 = this.pick();
                if (null === t2)
                  return;
                const e2 = this.tasks[t2];
                if (delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), !e2)
                  return;
                e2.fn();
              } finally {
              }
            }
            pick() {
              let t2 = null, e2 = 1 / 0;
              for (let r3 = 0; r3 < this.taskQueue.length; r3++) {
                const n2 = this.tasks[this.taskQueue[r3]];
                n2.priority < e2 && (e2 = n2.priority, t2 = r3);
              }
              if (null === t2)
                return null;
              const r2 = this.taskQueue[t2];
              return this.taskQueue.splice(t2, 1), r2;
            }
            remove() {
              this.invoker.remove();
            }
          }
          class kd {
            constructor(t2) {
              this._stringToNumber = {}, this._numberToString = [];
              for (let e2 = 0; e2 < t2.length; e2++) {
                const r2 = t2[e2];
                this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
              }
            }
            encode(t2) {
              return this._stringToNumber[t2];
            }
            decode(t2) {
              return this._numberToString[t2];
            }
          }
          const Id = ["tile", "layer", "source", "sourceLayer", "state"];
          class Md {
            constructor(t2, e2, r2, n2, i2) {
              this.type = "Feature", this._vectorTileFeature = t2, this._z = e2, this._x = r2, this._y = n2, this.properties = t2.properties, this.id = i2;
            }
            get geometry() {
              return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }
            set geometry(t2) {
              this._geometry = t2;
            }
            toJSON() {
              const t2 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
              void 0 !== this.id && (t2.id = this.id);
              for (const e2 of Id)
                void 0 !== this[e2] && (t2[e2] = this[e2]);
              return t2;
            }
          }
          const Td = 32, zd = 33, Bd = new Uint16Array(8184);
          for (let t2 = 0; t2 < 2046; t2++) {
            let e2 = t2 + 2, r2 = 0, n2 = 0, i2 = 0, s2 = 0, a2 = 0, o2 = 0;
            for (1 & e2 ? i2 = s2 = a2 = Td : r2 = n2 = o2 = Td; (e2 >>= 1) > 1; ) {
              const t3 = r2 + i2 >> 1, l3 = n2 + s2 >> 1;
              1 & e2 ? (i2 = r2, s2 = n2, r2 = a2, n2 = o2) : (r2 = i2, n2 = s2, i2 = a2, s2 = o2), a2 = t3, o2 = l3;
            }
            const l2 = 4 * t2;
            Bd[l2 + 0] = r2, Bd[l2 + 1] = n2, Bd[l2 + 2] = i2, Bd[l2 + 3] = s2;
          }
          const Ed = new Uint16Array(2178), Cd = new Uint8Array(1089), Pd = new Uint16Array(1089);
          function Dd(t2) {
            return 0 === t2 ? -0.03125 : 32 === t2 ? 0.03125 : 0;
          }
          var Vd = na([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
          const Ld = { type: 2, extent: ko, loadGeometry: () => [[new d(0, 0), new d(8193, 0), new d(8193, 8193), new d(0, 8193), new d(0, 0)]] };
          class Fd {
            constructor(t2, e2, r2, n2, i2) {
              this.tileID = t2, this.uid = E(), this.uses = 0, this.tileSize = e2, this.tileZoom = r2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = i2, this.expiredRequestCount = 0, this.state = "loading", n2 && n2.transform && (this.projection = n2.transform.projection);
            }
            registerFadeDuration(t2) {
              const e2 = t2 + this.timeAdded;
              e2 < Nt.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
            }
            wasRequested() {
              return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            get tileTransform() {
              return this._tileTransform || (this._tileTransform = Vf(this.tileID.canonical, this.projection)), this._tileTransform;
            }
            loadVectorData(t2, e2, r2) {
              if (this.unloadVectorData(), this.state = "loaded", t2) {
                t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e3) {
                  const r3 = {};
                  if (!e3)
                    return r3;
                  for (const n2 of t3) {
                    const t4 = n2.layerIds.map((t5) => e3.getLayer(t5)).filter(Boolean);
                    if (0 !== t4.length) {
                      n2.layers = t4, n2.stateDependentLayerIds && (n2.stateDependentLayers = n2.stateDependentLayerIds.map((e4) => t4.filter((t5) => t5.id === e4)[0]));
                      for (const e4 of t4)
                        r3[e4.id] = n2;
                    }
                  }
                  return r3;
                }(t2.buckets, e2.style), this.hasSymbolBuckets = false;
                for (const t3 in this.buckets) {
                  const e3 = this.buckets[t3];
                  if (e3 instanceof hd) {
                    if (this.hasSymbolBuckets = true, !r2)
                      break;
                    e3.justReloaded = true;
                  }
                }
                if (this.hasRTLText = false, this.hasSymbolBuckets)
                  for (const t3 in this.buckets) {
                    const e3 = this.buckets[t3];
                    if (e3 instanceof hd && e3.hasRTLText) {
                      this.hasRTLText = true, js.isLoading() || js.isLoaded() || "deferred" !== Fs() || Rs();
                      break;
                    }
                  }
                this.queryPadding = 0;
                for (const t3 in this.buckets) {
                  const r3 = this.buckets[t3];
                  this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(t3).queryRadius(r3));
                }
                t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage), t2.lineAtlas && (this.lineAtlas = t2.lineAtlas);
              } else
                this.collisionBoxArray = new Ea();
            }
            unloadVectorData() {
              if (this.hasData()) {
                for (const t2 in this.buckets)
                  this.buckets[t2].destroy();
                this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
              }
            }
            getBucket(t2) {
              return this.buckets[t2.id];
            }
            upload(t2) {
              for (const e3 in this.buckets) {
                const r2 = this.buckets[e3];
                r2.uploadPending() && r2.upload(t2);
              }
              const e2 = t2.gl;
              this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new _d(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new _d(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new _d(t2, this.lineAtlas.image, e2.ALPHA), this.lineAtlas.uploaded = true);
            }
            prepare(t2) {
              this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
              return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n2, pixelPosMatrix: a2, transform: s2, params: i2, tileTransform: this.tileTransform }, t2, e2, r2) : {};
            }
            querySourceFeatures(t2, e2) {
              const r2 = this.latestFeatureIndex;
              if (!r2 || !r2.rawTileData)
                return;
              const n2 = r2.loadVTLayers(), i2 = e2 ? e2.sourceLayer : "", s2 = n2._geojsonTileLayer || n2[i2];
              if (!s2)
                return;
              const a2 = ai(e2 && e2.filter), { z: o2, x: l2, y: u2 } = this.tileID.canonical, c2 = { z: o2, x: l2, y: u2 };
              for (let e3 = 0; e3 < s2.length; e3++) {
                const n3 = s2.feature(e3);
                if (a2.needGeometry) {
                  const t3 = wu(n3, true);
                  if (!a2.filter(new $s(this.tileID.overscaledZ), t3, this.tileID.canonical))
                    continue;
                } else if (!a2.filter(new $s(this.tileID.overscaledZ), n3))
                  continue;
                const h2 = r2.getId(n3, i2), p2 = new Md(n3, o2, l2, u2, h2);
                p2.tile = c2, t2.push(p2);
              }
            }
            hasData() {
              return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
              return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(t2) {
              const e2 = this.expirationTime;
              if (t2.cacheControl) {
                const e3 = G(t2.cacheControl);
                e3["max-age"] && (this.expirationTime = Date.now() + 1e3 * e3["max-age"]);
              } else
                t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
              if (this.expirationTime) {
                const t3 = Date.now();
                let r2 = false;
                if (this.expirationTime > t3)
                  r2 = false;
                else if (e2)
                  if (this.expirationTime < e2)
                    r2 = true;
                  else {
                    const n2 = this.expirationTime - e2;
                    n2 ? this.expirationTime = t3 + Math.max(n2, 3e4) : r2 = true;
                  }
                else
                  r2 = true;
                r2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
              }
            }
            getExpiryTimeout() {
              if (this.expirationTime)
                return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t2, e2) {
              if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t2).length || !e2)
                return;
              const r2 = this.latestFeatureIndex.loadVTLayers(), n2 = e2.style.listImages();
              for (const i2 in this.buckets) {
                if (!e2.style.hasLayer(i2))
                  continue;
                const s2 = this.buckets[i2], a2 = s2.layers[0].sourceLayer || "_geojsonTileLayer", o2 = r2[a2], l2 = t2[a2];
                if (!o2 || !l2 || 0 === Object.keys(l2).length)
                  continue;
                if (s2.update(l2, o2, n2, this.imageAtlas && this.imageAtlas.patternPositions || {}), s2 instanceof jh || s2 instanceof $c) {
                  const t3 = e2.style._getSourceCache(s2.layers[0].source);
                  e2._terrain && e2._terrain.enabled && t3 && s2.programConfigurations.needsUpload && e2._terrain._clearRenderCacheForTile(t3.id, this.tileID);
                }
                const u2 = e2 && e2.style && e2.style.getLayer(i2);
                u2 && (this.queryPadding = Math.max(this.queryPadding, u2.queryRadius(s2)));
              }
            }
            holdingForFade() {
              return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
              return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Nt.now();
            }
            clearFadeHold() {
              this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t2) {
              this.symbolFadeHoldUntil = Nt.now() + t2;
            }
            setTexture(t2, e2) {
              const r2 = e2.context, n2 = r2.gl;
              this.texture = this.texture || e2.getTileTexture(t2.width), this.texture ? this.texture.update(t2, { useMipmap: true }) : (this.texture = new _d(r2, t2, n2.RGBA, { useMipmap: true }), this.texture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE));
            }
            setDependencies(t2, e2) {
              const r2 = {};
              for (const t3 of e2)
                r2[t3] = true;
              this.dependencies[t2] = r2;
            }
            hasDependency(t2, e2) {
              for (const r2 of t2) {
                const t3 = this.dependencies[r2];
                if (t3) {
                  for (const r3 of e2)
                    if (t3[r3])
                      return true;
                }
              }
              return false;
            }
            clearQueryDebugViz() {
            }
            _makeDebugTileBoundsBuffers(t2, e2) {
              if (!e2 || "mercator" === e2.name || this._tileDebugBuffer)
                return;
              const r2 = bu(Ld, this.tileID.canonical, this.tileTransform)[0], n2 = new sa(), i2 = new Ta();
              for (let t3 = 0; t3 < r2.length; t3++) {
                const { x: e3, y: s2 } = r2[t3];
                n2.emplaceBack(e3, s2), i2.emplaceBack(t3);
              }
              i2.emplaceBack(0), this._tileDebugIndexBuffer = t2.createIndexBuffer(i2), this._tileDebugBuffer = t2.createVertexBuffer(n2, xl.members), this._tileDebugSegments = So.simpleSegment(0, 0, n2.length, i2.length);
            }
            _makeTileBoundsBuffers(t2, e2) {
              if (this._tileBoundsBuffer || !e2 || "mercator" === e2.name)
                return;
              const r2 = bu(Ld, this.tileID.canonical, this.tileTransform)[0];
              let n2, i2;
              if (this.isRaster) {
                const t3 = function(t4, e3) {
                  const r3 = Vf(t4, e3), n3 = Math.pow(2, t4.z);
                  for (let i4 = 0; i4 < zd; i4++)
                    for (let s3 = 0; s3 < zd; s3++) {
                      const a3 = ou((t4.x + (s3 + Dd(s3)) / Td) / n3), o3 = lu((t4.y + (i4 + Dd(i4)) / Td) / n3), l3 = e3.project(a3, o3), u2 = i4 * zd + s3;
                      Ed[2 * u2 + 0] = Math.round((l3.x * r3.scale - r3.x) * ko), Ed[2 * u2 + 1] = Math.round((l3.y * r3.scale - r3.y) * ko);
                    }
                  Cd.fill(0), Pd.fill(0);
                  for (let t5 = 2045; t5 >= 0; t5--) {
                    const e4 = 4 * t5, r4 = Bd[e4 + 0], n4 = Bd[e4 + 1], i4 = Bd[e4 + 2], s3 = Bd[e4 + 3], a3 = r4 + i4 >> 1, o3 = n4 + s3 >> 1, l3 = a3 + o3 - n4, u2 = o3 + r4 - a3, c2 = n4 * zd + r4, h2 = s3 * zd + i4, p2 = o3 * zd + a3, f2 = Math.hypot((Ed[2 * c2 + 0] + Ed[2 * h2 + 0]) / 2 - Ed[2 * p2 + 0], (Ed[2 * c2 + 1] + Ed[2 * h2 + 1]) / 2 - Ed[2 * p2 + 1]) >= 16;
                    if (Cd[p2] = Cd[p2] || (f2 ? 1 : 0), t5 < 1022) {
                      const t6 = (n4 + u2 >> 1) * zd + (r4 + l3 >> 1), e5 = (s3 + u2 >> 1) * zd + (i4 + l3 >> 1);
                      Cd[p2] = Cd[p2] || Cd[t6] || Cd[e5];
                    }
                  }
                  const i3 = new oa(), s2 = new wa();
                  let a2 = 0;
                  function o2(t5, e4) {
                    const r4 = e4 * zd + t5;
                    return 0 === Pd[r4] && (i3.emplaceBack(Ed[2 * r4 + 0], Ed[2 * r4 + 1], t5 * ko / Td, e4 * ko / Td), Pd[r4] = ++a2), Pd[r4] - 1;
                  }
                  function l2(t5, e4, r4, n4, i4, a3) {
                    const u2 = t5 + r4 >> 1, c2 = e4 + n4 >> 1;
                    if (Math.abs(t5 - i4) + Math.abs(e4 - a3) > 1 && Cd[c2 * zd + u2])
                      l2(i4, a3, t5, e4, u2, c2), l2(r4, n4, i4, a3, u2, c2);
                    else {
                      const l3 = o2(t5, e4), u3 = o2(r4, n4), c3 = o2(i4, a3);
                      s2.emplaceBack(l3, u3, c3);
                    }
                  }
                  return l2(0, 0, Td, Td, Td, 0), l2(Td, Td, 0, 0, 0, Td), { vertices: i3, indices: s2 };
                }(this.tileID.canonical, e2);
                n2 = t3.vertices, i2 = t3.indices;
              } else {
                n2 = new oa(), i2 = new wa();
                for (const { x: t4, y: e3 } of r2)
                  n2.emplaceBack(t4, e3, 0, 0);
                const t3 = sc(n2.int16, void 0, 4);
                for (let e3 = 0; e3 < t3.length; e3 += 3)
                  i2.emplaceBack(t3[e3], t3[e3 + 1], t3[e3 + 2]);
              }
              this._tileBoundsBuffer = t2.createVertexBuffer(n2, Vd.members), this._tileBoundsIndexBuffer = t2.createIndexBuffer(i2), this._tileBoundsSegments = So.simpleSegment(0, 0, n2.length, i2.length);
            }
            _makeGlobeTileDebugBuffers(t2, e2) {
              const r2 = e2.projection;
              if (!r2 || "globe" !== r2.name || e2.freezeTileCoverage)
                return;
              const n2 = this.tileID.canonical, i2 = Gl(Vl(n2, e2)), s2 = Kl(e2.zoom);
              let a2;
              s2 > 0 && (a2 = Co(new Float64Array(16), e2.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t2, n2, e2, i2, a2, s2), this._makeGlobeTileDebugTextBuffer(t2, n2, e2, i2, a2, s2);
            }
            _globePoint(t2, e2, r2, n2, i2, s2, a2) {
              let o2 = Ol(t2, e2, r2);
              if (s2) {
                const i3 = 1 << r2.z, l2 = iu(n2.center.lng), u2 = su(n2.center.lat), c2 = (r2.x + 0.5) / i3 - l2;
                let h2 = 0;
                c2 > 0.5 ? h2 = -1 : c2 < -0.5 && (h2 = 1);
                let p2 = (t2 / ko + r2.x) / i3 + h2, f2 = (e2 / ko + r2.y) / i3;
                p2 = (p2 - l2) * n2._pixelsPerMercatorPixel + l2, f2 = (f2 - u2) * n2._pixelsPerMercatorPixel + u2;
                const d2 = [p2 * n2.worldSize, f2 * n2.worldSize, 0];
                el(d2, d2, s2), o2 = Dl(o2, d2, a2);
              }
              return el(o2, o2, i2);
            }
            _makeGlobeTileDebugBorderBuffer(t2, e2, r2, n2, i2, s2) {
              const a2 = new sa(), o2 = new Ta(), l2 = new aa(), u2 = (t3, u3, c3, h2, p2) => {
                const f2 = (c3 - t3) / (p2 - 1), d2 = (h2 - u3) / (p2 - 1), y2 = a2.length;
                for (let c4 = 0; c4 < p2; c4++) {
                  const h3 = t3 + c4 * f2, p3 = u3 + c4 * d2;
                  a2.emplaceBack(h3, p3);
                  const m2 = this._globePoint(h3, p3, e2, r2, n2, i2, s2);
                  l2.emplaceBack(m2[0], m2[1], m2[2]), o2.emplaceBack(y2 + c4);
                }
              }, c2 = ko;
              u2(0, 0, c2, 0, 16), u2(c2, 0, c2, c2, 16), u2(c2, c2, 0, c2, 16), u2(0, c2, 0, 0, 16), this._tileDebugIndexBuffer = t2.createIndexBuffer(o2), this._tileDebugBuffer = t2.createVertexBuffer(a2, xl.members), this._globeTileDebugBorderBuffer = t2.createVertexBuffer(l2, gl.members), this._tileDebugSegments = So.simpleSegment(0, 0, a2.length, o2.length);
            }
            _makeGlobeTileDebugTextBuffer(t2, e2, r2, n2, i2, s2) {
              const a2 = new sa(), o2 = new wa(), l2 = new aa(), u2 = 25;
              o2.reserve(32), a2.reserve(u2), l2.reserve(u2);
              const c2 = (t3, e3) => u2 * t3 + e3;
              for (let t3 = 0; t3 < u2; t3++) {
                const o3 = 2048 * t3;
                for (let t4 = 0; t4 < u2; t4++) {
                  const u3 = 2048 * t4;
                  a2.emplaceBack(u3, o3);
                  const c3 = this._globePoint(u3, o3, e2, r2, n2, i2, s2);
                  l2.emplaceBack(c3[0], c3[1], c3[2]);
                }
              }
              for (let t3 = 0; t3 < 4; t3++)
                for (let e3 = 0; e3 < 4; e3++) {
                  const r3 = c2(t3, e3), n3 = c2(t3, e3 + 1), i3 = c2(t3 + 1, e3), s3 = c2(t3 + 1, e3 + 1);
                  o2.emplaceBack(r3, n3, i3), o2.emplaceBack(i3, n3, s3);
                }
              this._tileDebugTextIndexBuffer = t2.createIndexBuffer(o2), this._tileDebugTextBuffer = t2.createVertexBuffer(a2, xl.members), this._globeTileDebugTextBuffer = t2.createVertexBuffer(l2, gl.members), this._tileDebugTextSegments = So.simpleSegment(0, 0, u2, 32);
            }
          }
          class Rd {
            constructor() {
              this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(t2, e2, r2) {
              const n2 = String(e2);
              if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][n2] = this.stateChanges[t2][n2] || {}, z(this.stateChanges[t2][n2], r2), null === this.deletedStates[t2]) {
                this.deletedStates[t2] = {};
                for (const e3 in this.state[t2])
                  e3 !== n2 && (this.deletedStates[t2][e3] = null);
              } else if (this.deletedStates[t2] && null === this.deletedStates[t2][n2]) {
                this.deletedStates[t2][n2] = {};
                for (const e3 in this.state[t2][n2])
                  r2[e3] || (this.deletedStates[t2][n2][e3] = null);
              } else
                for (const e3 in r2)
                  this.deletedStates[t2] && this.deletedStates[t2][n2] && null === this.deletedStates[t2][n2][e3] && delete this.deletedStates[t2][n2][e3];
            }
            removeFeatureState(t2, e2, r2) {
              if (null === this.deletedStates[t2])
                return;
              const n2 = String(e2);
              if (this.deletedStates[t2] = this.deletedStates[t2] || {}, r2 && void 0 !== e2)
                null !== this.deletedStates[t2][n2] && (this.deletedStates[t2][n2] = this.deletedStates[t2][n2] || {}, this.deletedStates[t2][n2][r2] = null);
              else if (void 0 !== e2)
                if (this.stateChanges[t2] && this.stateChanges[t2][n2])
                  for (r2 in this.deletedStates[t2][n2] = {}, this.stateChanges[t2][n2])
                    this.deletedStates[t2][n2][r2] = null;
                else
                  this.deletedStates[t2][n2] = null;
              else
                this.deletedStates[t2] = null;
            }
            getState(t2, e2) {
              const r2 = String(e2), n2 = z({}, (this.state[t2] || {})[r2], (this.stateChanges[t2] || {})[r2]);
              if (null === this.deletedStates[t2])
                return {};
              if (this.deletedStates[t2]) {
                const r3 = this.deletedStates[t2][e2];
                if (null === r3)
                  return {};
                for (const t3 in r3)
                  delete n2[t3];
              }
              return n2;
            }
            initializeTileState(t2, e2) {
              t2.setFeatureState(this.state, e2);
            }
            coalesceChanges(t2, e2) {
              const r2 = {};
              for (const t3 in this.stateChanges) {
                this.state[t3] = this.state[t3] || {};
                const e3 = {};
                for (const r3 in this.stateChanges[t3])
                  this.state[t3][r3] || (this.state[t3][r3] = {}), z(this.state[t3][r3], this.stateChanges[t3][r3]), e3[r3] = this.state[t3][r3];
                r2[t3] = e3;
              }
              for (const t3 in this.deletedStates) {
                this.state[t3] = this.state[t3] || {};
                const e3 = {};
                if (null === this.deletedStates[t3])
                  for (const r3 in this.state[t3])
                    e3[r3] = {}, this.state[t3][r3] = {};
                else
                  for (const r3 in this.deletedStates[t3]) {
                    if (null === this.deletedStates[t3][r3])
                      this.state[t3][r3] = {};
                    else if (this.state[t3][r3])
                      for (const e4 of Object.keys(this.deletedStates[t3][r3]))
                        delete this.state[t3][r3][e4];
                    e3[r3] = this.state[t3][r3];
                  }
                r2[t3] = r2[t3] || {}, z(r2[t3], e3);
              }
              if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r2).length)
                for (const n2 in t2)
                  t2[n2].setFeatureState(r2, e2);
            }
          }
          class jd {
            constructor(t2) {
              this.size = t2, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t2, e2) {
              const r2 = this.toIdx(t2, e2);
              return { min: this.minimums[r2], max: this.maximums[r2] };
            }
            isLeaf(t2, e2) {
              return this.leaves[this.toIdx(t2, e2)];
            }
            toIdx(t2, e2) {
              return e2 * this.size + t2;
            }
          }
          function $d(t2, e2, r2, n2) {
            let i2 = 0, s2 = Number.MAX_VALUE;
            for (let a2 = 0; a2 < 3; a2++)
              if (Math.abs(n2[a2]) < 1e-15) {
                if (r2[a2] < t2[a2] || r2[a2] > e2[a2])
                  return null;
              } else {
                const o2 = 1 / n2[a2];
                let l2 = (t2[a2] - r2[a2]) * o2, u2 = (e2[a2] - r2[a2]) * o2;
                if (l2 > u2) {
                  const t3 = l2;
                  l2 = u2, u2 = t3;
                }
                if (l2 > i2 && (i2 = l2), u2 < s2 && (s2 = u2), i2 > s2)
                  return null;
              }
            return i2;
          }
          function Ud(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
            const h2 = n2 - t2, p2 = i2 - e2, f2 = s2 - r2, d2 = a2 - t2, y2 = o2 - e2, m2 = l2 - r2, g2 = c2[1] * m2 - c2[2] * y2, x2 = c2[2] * d2 - c2[0] * m2, v2 = c2[0] * y2 - c2[1] * d2, b2 = h2 * g2 + p2 * x2 + f2 * v2;
            if (Math.abs(b2) < 1e-15)
              return null;
            const w2 = 1 / b2, _2 = u2[0] - t2, A2 = u2[1] - e2, S2 = u2[2] - r2, k2 = (_2 * g2 + A2 * x2 + S2 * v2) * w2;
            if (k2 < 0 || k2 > 1)
              return null;
            const I2 = A2 * f2 - S2 * p2, M2 = S2 * h2 - _2 * f2, T2 = _2 * p2 - A2 * h2, z2 = (c2[0] * I2 + c2[1] * M2 + c2[2] * T2) * w2;
            return z2 < 0 || k2 + z2 > 1 ? null : (d2 * I2 + y2 * M2 + m2 * T2) * w2;
          }
          function Od(t2, e2, r2) {
            return (t2 - e2) / (r2 - e2);
          }
          function qd(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = 1 << r2, c2 = s2 - n2, h2 = a2 - i2, p2 = (t2 + 1) / u2 * c2 + n2, f2 = (e2 + 0) / u2 * h2 + i2, d2 = (e2 + 1) / u2 * h2 + i2;
            o2[0] = (t2 + 0) / u2 * c2 + n2, o2[1] = f2, l2[0] = p2, l2[1] = d2;
          }
          class Nd {
            constructor(t2) {
              if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
                return;
              const e2 = function(t3) {
                const e3 = Math.ceil(Math.log2(t3.dim / 8)), r3 = [];
                let n3 = Math.ceil(Math.pow(2, e3));
                const i2 = 1 / n3, s2 = (t4, e4, r4, n4, i3) => {
                  const s3 = n4 ? 1 : 0, a3 = (t4 + 1) * r4 - s3, o3 = e4 * r4, l2 = (e4 + 1) * r4 - s3;
                  i3[0] = t4 * r4, i3[1] = o3, i3[2] = a3, i3[3] = l2;
                };
                let a2 = new jd(n3);
                const o2 = [];
                for (let e4 = 0; e4 < n3 * n3; e4++) {
                  s2(e4 % n3, Math.floor(e4 / n3), i2, false, o2);
                  const r4 = Zd(o2[0], o2[1], t3), l2 = Zd(o2[2], o2[1], t3), u2 = Zd(o2[2], o2[3], t3), c2 = Zd(o2[0], o2[3], t3);
                  a2.minimums.push(Math.min(r4, l2, u2, c2)), a2.maximums.push(Math.max(r4, l2, u2, c2)), a2.leaves.push(1);
                }
                for (r3.push(a2), n3 /= 2; n3 >= 1; n3 /= 2) {
                  const t4 = r3[r3.length - 1];
                  a2 = new jd(n3);
                  for (let e4 = 0; e4 < n3 * n3; e4++) {
                    s2(e4 % n3, Math.floor(e4 / n3), 2, true, o2);
                    const r4 = t4.getElevation(o2[0], o2[1]), i3 = t4.getElevation(o2[2], o2[1]), l2 = t4.getElevation(o2[2], o2[3]), u2 = t4.getElevation(o2[0], o2[3]), c2 = t4.isLeaf(o2[0], o2[1]), h2 = t4.isLeaf(o2[2], o2[1]), p2 = t4.isLeaf(o2[2], o2[3]), f2 = t4.isLeaf(o2[0], o2[3]), d2 = Math.min(r4.min, i3.min, l2.min, u2.min), y2 = Math.max(r4.max, i3.max, l2.max, u2.max), m2 = c2 && h2 && p2 && f2;
                    a2.maximums.push(y2), a2.minimums.push(d2), a2.leaves.push(y2 - d2 <= 5 && m2 ? 1 : 0);
                  }
                  r3.push(a2);
                }
                return r3;
              }(this.dem), r2 = e2.length - 1, n2 = e2[r2];
              this._addNode(n2.minimums[0], n2.maximums[0], n2.leaves[0]), this._construct(e2, 0, 0, r2, 0);
            }
            raycastRoot(t2, e2, r2, n2, i2, s2, a2 = 1) {
              return $d([t2, e2, -100], [r2, n2, this.maximums[0] * a2], i2, s2);
            }
            raycast(t2, e2, r2, n2, i2, s2, a2 = 1) {
              if (!this.nodeCount)
                return null;
              const o2 = this.raycastRoot(t2, e2, r2, n2, i2, s2, a2);
              if (null == o2)
                return null;
              const l2 = [], u2 = [], c2 = [], h2 = [], p2 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
              for (; p2.length > 0; ) {
                const { idx: o3, t: f2, nodex: d2, nodey: y2, depth: m2 } = p2.pop();
                if (this.leaves[o3]) {
                  qd(d2, y2, m2, t2, e2, r2, n2, c2, h2);
                  const o4 = 1 << m2, l3 = (d2 + 0) / o4, u3 = (d2 + 1) / o4, p3 = (y2 + 0) / o4, g3 = (y2 + 1) / o4, x2 = Zd(l3, p3, this.dem) * a2, v2 = Zd(u3, p3, this.dem) * a2, b2 = Zd(u3, g3, this.dem) * a2, w2 = Zd(l3, g3, this.dem) * a2, _2 = Ud(c2[0], c2[1], x2, h2[0], c2[1], v2, h2[0], h2[1], b2, i2, s2), A2 = Ud(h2[0], h2[1], b2, c2[0], h2[1], w2, c2[0], c2[1], x2, i2, s2), S2 = Math.min(null !== _2 ? _2 : Number.MAX_VALUE, null !== A2 ? A2 : Number.MAX_VALUE);
                  if (S2 !== Number.MAX_VALUE)
                    return S2;
                  {
                    const t3 = Wo([], i2, s2, f2);
                    if (Gd(x2, v2, w2, b2, Od(t3[0], c2[0], h2[0]), Od(t3[1], c2[1], h2[1])) >= t3[2])
                      return f2;
                  }
                  continue;
                }
                let g2 = 0;
                for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
                  qd((d2 << 1) + this._siblingOffset[p3][0], (y2 << 1) + this._siblingOffset[p3][1], m2 + 1, t2, e2, r2, n2, c2, h2), c2[2] = -100, h2[2] = this.maximums[this.childOffsets[o3] + p3] * a2;
                  const f3 = $d(c2, h2, i2, s2);
                  if (null != f3) {
                    const t3 = f3;
                    l2[p3] = t3;
                    let e3 = false;
                    for (let r3 = 0; r3 < g2 && !e3; r3++)
                      t3 >= l2[u2[r3]] && (u2.splice(r3, 0, p3), e3 = true);
                    e3 || (u2[g2] = p3), g2++;
                  }
                }
                for (let t3 = 0; t3 < g2; t3++) {
                  const e3 = u2[t3];
                  p2.push({ idx: this.childOffsets[o3] + e3, t: l2[e3], nodex: (d2 << 1) + this._siblingOffset[e3][0], nodey: (y2 << 1) + this._siblingOffset[e3][1], depth: m2 + 1 });
                }
              }
              return null;
            }
            _addNode(t2, e2, r2) {
              return this.minimums.push(t2), this.maximums.push(e2), this.leaves.push(r2), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t2, e2, r2, n2, i2) {
              if (1 === t2[n2].isLeaf(e2, r2))
                return;
              this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
              const s2 = n2 - 1, a2 = t2[s2];
              let o2 = 0, l2 = 0;
              for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
                const n3 = 2 * e2 + this._siblingOffset[t3][0], i3 = 2 * r2 + this._siblingOffset[t3][1], s3 = a2.getElevation(n3, i3), u2 = a2.isLeaf(n3, i3), c2 = this._addNode(s3.min, s3.max, u2);
                u2 && (o2 |= 1 << t3), l2 || (l2 = c2);
              }
              for (let n3 = 0; n3 < this._siblingOffset.length; n3++)
                o2 & 1 << n3 || this._construct(t2, 2 * e2 + this._siblingOffset[n3][0], 2 * r2 + this._siblingOffset[n3][1], s2, l2 + n3);
            }
          }
          function Gd(t2, e2, r2, n2, i2, s2) {
            return Mr(Mr(t2, r2, s2), Mr(e2, n2, s2), i2);
          }
          function Zd(t2, e2, r2) {
            const n2 = r2.dim, i2 = S(t2 * n2 - 0.5, 0, n2 - 1), s2 = S(e2 * n2 - 0.5, 0, n2 - 1), a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = Math.min(a2 + 1, n2 - 1), u2 = Math.min(o2 + 1, n2 - 1);
            return Gd(r2.get(a2, o2), r2.get(l2, o2), r2.get(a2, u2), r2.get(l2, u2), i2 - a2, s2 - o2);
          }
          const Xd = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
          function Kd(t2, e2, r2) {
            return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
          }
          function Yd(t2, e2, r2) {
            return 256 * t2 + e2 + r2 / 256 - 32768;
          }
          class Hd {
            get tree() {
              return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t2, e2, r2, n2 = false, i2 = false) {
              if (this.uid = t2, e2.height !== e2.width)
                throw new RangeError("DEM tiles must be square");
              if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
                return U(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
              this.stride = e2.height;
              const s2 = this.dim = e2.height - 2, a2 = new Uint32Array(e2.data.buffer);
              if (this.pixels = new Uint8Array(e2.data.buffer), this.encoding = r2 || "mapbox", this.borderReady = n2, !n2) {
                for (let t3 = 0; t3 < s2; t3++)
                  a2[this._idx(-1, t3)] = a2[this._idx(0, t3)], a2[this._idx(s2, t3)] = a2[this._idx(s2 - 1, t3)], a2[this._idx(t3, -1)] = a2[this._idx(t3, 0)], a2[this._idx(t3, s2)] = a2[this._idx(t3, s2 - 1)];
                a2[this._idx(-1, -1)] = a2[this._idx(0, 0)], a2[this._idx(s2, -1)] = a2[this._idx(s2 - 1, 0)], a2[this._idx(-1, s2)] = a2[this._idx(0, s2 - 1)], a2[this._idx(s2, s2)] = a2[this._idx(s2 - 1, s2 - 1)], i2 && this._buildQuadTree();
              }
            }
            _buildQuadTree() {
              this._tree = new Nd(this);
            }
            get(t2, e2, r2 = false) {
              r2 && (t2 = S(t2, -1, this.dim), e2 = S(e2, -1, this.dim));
              const n2 = 4 * this._idx(t2, e2);
              return ("terrarium" === this.encoding ? Yd : Kd)(this.pixels[n2], this.pixels[n2 + 1], this.pixels[n2 + 2]);
            }
            static getUnpackVector(t2) {
              return Xd[t2];
            }
            get unpackVector() {
              return Xd[this.encoding];
            }
            _idx(t2, e2) {
              if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
                throw new RangeError("out of range source coordinates for DEM data");
              return (e2 + 1) * this.stride + (t2 + 1);
            }
            static pack(t2, e2) {
              const r2 = [0, 0, 0, 0], n2 = Hd.getUnpackVector(e2);
              let i2 = Math.floor((t2 + n2[3]) / n2[2]);
              return r2[2] = i2 % 256, i2 = Math.floor(i2 / 256), r2[1] = i2 % 256, i2 = Math.floor(i2 / 256), r2[0] = i2, r2;
            }
            getPixels() {
              return new Qu({ width: this.stride, height: this.stride }, this.pixels);
            }
            backfillBorder(t2, e2, r2) {
              if (this.dim !== t2.dim)
                throw new Error("dem dimension mismatch");
              let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
              switch (e2) {
                case -1:
                  n2 = i2 - 1;
                  break;
                case 1:
                  i2 = n2 + 1;
              }
              switch (r2) {
                case -1:
                  s2 = a2 - 1;
                  break;
                case 1:
                  a2 = s2 + 1;
              }
              const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
              for (let e3 = s2; e3 < a2; e3++)
                for (let r3 = n2; r3 < i2; r3++) {
                  const n3 = 4 * this._idx(r3, e3), i3 = 4 * this._idx(r3 + o2, e3 + l2);
                  this.pixels[n3 + 0] = t2.pixels[i3 + 0], this.pixels[n3 + 1] = t2.pixels[i3 + 1], this.pixels[n3 + 2] = t2.pixels[i3 + 2], this.pixels[n3 + 3] = t2.pixels[i3 + 3];
                }
            }
            onDeserialize() {
              this._tree && (this._tree.dem = this);
            }
          }
          Oi(Hd, "DEMData"), Oi(Nd, "DemMinMaxQuadTree", { omit: ["dem"] });
          class Wd {
            constructor(t2, e2) {
              this.max = t2, this.onRemove = e2, this.reset();
            }
            reset() {
              for (const t2 in this.data)
                for (const e2 of this.data[t2])
                  e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
              return this.data = {}, this.order = [], this;
            }
            add(t2, e2, r2) {
              const n2 = t2.wrapped().key;
              void 0 === this.data[n2] && (this.data[n2] = []);
              const i2 = { value: e2, timeout: void 0 };
              if (void 0 !== r2 && (i2.timeout = setTimeout(() => {
                this.remove(t2, i2);
              }, r2)), this.data[n2].push(i2), this.order.push(n2), this.order.length > this.max) {
                const t3 = this._getAndRemoveByKey(this.order[0]);
                t3 && this.onRemove(t3);
              }
              return this;
            }
            has(t2) {
              return t2.wrapped().key in this.data;
            }
            getAndRemove(t2) {
              return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
            }
            _getAndRemoveByKey(t2) {
              const e2 = this.data[t2].shift();
              return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
            }
            getByKey(t2) {
              const e2 = this.data[t2];
              return e2 ? e2[0].value : null;
            }
            get(t2) {
              return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
            }
            remove(t2, e2) {
              if (!this.has(t2))
                return this;
              const r2 = t2.wrapped().key, n2 = void 0 === e2 ? 0 : this.data[r2].indexOf(e2), i2 = this.data[r2][n2];
              return this.data[r2].splice(n2, 1), i2.timeout && clearTimeout(i2.timeout), 0 === this.data[r2].length && delete this.data[r2], this.onRemove(i2.value), this.order.splice(this.order.indexOf(r2), 1), this;
            }
            setMaxSize(t2) {
              for (this.max = t2; this.order.length > this.max; ) {
                const t3 = this._getAndRemoveByKey(this.order[0]);
                t3 && this.onRemove(t3);
              }
              return this;
            }
            filter(t2) {
              const e2 = [];
              for (const r2 in this.data)
                for (const n2 of this.data[r2])
                  t2(n2.value) || e2.push(n2);
              for (const t3 of e2)
                this.remove(t3.value.tileID, t3);
            }
          }
          class Jd {
            constructor(t2, e2, r2) {
              this.func = t2, this.mask = e2, this.range = r2;
            }
          }
          Jd.ReadOnly = false, Jd.ReadWrite = true, Jd.disabled = new Jd(519, Jd.ReadOnly, [0, 1]);
          const Qd = 7680;
          class ty {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.test = t2, this.ref = e2, this.mask = r2, this.fail = n2, this.depthFail = i2, this.pass = s2;
            }
          }
          ty.disabled = new ty({ func: 519, mask: 0 }, 0, 0, Qd, Qd, Qd);
          class ey {
            constructor(t2, e2, r2) {
              this.blendFunction = t2, this.blendColor = e2, this.mask = r2;
            }
          }
          ey.Replace = [1, 0], ey.disabled = new ey(ey.Replace, Me.transparent, [false, false, false, false]), ey.unblended = new ey(ey.Replace, Me.transparent, [true, true, true, true]), ey.alphaBlended = new ey([1, 771], Me.transparent, [true, true, true, true]);
          const ry = 1029, ny = 2305;
          class iy {
            constructor(t2, e2, r2) {
              this.enable = t2, this.mode = e2, this.frontFace = r2;
            }
          }
          iy.disabled = new iy(false, ry, ny), iy.backCCW = new iy(true, ry, ny), iy.backCW = new iy(true, ry, 2304), iy.frontCW = new iy(true, 1028, 2304), iy.frontCCW = new iy(true, 1028, ny);
          class sy extends Yt {
            constructor(t2, e2, r2) {
              super(), this.id = t2, this._onlySymbols = r2, e2.on("data", (t3) => {
                "source" === t3.dataType && "metadata" === t3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t3.dataType && "content" === t3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
              }), e2.on("error", () => {
                this._sourceErrored = true;
              }), this._source = e2, this._tiles = {}, this._cache = new Wd(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e2.minTileCacheSize, this._maxTileCacheSize = e2.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Rd(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(t2) {
              this.map = t2, this._minTileCacheSize = void 0 === this._minTileCacheSize && t2 ? t2._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t2 ? t2._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
              if (this._sourceErrored)
                return true;
              if (!this._sourceLoaded)
                return false;
              if (!this._source.loaded())
                return false;
              for (const t2 in this._tiles) {
                const e2 = this._tiles[t2];
                if ("loaded" !== e2.state && "errored" !== e2.state)
                  return false;
              }
              return true;
            }
            getSource() {
              return this._source;
            }
            pause() {
              this._paused = true;
            }
            resume() {
              if (!this._paused)
                return;
              const t2 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(t2, e2) {
              return t2.isSymbolTile = this._onlySymbols, this._source.loadTile(t2, e2);
            }
            _unloadTile(t2) {
              if (this._source.unloadTile)
                return this._source.unloadTile(t2, () => {
                });
            }
            _abortTile(t2) {
              if (this._source.abortTile)
                return this._source.abortTile(t2, () => {
                });
            }
            serialize() {
              return this._source.serialize();
            }
            prepare(t2) {
              this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
              for (const e2 in this._tiles) {
                const r2 = this._tiles[e2];
                r2.upload(t2), r2.prepare(this.map.style.imageManager);
              }
            }
            getIds() {
              return T(this._tiles).map((t2) => t2.tileID).sort(ay).map((t2) => t2.key);
            }
            getRenderableIds(t2) {
              const e2 = [];
              for (const r2 in this._tiles)
                this._isIdRenderable(+r2, t2) && e2.push(this._tiles[r2]);
              return t2 ? e2.sort((t3, e3) => {
                const r2 = t3.tileID, n2 = e3.tileID, i2 = new d(r2.canonical.x, r2.canonical.y)._rotate(this.transform.angle), s2 = new d(n2.canonical.x, n2.canonical.y)._rotate(this.transform.angle);
                return r2.overscaledZ - n2.overscaledZ || s2.y - i2.y || s2.x - i2.x;
              }).map((t3) => t3.tileID.key) : e2.map((t3) => t3.tileID).sort(ay).map((t3) => t3.key);
            }
            hasRenderableParent(t2) {
              const e2 = this.findLoadedParent(t2, 0);
              return !!e2 && this._isIdRenderable(e2.tileID.key);
            }
            _isIdRenderable(t2, e2) {
              return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
            }
            reload() {
              if (this._paused)
                this._shouldReloadOnResume = true;
              else {
                this._cache.reset();
                for (const t2 in this._tiles)
                  "errored" !== this._tiles[t2].state && this._reloadTile(+t2, "reloading");
              }
            }
            _reloadTile(t2, e2) {
              const r2 = this._tiles[t2];
              r2 && ("loading" !== r2.state && (r2.state = e2), this._loadTile(r2, this._tileLoaded.bind(this, r2, t2, e2)));
            }
            _tileLoaded(t2, e2, r2, n2) {
              if (n2)
                if (t2.state = "errored", 404 !== n2.status)
                  this._source.fire(new Kt(n2, { tile: t2 }));
                else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                  const t3 = this.map.painter.terrain;
                  this.update(this.transform, t3.getScaledDemTileSize(), true), t3.resetTileLookupCache(this.id);
                } else
                  this.update(this.transform);
              else
                t2.timeAdded = Nt.now(), "expired" === r2 && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(e2, t2), "raster-dem" === this._source.type && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), this._source.fire(new Xt("data", { dataType: "source", tile: t2, coord: t2.tileID, sourceCacheId: this.id }));
            }
            _backfillDEM(t2) {
              const e2 = this.getRenderableIds();
              for (let n2 = 0; n2 < e2.length; n2++) {
                const i2 = e2[n2];
                if (t2.neighboringTiles && t2.neighboringTiles[i2]) {
                  const e3 = this.getTileByID(i2);
                  r2(t2, e3), r2(e3, t2);
                }
              }
              function r2(t3, e3) {
                if (!t3.dem || t3.dem.borderReady)
                  return;
                t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true;
                let r3 = e3.tileID.canonical.x - t3.tileID.canonical.x;
                const n2 = e3.tileID.canonical.y - t3.tileID.canonical.y, i2 = Math.pow(2, t3.tileID.canonical.z), s2 = e3.tileID.key;
                0 === r3 && 0 === n2 || Math.abs(n2) > 1 || (Math.abs(r3) > 1 && (1 === Math.abs(r3 + i2) ? r3 += i2 : 1 === Math.abs(r3 - i2) && (r3 -= i2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, r3, n2), t3.neighboringTiles && t3.neighboringTiles[s2] && (t3.neighboringTiles[s2].backfilled = true)));
              }
            }
            getTile(t2) {
              return this.getTileByID(t2.key);
            }
            getTileByID(t2) {
              return this._tiles[t2];
            }
            _retainLoadedChildren(t2, e2, r2, n2) {
              for (const i2 in this._tiles) {
                let s2 = this._tiles[i2];
                if (n2[i2] || !s2.hasData() || s2.tileID.overscaledZ <= e2 || s2.tileID.overscaledZ > r2)
                  continue;
                let a2 = s2.tileID;
                for (; s2 && s2.tileID.overscaledZ > e2 + 1; ) {
                  const t3 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
                  s2 = this._tiles[t3.key], s2 && s2.hasData() && (a2 = t3);
                }
                let o2 = a2;
                for (; o2.overscaledZ > e2; )
                  if (o2 = o2.scaledTo(o2.overscaledZ - 1), t2[o2.key]) {
                    n2[a2.key] = a2;
                    break;
                  }
              }
            }
            findLoadedParent(t2, e2) {
              if (t2.key in this._loadedParentTiles) {
                const r2 = this._loadedParentTiles[t2.key];
                return r2 && r2.tileID.overscaledZ >= e2 ? r2 : null;
              }
              for (let r2 = t2.overscaledZ - 1; r2 >= e2; r2--) {
                const e3 = t2.scaledTo(r2), n2 = this._getLoadedTile(e3);
                if (n2)
                  return n2;
              }
            }
            _getLoadedTile(t2) {
              const e2 = this._tiles[t2.key];
              return e2 && e2.hasData() ? e2 : this._cache.getByKey(this._source.reparseOverscaled ? t2.wrapped().key : t2.canonical.key);
            }
            updateCacheSize(t2, e2) {
              e2 = e2 || this._source.tileSize;
              const r2 = Math.ceil(t2.width / e2) + 1, n2 = Math.ceil(t2.height / e2) + 1, i2 = Math.floor(r2 * n2 * 5), s2 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i2) : i2, a2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s2) : s2;
              this._cache.setMaxSize(a2);
            }
            handleWrapJump(t2) {
              const e2 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
              if (this._prevLng = t2, e2) {
                const t3 = {};
                for (const r2 in this._tiles) {
                  const n2 = this._tiles[r2];
                  n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e2), t3[n2.tileID.key] = n2;
                }
                this._tiles = t3;
                for (const t4 in this._timers)
                  clearTimeout(this._timers[t4]), delete this._timers[t4];
                for (const t4 in this._tiles)
                  this._setTileReloadTimer(+t4, this._tiles[t4]);
              }
            }
            update(t2, e2, r2) {
              if (this.transform = t2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
                return;
              if (this.usedForTerrain && !r2)
                return;
              let n2;
              this.updateCacheSize(t2, e2), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new Mh(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (n2 = t2.coveringTiles({ tileSize: e2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n2 = n2.filter((t3) => this._source.hasTile(t3)))) : n2 = [];
              const i2 = this._updateRetainedTiles(n2);
              if (oy(this._source.type) && 0 !== n2.length) {
                const t3 = {}, e3 = {}, r3 = Object.keys(i2);
                for (const n3 of r3) {
                  const r4 = i2[n3], s4 = this._tiles[n3];
                  if (!s4 || s4.fadeEndTime && s4.fadeEndTime <= Nt.now())
                    continue;
                  const a2 = this.findLoadedParent(r4, Math.max(r4.overscaledZ - sy.maxOverzooming, this._source.minzoom));
                  a2 && (this._addTile(a2.tileID), t3[a2.tileID.key] = a2.tileID), e3[n3] = r4;
                }
                const s3 = n2[n2.length - 1].overscaledZ;
                for (const t4 in this._tiles) {
                  const r4 = this._tiles[t4];
                  if (i2[t4] || !r4.hasData())
                    continue;
                  let n3 = r4.tileID;
                  for (; n3.overscaledZ > s3; ) {
                    n3 = n3.scaledTo(n3.overscaledZ - 1);
                    const s4 = this._tiles[n3.key];
                    if (s4 && s4.hasData() && e3[n3.key]) {
                      i2[t4] = r4.tileID;
                      break;
                    }
                  }
                }
                for (const e4 in t3)
                  i2[e4] || (this._coveredTiles[e4] = true, i2[e4] = t3[e4]);
              }
              for (const t3 in i2)
                this._tiles[t3].clearFadeHold();
              const s2 = function(t3, e3) {
                const r3 = [];
                for (const n3 in t3)
                  n3 in e3 || r3.push(n3);
                return r3;
              }(this._tiles, i2);
              for (const t3 of s2) {
                const e3 = this._tiles[t3];
                e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(+t3);
              }
              this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
              for (const t2 in this._tiles)
                this._tiles[t2].holdingForFade() && this._removeTile(+t2);
            }
            _updateRetainedTiles(t2) {
              const e2 = {};
              if (0 === t2.length)
                return e2;
              const r2 = {}, n2 = t2.reduce((t3, e3) => Math.min(t3, e3.overscaledZ), 1 / 0), i2 = t2[0].overscaledZ, s2 = Math.max(i2 - sy.maxOverzooming, this._source.minzoom), a2 = Math.max(i2 + sy.maxUnderzooming, this._source.minzoom), o2 = {};
              for (const r3 of t2) {
                const t3 = this._addTile(r3);
                e2[r3.key] = r3, t3.hasData() || n2 < this._source.maxzoom && (o2[r3.key] = r3);
              }
              this._retainLoadedChildren(o2, n2, a2, e2);
              for (const n3 of t2) {
                let t3 = this._tiles[n3.key];
                if (t3.hasData())
                  continue;
                if (n3.canonical.z >= this._source.maxzoom) {
                  const t4 = n3.children(this._source.maxzoom)[0], r3 = this.getTile(t4);
                  if (r3 && r3.hasData()) {
                    e2[t4.key] = t4;
                    continue;
                  }
                } else {
                  const t4 = n3.children(this._source.maxzoom);
                  if (e2[t4[0].key] && e2[t4[1].key] && e2[t4[2].key] && e2[t4[3].key])
                    continue;
                }
                let i3 = t3.wasRequested();
                for (let a3 = n3.overscaledZ - 1; a3 >= s2; --a3) {
                  const s3 = n3.scaledTo(a3);
                  if (r2[s3.key])
                    break;
                  if (r2[s3.key] = true, t3 = this.getTile(s3), !t3 && i3 && (t3 = this._addTile(s3)), t3 && (e2[s3.key] = s3, i3 = t3.wasRequested(), t3.hasData()))
                    break;
                }
              }
              return e2;
            }
            _updateLoadedParentTileCache() {
              this._loadedParentTiles = {};
              for (const t2 in this._tiles) {
                const e2 = [];
                let r2, n2 = this._tiles[t2].tileID;
                for (; n2.overscaledZ > 0; ) {
                  if (n2.key in this._loadedParentTiles) {
                    r2 = this._loadedParentTiles[n2.key];
                    break;
                  }
                  e2.push(n2.key);
                  const t3 = n2.scaledTo(n2.overscaledZ - 1);
                  if (r2 = this._getLoadedTile(t3), r2)
                    break;
                  n2 = t3;
                }
                for (const t3 of e2)
                  this._loadedParentTiles[t3] = r2;
              }
            }
            _addTile(t2) {
              let e2 = this._tiles[t2.key];
              if (e2)
                return e2;
              e2 = this._cache.getAndRemove(t2), e2 && (this._setTileReloadTimer(t2.key, e2), e2.tileID = t2, this._state.initializeTileState(e2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, e2)));
              const r2 = Boolean(e2);
              if (!r2) {
                const r3 = this.map ? this.map.painter : null;
                e2 = new Fd(t2, this._source.tileSize * t2.overscaleFactor(), this.transform.tileZoom, r3, this._isRaster), this._loadTile(e2, this._tileLoaded.bind(this, e2, t2.key, e2.state));
              }
              return e2 ? (e2.uses++, this._tiles[t2.key] = e2, r2 || this._source.fire(new Xt("dataloading", { tile: e2, coord: e2.tileID, dataType: "source" })), e2) : null;
            }
            _setTileReloadTimer(t2, e2) {
              t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
              const r2 = e2.getExpiryTimeout();
              r2 && (this._timers[t2] = setTimeout(() => {
                this._reloadTile(t2, "expired"), delete this._timers[t2];
              }, r2));
            }
            _removeTile(t2) {
              const e2 = this._tiles[t2];
              e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && "reloading" !== e2.state ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
            }
            clearTiles() {
              this._shouldReloadOnResume = false, this._paused = false;
              for (const t2 in this._tiles)
                this._removeTile(+t2);
              this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t2, e2, r2) {
              const n2 = [], i2 = this.transform;
              if (!i2)
                return n2;
              const s2 = "globe" === i2.projection.name, a2 = iu(i2.center.lng);
              for (const o2 in this._tiles) {
                const l2 = this._tiles[o2];
                if (r2 && l2.clearQueryDebugViz(), l2.holdingForFade())
                  continue;
                let u2;
                if (s2) {
                  const t3 = l2.tileID.canonical;
                  if (0 === t3.z) {
                    const e3 = [Math.abs(S(a2, ...ly(t3, -1)) - a2), Math.abs(S(a2, ...ly(t3, 1)) - a2)];
                    u2 = [0, 2 * e3.indexOf(Math.min(...e3)) - 1];
                  } else {
                    const e3 = [Math.abs(S(a2, ...ly(t3, -1)) - a2), Math.abs(S(a2, ...ly(t3, 0)) - a2), Math.abs(S(a2, ...ly(t3, 1)) - a2)];
                    u2 = [e3.indexOf(Math.min(...e3)) - 1];
                  }
                } else
                  u2 = [0];
                for (const r3 of u2) {
                  const s3 = t2.containsTile(l2, i2, e2, r3);
                  s3 && n2.push(s3);
                }
              }
              return n2;
            }
            getVisibleCoordinates(t2) {
              const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
              for (const t3 of e2)
                t3.projMatrix = this.transform.calculateProjMatrix(t3.toUnwrapped());
              return e2;
            }
            hasTransition() {
              if (this._source.hasTransition())
                return true;
              if (oy(this._source.type))
                for (const t2 in this._tiles) {
                  const e2 = this._tiles[t2];
                  if (void 0 !== e2.fadeEndTime && e2.fadeEndTime >= Nt.now())
                    return true;
                }
              return false;
            }
            setFeatureState(t2, e2, r2) {
              this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, r2);
            }
            removeFeatureState(t2, e2, r2) {
              this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, r2);
            }
            getFeatureState(t2, e2) {
              return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
            }
            setDependencies(t2, e2, r2) {
              const n2 = this._tiles[t2];
              n2 && n2.setDependencies(e2, r2);
            }
            reloadTilesForDependencies(t2, e2) {
              for (const r2 in this._tiles)
                this._tiles[r2].hasDependency(t2, e2) && this._reloadTile(+r2, "reloading");
              this._cache.filter((r2) => !r2.hasDependency(t2, e2));
            }
            _preloadTiles(t2, e2) {
              const r2 = /* @__PURE__ */ new Map(), n2 = Array.isArray(t2) ? t2 : [t2], i2 = this.map.painter.terrain, s2 = this.usedForTerrain && i2 ? i2.getScaledDemTileSize() : this._source.tileSize;
              for (const t3 of n2) {
                const e3 = t3.coveringTiles({ tileSize: s2, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
                for (const t4 of e3)
                  r2.set(t4.key, t4);
                this.usedForTerrain && t3.updateElevation(false);
              }
              M(Array.from(r2.values()), (t3, e3) => {
                const r3 = new Fd(t3, this._source.tileSize * t3.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
                this._loadTile(r3, (t4) => {
                  "raster-dem" === this._source.type && r3.dem && this._backfillDEM(r3), e3(t4, r3);
                });
              }, e2);
            }
          }
          function ay(t2, e2) {
            const r2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), n2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
            return t2.overscaledZ - e2.overscaledZ || n2 - r2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
          }
          function oy(t2) {
            return "raster" === t2 || "image" === t2 || "video" === t2 || "custom" === t2;
          }
          function ly(t2, e2) {
            const r2 = 1 << t2.z;
            return [t2.x / r2 + e2, (t2.x + 1) / r2 + e2];
          }
          sy.maxOverzooming = 10, sy.maxUnderzooming = 3;
          class uy {
            constructor(t2, e2, r2) {
              this._demTile = t2, this._dem = this._demTile.dem, this._scale = e2, this._offset = r2;
            }
            static create(t2, e2, r2) {
              const n2 = r2 || t2.findDEMTileFor(e2);
              if (!n2 || !n2.dem)
                return;
              const i2 = n2.dem, s2 = n2.tileID, a2 = 1 << e2.canonical.z - s2.canonical.z;
              return new uy(n2, n2.tileSize / ko / a2, [(e2.canonical.x / a2 - s2.canonical.x) * i2.dim, (e2.canonical.y / a2 - s2.canonical.y) * i2.dim]);
            }
            tileCoordToPixel(t2, e2) {
              const r2 = e2 * this._scale + this._offset[1], n2 = Math.floor(t2 * this._scale + this._offset[0]), i2 = Math.floor(r2);
              return new d(n2, i2);
            }
            getElevationAt(t2, e2, r2, n2) {
              const i2 = t2 * this._scale + this._offset[0], s2 = e2 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = this._dem;
              return n2 = !!n2, r2 ? Mr(Mr(l2.get(a2, o2, n2), l2.get(a2, o2 + 1, n2), s2 - o2), Mr(l2.get(a2 + 1, o2, n2), l2.get(a2 + 1, o2 + 1, n2), s2 - o2), i2 - a2) : l2.get(a2, o2, n2);
            }
            getElevationAtPixel(t2, e2, r2) {
              return this._dem.get(t2, e2, !!r2);
            }
            getMeterToDEM(t2) {
              return (1 << this._demTile.tileID.canonical.z) * au(1, t2) * this._dem.stride;
            }
          }
          class cy {
            constructor(t2, e2) {
              this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new ji(ko, 16, 0), this.featureIndexArray = new ja(), this.promoteId = e2;
            }
            insert(t2, e2, r2, n2, i2, s2 = 0) {
              const a2 = this.featureIndexArray.length;
              this.featureIndexArray.emplaceBack(r2, n2, i2, s2);
              const o2 = this.grid;
              for (let t3 = 0; t3 < e2.length; t3++) {
                const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let t4 = 0; t4 < r3.length; t4++) {
                  const e3 = r3[t4];
                  n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
                }
                n3[0] < ko && n3[1] < ko && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
              }
            }
            loadVTLayers() {
              if (!this.vtLayers) {
                this.vtLayers = new sh(new op(this.rawTileData)).layers, this.sourceLayerCoder = new kd(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
                for (const t2 in this.vtLayers)
                  this.vtFeatures[t2] = [];
              }
              return this.vtLayers;
            }
            query(t2, e2, r2, n2) {
              this.loadVTLayers();
              const i2 = t2.params || {}, s2 = ai(i2.filter), a2 = t2.tileResult, o2 = t2.transform, l2 = a2.bufferedTilespaceBounds, u2 = this.grid.query(l2.min.x, l2.min.y, l2.max.x, l2.max.y, (t3, e3, r3, n3) => Vu(a2.bufferedTilespaceGeometry, t3, e3, r3, n3));
              u2.sort(py);
              let c2 = null;
              o2.elevation && u2.length > 0 && (c2 = uy.create(o2.elevation, this.tileID));
              const h2 = {};
              let p2;
              for (let o3 = 0; o3 < u2.length; o3++) {
                const l3 = u2[o3];
                if (l3 === p2)
                  continue;
                p2 = l3;
                const f2 = this.featureIndexArray.get(l3);
                let d2 = null;
                this.loadMatchingFeature(h2, f2, s2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3, i3 = 0) => (d2 || (d2 = bu(e3, this.tileID.canonical, t2.tileTransform)), r3.queryIntersectsFeature(a2, e3, n3, d2, this.z, t2.transform, t2.pixelPosMatrix, c2, i3)));
              }
              return h2;
            }
            loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
              const { featureIndex: u2, bucketIndex: c2, sourceLayerIndex: h2, layoutVertexArrayOffset: p2 } = e2, f2 = this.bucketLayerIDs[c2];
              if (n2 && !function(t3, e3) {
                for (let r3 = 0; r3 < t3.length; r3++)
                  if (e3.indexOf(t3[r3]) >= 0)
                    return true;
                return false;
              }(n2, f2))
                return;
              const d2 = this.sourceLayerCoder.decode(h2), y2 = this.vtLayers[d2].feature(u2);
              if (r2.needGeometry) {
                const t3 = wu(y2, true);
                if (!r2.filter(new $s(this.tileID.overscaledZ), t3, this.tileID.canonical))
                  return;
              } else if (!r2.filter(new $s(this.tileID.overscaledZ), y2))
                return;
              const m2 = this.getId(y2, d2);
              for (let e3 = 0; e3 < f2.length; e3++) {
                const r3 = f2[e3];
                if (n2 && n2.indexOf(r3) < 0)
                  continue;
                const c3 = s2[r3];
                if (!c3)
                  continue;
                let h3 = {};
                void 0 !== m2 && o2 && (h3 = o2.getState(c3.sourceLayer || "_geojsonTileLayer", m2));
                const d3 = z({}, a2[r3]);
                d3.paint = hy(d3.paint, c3.paint, y2, h3, i2), d3.layout = hy(d3.layout, c3.layout, y2, h3, i2);
                const g2 = !l2 || l2(y2, c3, h3, p2);
                if (!g2)
                  continue;
                const x2 = new Md(y2, this.z, this.x, this.y, m2);
                x2.layer = d3;
                let v2 = t2[r3];
                void 0 === v2 && (v2 = t2[r3] = []), v2.push({ featureIndex: u2, feature: x2, intersectionZ: g2 });
              }
            }
            lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = {};
              this.loadVTLayers();
              const u2 = ai(i2);
              for (const i3 of t2)
                this.loadMatchingFeature(l2, { bucketIndex: r2, sourceLayerIndex: n2, featureIndex: i3, layoutVertexArrayOffset: 0 }, u2, s2, a2, o2, e2);
              return l2;
            }
            loadFeature(t2) {
              const { featureIndex: e2, sourceLayerIndex: r2 } = t2;
              this.loadVTLayers();
              const n2 = this.sourceLayerCoder.decode(r2), i2 = this.vtFeatures[n2];
              if (i2[e2])
                return i2[e2];
              const s2 = this.vtLayers[n2].feature(e2);
              return i2[e2] = s2, s2;
            }
            hasLayer(t2) {
              for (const e2 of this.bucketLayerIDs)
                for (const r2 of e2)
                  if (t2 === r2)
                    return true;
              return false;
            }
            getId(t2, e2) {
              let r2 = t2.id;
              if (this.promoteId) {
                const n2 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2];
                null != n2 && (r2 = t2.properties[n2]), "boolean" == typeof r2 && (r2 = Number(r2));
              }
              return r2;
            }
          }
          function hy(t2, e2, r2, n2, i2) {
            return F(t2, (t3, s2) => {
              const a2 = e2 instanceof Ks ? e2.get(s2) : null;
              return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
            });
          }
          function py(t2, e2) {
            return e2 - t2;
          }
          Oi(cy, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
          class fy {
            constructor(t2, e2) {
              this.width = t2, this.height = e2, this.nextRow = 0, this.image = new Ju({ width: t2, height: e2 }), this.positions = {}, this.uploaded = false;
            }
            getDash(t2, e2) {
              const r2 = this.getKey(t2, e2);
              return this.positions[r2];
            }
            trim() {
              const t2 = this.width, e2 = this.height = P(this.nextRow);
              this.image.resize({ width: t2, height: e2 });
            }
            getKey(t2, e2) {
              return t2.join(",") + e2;
            }
            getDashRanges(t2, e2, r2) {
              const n2 = [];
              let i2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * r2 : 0, s2 = t2[0] * r2, a2 = true;
              n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === t2[0] });
              let o2 = t2[0];
              for (let e3 = 1; e3 < t2.length; e3++) {
                a2 = !a2;
                const l2 = t2[e3];
                i2 = o2 * r2, o2 += l2, s2 = o2 * r2, n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === l2 });
              }
              return n2;
            }
            addRoundDash(t2, e2, r2) {
              const n2 = e2 / 2;
              for (let e3 = -r2; e3 <= r2; e3++) {
                const i2 = this.width * (this.nextRow + r2 + e3);
                let s2 = 0, a2 = t2[s2];
                for (let o2 = 0; o2 < this.width; o2++) {
                  o2 / a2.right > 1 && (a2 = t2[++s2]);
                  const l2 = Math.abs(o2 - a2.left), u2 = Math.abs(o2 - a2.right), c2 = Math.min(l2, u2);
                  let h2;
                  const p2 = e3 / r2 * (n2 + 1);
                  if (a2.isDash) {
                    const t3 = n2 - Math.abs(p2);
                    h2 = Math.sqrt(c2 * c2 + t3 * t3);
                  } else
                    h2 = n2 - Math.sqrt(c2 * c2 + p2 * p2);
                  this.image.data[i2 + o2] = Math.max(0, Math.min(255, h2 + 128));
                }
              }
            }
            addRegularDash(t2, e2) {
              for (let e3 = t2.length - 1; e3 >= 0; --e3) {
                const r3 = t2[e3], n3 = t2[e3 + 1];
                r3.zeroLength ? t2.splice(e3, 1) : n3 && n3.isDash === r3.isDash && (n3.left = r3.left, t2.splice(e3, 1));
              }
              const r2 = t2[0], n2 = t2[t2.length - 1];
              r2.isDash === n2.isDash && (r2.left = n2.left - this.width, n2.right = r2.right + this.width);
              const i2 = this.width * this.nextRow;
              let s2 = 0, a2 = t2[s2];
              for (let r3 = 0; r3 < this.width; r3++) {
                r3 / a2.right > 1 && (a2 = t2[++s2]);
                const n3 = Math.abs(r3 - a2.left), o2 = Math.abs(r3 - a2.right), l2 = Math.min(n3, o2);
                this.image.data[i2 + r3] = Math.max(0, Math.min(255, (a2.isDash ? l2 : -l2) + e2 + 128));
              }
            }
            addDash(t2, e2) {
              const r2 = this.getKey(t2, e2);
              if (this.positions[r2])
                return this.positions[r2];
              const n2 = "round" === e2, i2 = n2 ? 7 : 0, s2 = 2 * i2 + 1;
              if (this.nextRow + s2 > this.height)
                return U("LineAtlas out of space"), null;
              0 === t2.length && t2.push(1);
              let a2 = 0;
              for (let e3 = 0; e3 < t2.length; e3++)
                t2[e3] < 0 && (U("Negative value is found in line dasharray, replacing values with 0"), t2[e3] = 0), a2 += t2[e3];
              if (0 !== a2) {
                const r3 = this.width / a2, s3 = this.getDashRanges(t2, this.width, r3);
                n2 ? this.addRoundDash(s3, r3, i2) : this.addRegularDash(s3, "square" === e2 ? 0.5 * r3 : 0);
              }
              const o2 = this.nextRow + i2;
              this.nextRow += s2;
              const l2 = { tl: [o2, i2], br: [a2, 0] };
              return this.positions[r2] = l2, l2;
            }
          }
          Oi(fy, "LineAtlas");
          class dy {
            constructor(t2) {
              const e2 = {}, r2 = [];
              for (const n3 in t2) {
                const i3 = t2[n3], s3 = e2[n3] = {};
                for (const t3 in i3.glyphs) {
                  const e3 = i3.glyphs[+t3];
                  if (!e3 || 0 === e3.bitmap.width || 0 === e3.bitmap.height)
                    continue;
                  const n4 = e3.metrics.localGlyph ? 2 : 1, a2 = { x: 0, y: 0, w: e3.bitmap.width + 2 * n4, h: e3.bitmap.height + 2 * n4 };
                  r2.push(a2), s3[t3] = a2;
                }
              }
              const { w: n2, h: i2 } = Cp(r2), s2 = new Ju({ width: n2 || 1, height: i2 || 1 });
              for (const r3 in t2) {
                const n3 = t2[r3];
                for (const t3 in n3.glyphs) {
                  const i3 = n3.glyphs[+t3];
                  if (!i3 || 0 === i3.bitmap.width || 0 === i3.bitmap.height)
                    continue;
                  const a2 = e2[r3][t3], o2 = i3.metrics.localGlyph ? 2 : 1;
                  Ju.copy(i3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + o2, y: a2.y + o2 }, i3.bitmap);
                }
              }
              this.image = s2, this.positions = e2;
            }
          }
          Oi(dy, "GlyphAtlas");
          class yy {
            constructor(t2) {
              this.tileID = new Mh(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.enableTerrain = !!t2.enableTerrain, this.isSymbolTile = t2.isSymbolTile, this.tileTransform = Vf(t2.tileID.canonical, t2.projection), this.projection = t2.projection;
            }
            parse(t2, e2, r2, n2, i2) {
              this.status = "parsing", this.data = t2, this.collisionBoxArray = new Ea();
              const s2 = new kd(Object.keys(t2.layers).sort()), a2 = new cy(this.tileID, this.promoteId);
              a2.bucketLayerIDs = [];
              const o2 = {}, l2 = new fy(256, 256), u2 = { featureIndex: a2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l2, availableImages: r2 }, c2 = e2.familiesBySource[this.source];
              for (const e3 in c2) {
                const n3 = t2.layers[e3];
                if (!n3)
                  continue;
                let i3 = false, l3 = false;
                for (const t3 of c2[e3])
                  "symbol" === t3[0].type ? i3 = true : l3 = true;
                if (true === this.isSymbolTile && !i3)
                  continue;
                if (false === this.isSymbolTile && !l3)
                  continue;
                1 === n3.version && U(`Vector tile source "${this.source}" layer "${e3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const h3 = s2.encode(e3), p3 = [];
                for (let t3 = 0; t3 < n3.length; t3++) {
                  const r3 = n3.feature(t3), i4 = a2.getId(r3, e3);
                  p3.push({ feature: r3, id: i4, index: t3, sourceLayerIndex: h3 });
                }
                for (const t3 of c2[e3]) {
                  const e4 = t3[0];
                  void 0 !== this.isSymbolTile && "symbol" === e4.type !== this.isSymbolTile || e4.minzoom && this.zoom < Math.floor(e4.minzoom) || e4.maxzoom && this.zoom >= e4.maxzoom || "none" !== e4.visibility && (my(t3, this.zoom, r2), (o2[e4.id] = e4.createBucket({ index: a2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: h3, sourceID: this.source, enableTerrain: this.enableTerrain, projection: this.projection.spec, availableImages: r2 })).populate(p3, u2, this.tileID.canonical, this.tileTransform), a2.bucketLayerIDs.push(t3.map((t4) => t4.id)));
                }
              }
              let h2, p2, f2, d2;
              l2.trim();
              const y2 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, m2 = F(u2.glyphDependencies, (t3) => Object.keys(t3).map(Number));
              Object.keys(m2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: m2 }, (t3, e3) => {
                h2 || (h2 = t3, p2 = e3, v2.call(this));
              }, void 0, false, y2) : p2 = {};
              const g2 = Object.keys(u2.iconDependencies);
              g2.length ? n2.send("getImages", { icons: g2, source: this.source, tileID: this.tileID, type: "icons" }, (t3, e3) => {
                h2 || (h2 = t3, f2 = e3, v2.call(this));
              }, void 0, false, y2) : f2 = {};
              const x2 = Object.keys(u2.patternDependencies);
              function v2() {
                if (h2)
                  return i2(h2);
                if (p2 && f2 && d2) {
                  const t3 = new dy(p2), e3 = new Dp(f2, d2);
                  for (const n3 in o2) {
                    const i3 = o2[n3];
                    i3 instanceof hd ? (my(i3.layers, this.zoom, r2), kf(i3, p2, t3.positions, f2, e3.iconPositions, this.showCollisionBoxes, r2, this.tileID.canonical, this.tileZoom, this.projection)) : i3.hasPattern && (i3 instanceof jh || i3 instanceof $c || i3 instanceof fh) && (my(i3.layers, this.zoom, r2), i3.addFeatures(u2, this.tileID.canonical, e3.patternPositions, r2, this.tileTransform));
                  }
                  this.status = "done", i2(null, { buckets: T(o2).filter((t4) => !t4.isEmpty()), featureIndex: a2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, lineAtlas: l2, imageAtlas: e3, glyphMap: this.returnDependencies ? p2 : null, iconMap: this.returnDependencies ? f2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
                }
              }
              x2.length ? n2.send("getImages", { icons: x2, source: this.source, tileID: this.tileID, type: "patterns" }, (t3, e3) => {
                h2 || (h2 = t3, d2 = e3, v2.call(this));
              }, void 0, false, y2) : d2 = {}, v2.call(this);
            }
          }
          function my(t2, e2, r2) {
            const n2 = new $s(e2);
            for (const e3 of t2)
              e3.recalculate(n2, r2);
          }
          class gy {
            constructor(t2) {
              this.entries = {}, this.scheduler = t2;
            }
            request(t2, e2, r2, n2) {
              const i2 = this.entries[t2] = this.entries[t2] || { callbacks: [] };
              if (i2.result) {
                const [t3, r3] = i2.result;
                return this.scheduler ? this.scheduler.add(() => {
                  n2(t3, r3);
                }, e2) : n2(t3, r3), () => {
                };
              }
              return i2.callbacks.push(n2), i2.cancel || (i2.cancel = r2((r3, n3) => {
                i2.result = [r3, n3];
                for (const t3 of i2.callbacks)
                  this.scheduler ? this.scheduler.add(() => {
                    t3(r3, n3);
                  }, e2) : t3(r3, n3);
                setTimeout(() => delete this.entries[t2], 3e3);
              })), () => {
                i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n2), i2.callbacks.length || (i2.cancel(), delete this.entries[t2]));
              };
            }
          }
          function xy(t2, e2, r2) {
            const n2 = JSON.stringify(t2.request);
            return t2.data && (this.deduped.entries[n2] = { result: [null, t2.data] }), this.deduped.request(n2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }, (e3) => {
              const n3 = ut(t2.request, (t3, n4, i2, s2) => {
                t3 ? e3(t3) : n4 && e3(null, { vectorTile: r2 ? void 0 : new sh(new op(n4)), rawData: n4, cacheControl: i2, expires: s2 });
              });
              return () => {
                n3.cancel(), e3();
              };
            }, e2);
          }
          t.ARRAY_TYPE = To, t.AUTH_ERR_MSG = yt, t.Aabb = _l, t.Actor = class {
            constructor(t2, r2, n2) {
              this.target = t2, this.parent = r2, this.mapId = n2, this.callbacks = {}, this.cancelCallbacks = {}, V(["receive"], this), this.target.addEventListener("message", this.receive, false), this.globalScope = N() ? t2 : e, this.scheduler = new Sd();
            }
            send(t2, e2, r2, n2, i2 = false, s2) {
              const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              r2 && (r2.metadata = s2, this.callbacks[a2] = r2);
              const o2 = X(this.globalScope) ? void 0 : [];
              return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: Gi(e2, o2) }, o2), { cancel: () => {
                r2 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
              } };
            }
            receive(t2) {
              const e2 = t2.data, r2 = e2.id;
              if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
                if ("<cancel>" === e2.type) {
                  const t3 = this.cancelCallbacks[r2];
                  delete this.cancelCallbacks[r2], t3 && t3.cancel();
                } else if (e2.mustQueue || N()) {
                  const t3 = this.callbacks[r2];
                  this.cancelCallbacks[r2] = this.scheduler.add(() => this.processTask(r2, e2), t3 && t3.metadata || { type: "message" });
                } else
                  this.processTask(r2, e2);
            }
            processTask(t2, e2) {
              if ("<response>" === e2.type) {
                const r2 = this.callbacks[t2];
                delete this.callbacks[t2], r2 && (e2.error ? r2(Zi(e2.error)) : r2(null, Zi(e2.data)));
              } else {
                const r2 = X(this.globalScope) ? void 0 : [], n2 = e2.hasCallback ? (e3, n3) => {
                  delete this.cancelCallbacks[t2], this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? Gi(e3) : null, data: Gi(n3, r2) }, r2);
                } : (t3) => {
                }, i2 = Zi(e2.data);
                if (this.parent[e2.type])
                  this.parent[e2.type](e2.sourceMapId, i2, n2);
                else if (this.parent.getWorkerSource) {
                  const t3 = e2.type.split(".");
                  this.parent.getWorkerSource(e2.sourceMapId, t3[0], i2.source)[t3[1]](i2, n2);
                } else
                  n2(new Error(`Could not find function ${e2.type}`));
              }
            }
            remove() {
              this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
            }
          }, t.CanonicalTileID = kh, t.Color = Me, t.ColorMode = ey, t.CullFaceMode = iy, t.DEMData = Hd, t.DataConstantProperty = Ys, t.DedupedRequest = gy, t.DepthMode = Jd, t.EXTENT = ko, t.Elevation = class {
            isDataAvailableAtPoint(t2) {
              const e2 = this._source();
              if (this.isUsingMockSource() || !e2 || t2.y < 0 || t2.y > 1)
                return false;
              const r2 = e2.getSource().maxzoom, n2 = 1 << r2, i2 = Math.floor(t2.x), s2 = Math.floor((t2.x - i2) * n2), a2 = Math.floor(t2.y * n2), o2 = this.findDEMTileFor(new Mh(r2, i2, r2, s2, a2));
              return !(!o2 || !o2.dem);
            }
            getAtPointOrZero(t2, e2 = 0) {
              return this.getAtPoint(t2, e2) || 0;
            }
            getAtPoint(t2, e2, r2 = true) {
              if (this.isUsingMockSource())
                return null;
              null == e2 && (e2 = null);
              const n2 = this._source();
              if (!n2)
                return e2;
              if (t2.y < 0 || t2.y > 1)
                return e2;
              const i2 = n2.getSource().maxzoom, s2 = 1 << i2, a2 = Math.floor(t2.x), o2 = t2.x - a2, l2 = new Mh(i2, a2, i2, Math.floor(o2 * s2), Math.floor(t2.y * s2)), u2 = this.findDEMTileFor(l2);
              if (!u2 || !u2.dem)
                return e2;
              const c2 = u2.dem, h2 = 1 << u2.tileID.canonical.z, p2 = (o2 * h2 - u2.tileID.canonical.x) * c2.dim, f2 = (t2.y * h2 - u2.tileID.canonical.y) * c2.dim, d2 = Math.floor(p2), y2 = Math.floor(f2);
              return (r2 ? this.exaggeration() : 1) * Mr(Mr(c2.get(d2, y2), c2.get(d2, y2 + 1), f2 - y2), Mr(c2.get(d2 + 1, y2), c2.get(d2 + 1, y2 + 1), f2 - y2), p2 - d2);
            }
            getAtTileOffset(t2, e2, r2) {
              const n2 = 1 << t2.canonical.z;
              return this.getAtPointOrZero(new pu(t2.wrap + (t2.canonical.x + e2 / ko) / n2, (t2.canonical.y + r2 / ko) / n2));
            }
            getAtTileOffsetFunc(t2, e2, r2, n2) {
              return (i2) => {
                const s2 = this.getAtTileOffset(t2, i2.x, i2.y), a2 = n2.upVector(t2.canonical, i2.x, i2.y);
                return Ho(a2, a2, s2 * n2.upVectorScale(t2.canonical, e2, r2).metersToTile), a2;
              };
            }
            getForTilePoints(t2, e2, r2, n2) {
              if (this.isUsingMockSource())
                return false;
              const i2 = uy.create(this, t2, n2);
              return !!i2 && (e2.forEach((t3) => {
                t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r2);
              }), true);
            }
            getMinMaxForTile(t2) {
              if (this.isUsingMockSource())
                return null;
              const e2 = this.findDEMTileFor(t2);
              if (!e2 || !e2.dem)
                return null;
              const r2 = e2.dem.tree, n2 = e2.tileID, i2 = 1 << t2.canonical.z - n2.canonical.z;
              let s2 = t2.canonical.x / i2 - n2.canonical.x, a2 = t2.canonical.y / i2 - n2.canonical.y, o2 = 0;
              for (let e3 = 0; e3 < t2.canonical.z - n2.canonical.z && !r2.leaves[o2]; e3++) {
                s2 *= 2, a2 *= 2;
                const t3 = 2 * Math.floor(a2) + Math.floor(s2);
                o2 = r2.childOffsets[o2] + t3, s2 %= 1, a2 %= 1;
              }
              return { min: this.exaggeration() * r2.minimums[o2], max: this.exaggeration() * r2.maximums[o2] };
            }
            getMinElevationBelowMSL() {
              throw new Error("Pure virtual method called.");
            }
            raycast(t2, e2, r2) {
              throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t2) {
              throw new Error("Pure virtual method called.");
            }
            _source() {
              throw new Error("Pure virtual method called.");
            }
            isUsingMockSource() {
              throw new Error("Pure virtual method called.");
            }
            exaggeration() {
              throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t2) {
              throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
              throw new Error("Getter must be implemented in subclass.");
            }
          }, t.ErrorEvent = Kt, t.EvaluationParameters = $s, t.Event = Xt, t.Evented = Yt, t.FillExtrusionBucket = fh, t.Frustum = wl, t.FrustumCorners = bl, t.GLOBE_RADIUS = Al, t.GLOBE_SCALE_MATCH_LATITUDE = 45, t.GLOBE_ZOOM_THRESHOLD_MAX = 6, t.GLOBE_ZOOM_THRESHOLD_MIN = 5, t.GlobeSharedBuffers = class {
            constructor(t2) {
              this._createGrid(t2), this._createPoles(t2);
            }
            destroy() {
              this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
              for (const t2 of this._poleSegments)
                t2.destroy();
              for (const t2 of this._gridSegments)
                t2.withSkirts.destroy(), t2.withoutSkirts.destroy();
              if (this._wireframeIndexBuffer) {
                this._wireframeIndexBuffer.destroy();
                for (const t2 of this._wireframeSegments)
                  t2.destroy();
              }
            }
            _fillGridMeshWithLods(t2, e2) {
              const r2 = new sa(), n2 = new wa(), i2 = [], s2 = t2 + 1 + 2, a2 = e2[0] + 1, o2 = e2[0] + 1 + (1 + e2.length), l2 = (t3, e3, r3) => {
                let n3 = t3 === s2 - 1 ? t3 - 2 : 0 === t3 ? t3 : t3 - 1;
                return n3 += r3 ? 24575 : 0, [n3, e3];
              };
              for (let t3 = 0; t3 < s2; ++t3)
                r2.emplaceBack(...l2(t3, 0, true));
              for (let t3 = 0; t3 < a2; ++t3)
                for (let e3 = 0; e3 < s2; ++e3)
                  r2.emplaceBack(...l2(e3, t3, (0 === e3 || e3 === s2 - 1) && true));
              for (let t3 = 0; t3 < e2.length; ++t3) {
                const n3 = e2[t3];
                for (let t4 = 0; t4 < s2; ++t4)
                  r2.emplaceBack(...l2(t4, n3, true));
              }
              for (let t3 = 0; t3 < e2.length; ++t3) {
                const a3 = n2.length, l3 = e2[t3] + 1 + 2, u2 = new wa();
                for (let r3 = 0; r3 < l3 - 1; r3++) {
                  const i3 = r3 === l3 - 2, a4 = i3 ? s2 * (o2 - e2.length + t3 - r3) : s2;
                  for (let t4 = 0; t4 < s2 - 1; t4++) {
                    const e3 = r3 * s2 + t4;
                    0 === r3 || i3 || 0 === t4 || t4 === s2 - 2 ? (u2.emplaceBack(e3 + 1, e3, e3 + a4), u2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1)) : (n2.emplaceBack(e3 + 1, e3, e3 + a4), n2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1));
                  }
                }
                const c2 = So.simpleSegment(0, a3, r2.length, n2.length - a3);
                for (let t4 = 0; t4 < u2.uint16.length; t4 += 3)
                  n2.emplaceBack(u2.uint16[t4], u2.uint16[t4 + 1], u2.uint16[t4 + 2]);
                const h2 = So.simpleSegment(0, a3, r2.length, n2.length - a3);
                i2.push({ withoutSkirts: c2, withSkirts: h2 });
              }
              return { vertices: r2, indices: n2, segments: i2 };
            }
            _createGrid(t2) {
              const e2 = this._fillGridMeshWithLods(Sl, kl);
              this._gridSegments = e2.segments, this._gridBuffer = t2.createVertexBuffer(e2.vertices, xl.members), this._gridIndexBuffer = t2.createIndexBuffer(e2.indices, true);
            }
            _createPoles(t2) {
              const e2 = new wa();
              for (let t3 = 0; t3 <= Sl; t3++)
                e2.emplaceBack(0, t3 + 1, t3 + 2);
              this._poleIndexBuffer = t2.createIndexBuffer(e2, true);
              const r2 = new ka(), n2 = new ka();
              this._poleSegments = [];
              for (let t3 = 0, e3 = 0; t3 < 5; t3++) {
                const i2 = 360 / (1 << t3);
                r2.emplaceBack(0, -Al, 0, 0.5, 0), n2.emplaceBack(0, -Al, 0, 0.5, 1);
                for (let t4 = 0; t4 <= Sl; t4++) {
                  const e4 = t4 / Sl, s2 = Mr(0, i2, e4), [a2, o2, l2] = $l(Jl, Ql, s2, Al);
                  r2.emplaceBack(a2, o2, l2, e4, 0), n2.emplaceBack(a2, o2, l2, e4, 1);
                }
                this._poleSegments.push(So.simpleSegment(e3, 0, 66, 64)), e3 += 66;
              }
              this._poleNorthVertexBuffer = t2.createVertexBuffer(r2, ml, false), this._poleSouthVertexBuffer = t2.createVertexBuffer(n2, ml, false);
            }
            getGridBuffers(t2, e2) {
              return [this._gridBuffer, this._gridIndexBuffer, e2 ? this._gridSegments[t2].withSkirts : this._gridSegments[t2].withoutSkirts];
            }
            getPoleBuffers(t2) {
              return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t2]];
            }
            getWirefameBuffers(t2, e2) {
              if (!this._wireframeSegments) {
                const e3 = new Ma(), r2 = Sl, n2 = r2 + 1 + 2, i2 = 1;
                this._wireframeSegments = [];
                for (let t3 = 0, s2 = 0; t3 < kl.length; t3++) {
                  const a2 = kl[t3];
                  for (let t4 = i2; t4 < a2 + i2; t4++)
                    for (let s3 = i2; s3 < r2 + i2; s3++) {
                      const r3 = t4 * n2 + s3;
                      e3.emplaceBack(r3, r3 + 1), e3.emplaceBack(r3, r3 + n2), e3.emplaceBack(r3, r3 + n2 + 1);
                    }
                  const o2 = a2 * r2 * 3;
                  this._wireframeSegments.push(So.simpleSegment(0, s2, (a2 + 1) * n2, o2)), s2 += o2;
                }
                this._wireframeIndexBuffer = t2.createIndexBuffer(e3);
              }
              return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e2]];
            }
          }, t.GlyphManager = cf, t.ImagePosition = Pp, t.LivePerformanceUtils = Lt, t.LngLat = ru, t.LngLatBounds = Io, t.LocalGlyphMode = uf, t.MAX_MERCATOR_LATITUDE = cu, t.MercatorCoordinate = pu, t.ONE_EM = Wh, t.OverscaledTileID = Mh, t.PerformanceMarkers = Vt, t.Properties = Js, t.RGBAImage = Qu, t.Ray = vl, t.RequestManager = class {
            constructor(t2, e2, r2) {
              this._transformRequestFn = t2, this._customAccessToken = e2, this._silenceAuthErrors = !!r2, this._createSkuToken();
            }
            _createSkuToken() {
              const t2 = function() {
                let t3 = "";
                for (let e2 = 0; e2 < 10; e2++)
                  t3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                return { token: ["1", h, t3].join(""), tokenExpiresAt: Date.now() + 432e5 };
              }();
              this._skuToken = t2.token, this._skuTokenExpiresAt = t2.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
              return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(t2, e2) {
              return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
            }
            normalizeStyleURL(t2, e2) {
              if (!mt(t2))
                return t2;
              const r2 = _t(t2);
              return r2.path = `/styles/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || e2);
            }
            normalizeGlyphsURL(t2, e2) {
              if (!mt(t2))
                return t2;
              const r2 = _t(t2);
              return r2.path = `/fonts/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || e2);
            }
            normalizeSourceURL(t2, e2, r2, n2) {
              if (!mt(t2))
                return t2;
              const i2 = _t(t2);
              return i2.path = `/v4/${i2.authority}.json`, i2.params.push("secure"), r2 && i2.params.push(`language=${r2}`), n2 && i2.params.push(`worldview=${n2}`), this._makeAPIURL(i2, this._customAccessToken || e2);
            }
            normalizeSpriteURL(t2, e2, r2, n2) {
              const i2 = _t(t2);
              return mt(t2) ? (i2.path = `/styles/v1${i2.path}/sprite${e2}${r2}`, this._makeAPIURL(i2, this._customAccessToken || n2)) : (i2.path += `${e2}${r2}`, At(i2));
            }
            normalizeTileURL(t2, e2, r2) {
              if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !mt(t2))
                return t2;
              const n2 = _t(t2);
              n2.path = n2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e2 || r2 && "raster" !== n2.authority && 512 === r2 ? "@2x" : ""}${s.supported ? ".webp" : "$1"}`), "raster" === n2.authority ? n2.path = `/${i.RASTER_URL_PREFIX}${n2.path}` : (n2.path = n2.path.replace(/^.+\/v4\//, "/"), n2.path = `/${i.TILE_URL_VERSION}${n2.path}`);
              const a2 = this._customAccessToken || function(t3) {
                for (const e3 of t3) {
                  const t4 = e3.match(/^access_token=(.*)$/);
                  if (t4)
                    return t4[1];
                }
                return null;
              }(n2.params) || i.ACCESS_TOKEN;
              return i.REQUIRE_ACCESS_TOKEN && a2 && this._skuToken && n2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n2, a2);
            }
            canonicalizeTileURL(t2, e2) {
              const r2 = _t(t2);
              if (!r2.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r2.path.match(/\.[\w]+$/))
                return t2;
              let n2 = "mapbox://";
              r2.path.match(/^\/raster\/v1\//) ? n2 += `raster/${r2.path.replace(`/${i.RASTER_URL_PREFIX}/`, "")}` : n2 += `tiles/${r2.path.replace(`/${i.TILE_URL_VERSION}/`, "")}`;
              let s2 = r2.params;
              return e2 && (s2 = s2.filter((t3) => !t3.match(/^access_token=/))), s2.length && (n2 += `?${s2.join("&")}`), n2;
            }
            canonicalizeTileset(t2, e2) {
              const r2 = !!e2 && mt(e2), n2 = [];
              for (const e3 of t2.tiles || [])
                gt(e3) ? n2.push(this.canonicalizeTileURL(e3, r2)) : n2.push(e3);
              return n2;
            }
            _makeAPIURL(t2, e2) {
              const r2 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n2 = _t(i.API_URL);
              if (t2.protocol = n2.protocol, t2.authority = n2.authority, "http" === t2.protocol) {
                const e3 = t2.params.indexOf("secure");
                e3 >= 0 && t2.params.splice(e3, 1);
              }
              if ("/" !== n2.path && (t2.path = `${n2.path}${t2.path}`), !i.REQUIRE_ACCESS_TOKEN)
                return At(t2);
              if (e2 = e2 || i.ACCESS_TOKEN, !this._silenceAuthErrors) {
                if (!e2)
                  throw new Error(`An API access token is required to use Mapbox GL. ${r2}`);
                if ("s" === e2[0])
                  throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r2}`);
              }
              return t2.params = t2.params.filter((t3) => -1 === t3.indexOf("access_token")), t2.params.push(`access_token=${e2 || ""}`), At(t2);
            }
          }, t.ResourceType = st, t.SegmentVector = So, t.SourceCache = sy, t.StencilMode = ty, t.StructArrayLayout1ui2 = Ta, t.StructArrayLayout2f1f2i16 = xa, t.StructArrayLayout2i4 = sa, t.StructArrayLayout2ui4 = Ma, t.StructArrayLayout3f12 = ba, t.StructArrayLayout3ui6 = wa, t.StructArrayLayout4i8 = oa, t.StructArrayLayout5f20 = ka, t.Texture = _d, t.Tile = Fd, t.Transitionable = qs, t.Uniform1f = to, t.Uniform1i = class extends Qa {
            constructor(t2) {
              super(t2), this.current = 0;
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1i(this.location, r2));
            }
          }, t.Uniform2f = class extends Qa {
            constructor(t2) {
              super(t2), this.current = [0, 0];
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] || (this.current = r2, this.gl.uniform2f(this.location, r2[0], r2[1])));
            }
          }, t.Uniform3f = class extends Qa {
            constructor(t2) {
              super(t2), this.current = [0, 0, 0];
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] || (this.current = r2, this.gl.uniform3f(this.location, r2[0], r2[1], r2[2])));
            }
          }, t.Uniform4f = eo, t.UniformColor = ro, t.UniformMatrix2f = class extends Qa {
            constructor(t2) {
              super(t2), this.current = so;
            }
            set(t2, e2, r2) {
              if (this.fetchUniformLocation(t2, e2)) {
                for (let t3 = 0; t3 < 4; t3++)
                  if (r2[t3] !== this.current[t3]) {
                    this.current = r2, this.gl.uniformMatrix2fv(this.location, false, r2);
                    break;
                  }
              }
            }
          }, t.UniformMatrix3f = class extends Qa {
            constructor(t2) {
              super(t2), this.current = io;
            }
            set(t2, e2, r2) {
              if (this.fetchUniformLocation(t2, e2)) {
                for (let t3 = 0; t3 < 9; t3++)
                  if (r2[t3] !== this.current[t3]) {
                    this.current = r2, this.gl.uniformMatrix3fv(this.location, false, r2);
                    break;
                  }
              }
            }
          }, t.UniformMatrix4f = class extends Qa {
            constructor(t2) {
              super(t2), this.current = no;
            }
            set(t2, e2, r2) {
              if (this.fetchUniformLocation(t2, e2)) {
                if (r2[12] !== this.current[12] || r2[0] !== this.current[0])
                  return this.current = r2, void this.gl.uniformMatrix4fv(this.location, false, r2);
                for (let t3 = 1; t3 < 16; t3++)
                  if (r2[t3] !== this.current[t3]) {
                    this.current = r2, this.gl.uniformMatrix4fv(this.location, false, r2);
                    break;
                  }
              }
            }
          }, t.UnwrappedTileID = Ih, t.ValidationError = Wn, t.VectorTileFeature = ah, t.VectorTileWorkerSource = class extends Yt {
            constructor(t2, e2, r2, n2, i2) {
              super(), this.actor = t2, this.layerIndex = e2, this.availableImages = r2, this.loadVectorData = i2 || xy, this.loading = {}, this.loaded = {}, this.deduped = new gy(t2.scheduler), this.isSpriteLoaded = n2, this.scheduler = t2.scheduler;
            }
            loadTile(t2, e2) {
              const r2 = t2.uid, n2 = t2 && t2.request, i2 = n2 && n2.collectResourceTiming, s2 = this.loading[r2] = new yy(t2);
              s2.abort = this.loadVectorData(t2, (a2, o2) => {
                const l2 = !this.loading[r2];
                if (delete this.loading[r2], l2 || a2 || !o2)
                  return s2.status = "done", l2 || (this.loaded[r2] = s2), e2(a2);
                const u2 = o2.rawData, c2 = {};
                o2.expires && (c2.expires = o2.expires), o2.cacheControl && (c2.cacheControl = o2.cacheControl), s2.vectorTile = o2.vectorTile || new sh(new op(u2));
                const h2 = () => {
                  s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t3, r3) => {
                    if (t3 || !r3)
                      return e2(t3);
                    const s3 = {};
                    if (i2) {
                      const t4 = jt(n2);
                      t4.length > 0 && (s3.resourceTiming = JSON.parse(JSON.stringify(t4)));
                    }
                    e2(null, z({ rawTileData: u2.slice(0) }, r3, c2, s3));
                  });
                };
                this.isSpriteLoaded ? h2() : this.once("isSpriteLoaded", () => {
                  this.scheduler ? this.scheduler.add(h2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }) : h2();
                }), this.loaded = this.loaded || {}, this.loaded[r2] = s2;
              });
            }
            reloadTile(t2, e2) {
              const r2 = this.loaded, n2 = t2.uid, i2 = this;
              if (r2 && r2[n2]) {
                const s2 = r2[n2];
                s2.showCollisionBoxes = t2.showCollisionBoxes, s2.enableTerrain = !!t2.enableTerrain, s2.projection = t2.projection, s2.tileTransform = Vf(t2.tileID.canonical, t2.projection);
                const a2 = (t3, r3) => {
                  const n3 = s2.reloadCallback;
                  n3 && (delete s2.reloadCallback, s2.parse(s2.vectorTile, i2.layerIndex, this.availableImages, i2.actor, n3)), e2(t3, r3);
                };
                "parsing" === s2.status ? s2.reloadCallback = a2 : "done" === s2.status && (s2.vectorTile ? s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, a2) : a2());
              }
            }
            abortTile(t2, e2) {
              const r2 = t2.uid, n2 = this.loading[r2];
              n2 && (n2.abort && n2.abort(), delete this.loading[r2]), e2();
            }
            removeTile(t2, e2) {
              const r2 = this.loaded, n2 = t2.uid;
              r2 && r2[n2] && delete r2[n2], e2();
            }
          }, t.WritingMode = Vp, t.ZoomDependentExpression = Xn, t.add = Go, t.addDynamicAttributes = od, t.adjoint = function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8];
            return t2[0] = a2 * c2 - o2 * u2, t2[1] = i2 * u2 - n2 * c2, t2[2] = n2 * o2 - i2 * a2, t2[3] = o2 * l2 - s2 * c2, t2[4] = r2 * c2 - i2 * l2, t2[5] = i2 * s2 - r2 * o2, t2[6] = s2 * u2 - a2 * l2, t2[7] = n2 * l2 - r2 * u2, t2[8] = r2 * a2 - n2 * s2, t2;
          }, t.asyncAll = M, t.bezier = _, t.bindAll = V, t.boundsAttributes = Vd, t.bufferConvexPolygon = function(t2, e2) {
            const r2 = [];
            for (let n2 = 0; n2 < t2.length; n2++) {
              const i2 = I(n2 - 1, -1, t2.length - 1), s2 = I(n2 + 1, -1, t2.length - 1), a2 = t2[n2], o2 = t2[s2], l2 = t2[i2].sub(a2).unit(), u2 = o2.sub(a2).unit(), c2 = u2.angleWithSep(l2.x, l2.y), h2 = l2.add(u2).unit().mult(-1 * e2 / Math.sin(c2 / 2));
              r2.push(a2.add(h2));
            }
            return r2;
          }, t.cacheEntryPossiblyAdded = function(t2) {
            it++, it > tt && (t2.getActor().send("enforceCacheSizeLimit", Q), it = 0);
          }, t.calculateGlobeLabelMatrix = function(t2, e2) {
            const { x: r2, y: n2 } = t2.point, i2 = Xl(r2, n2, t2.worldSize / t2._pixelsPerMercatorPixel, 0, 0);
            return Po(i2, i2, Zl(Pl(e2)));
          }, t.calculateGlobeMatrix = function(t2) {
            const { x: e2, y: r2 } = t2.point, { lng: n2, lat: i2 } = t2._center;
            return Xl(e2, r2, t2.worldSize, n2, i2);
          }, t.calculateGlobeMercatorMatrix = function(t2) {
            const e2 = t2.pixelsPerMeter, r2 = e2 / au(1, t2.center.lat), n2 = Eo(new Float64Array(16));
            return Do(n2, n2, [t2.point.x, t2.point.y, 0]), Vo(n2, n2, [r2, r2, e2]), Float32Array.from(n2);
          }, t.circumferenceAtLatitude = nu, t.clamp = S, t.clearTileCache = function(t2) {
            if (!et())
              return;
            const r2 = e.caches.delete(H);
            t2 && r2.catch(t2).then(() => t2());
          }, t.clipLine = sf, t.clone = function(t2) {
            var e2 = new To(16);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
          }, t.clone$1 = j, t.collisionCircleLayout = Hh, t.config = i, t.conjugate = function(t2, e2) {
            return t2[0] = -e2[0], t2[1] = -e2[1], t2[2] = -e2[2], t2[3] = e2[3], t2;
          }, t.create = function() {
            var t2 = new To(16);
            return To != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
          }, t.create$1 = zo, t.createExpression = Gn, t.createLayout = na, t.createStyleLayer = function(t2) {
            return "custom" === t2.type ? new xd(t2) : new wd[t2.type](t2);
          }, t.cross = tl, t.degToRad = x, t.distance = function(t2, e2) {
            return Math.hypot(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
          }, t.div = function(t2, e2, r2) {
            return t2[0] = e2[0] / r2[0], t2[1] = e2[1] / r2[1], t2[2] = e2[2] / r2[2], t2;
          }, t.dot = Qo, t.earthRadius = tu, t.ease = A, t.easeCubicInOut = w, t.ecefToLatLng = function([t2, e2, r2]) {
            const n2 = Math.hypot(t2, e2, r2), i2 = Math.atan2(t2, r2), s2 = 0.5 * Math.PI - Math.acos(-e2 / n2);
            return new ru(v(i2), v(s2));
          }, t.emitValidationErrors = Ri, t.endsWith = L, t.enforceCacheSizeLimit = function(t2) {
            rt(), W && W.then((e2) => {
              e2.keys().then((r2) => {
                for (let n2 = 0; n2 < r2.length - t2; n2++)
                  e2.delete(r2[n2]);
              });
            });
          }, t.evaluateSizeForFeature = tp, t.evaluateSizeForZoom = ep, t.evaluateVariableOffset = Sf, t.evented = Ls, t.exactEquals = function(t2, e2) {
            return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3];
          }, t.exactEquals$1 = function(t2, e2) {
            return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2];
          }, t.exported = Nt, t.exported$1 = s, t.extend = z, t.extend$1 = Wt, t.fillExtrusionHeightLift = bh, t.filterObject = R, t.fromMat4 = function(t2, e2) {
            return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[4], t2[4] = e2[5], t2[5] = e2[6], t2[6] = e2[8], t2[7] = e2[9], t2[8] = e2[10], t2;
          }, t.fromQuat = function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r2 + r2, o2 = n2 + n2, l2 = i2 + i2, u2 = r2 * a2, c2 = n2 * a2, h2 = n2 * o2, p2 = i2 * a2, f2 = i2 * o2, d2 = i2 * l2, y2 = s2 * a2, m2 = s2 * o2, g2 = s2 * l2;
            return t2[0] = 1 - h2 - d2, t2[1] = c2 + g2, t2[2] = p2 - m2, t2[3] = 0, t2[4] = c2 - g2, t2[5] = 1 - u2 - d2, t2[6] = f2 + y2, t2[7] = 0, t2[8] = p2 + m2, t2[9] = f2 - y2, t2[10] = 1 - u2 - h2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }, t.fromRotation = function(t2, e2) {
            var r2 = Math.sin(e2), n2 = Math.cos(e2);
            return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
          }, t.fromScaling = Ro, t.furthestTileCorner = function(t2) {
            const e2 = Math.round((t2 + 45 + 360) % 360 / 90) % 4;
            return b[e2];
          }, t.getAABBPointSquareDist = function(t2, e2, r2) {
            let n2 = 0;
            for (let i2 = 0; i2 < 2; ++i2) {
              const s2 = r2 ? r2[i2] : 0;
              t2[i2] > s2 && (n2 += (t2[i2] - s2) * (t2[i2] - s2)), e2[i2] < s2 && (n2 += (s2 - e2[i2]) * (s2 - e2[i2]));
            }
            return n2;
          }, t.getAnchorAlignment = Zp, t.getAnchorJustification = If, t.getBounds = function(t2) {
            let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
            for (const s2 of t2)
              e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
            return { min: new d(e2, r2), max: new d(n2, i2) };
          }, t.getColumn = Y, t.getGridMatrix = function(t2, e2, r2, n2) {
            const i2 = e2.getNorth(), s2 = e2.getSouth(), a2 = e2.getWest(), o2 = e2.getEast(), l2 = 1 << t2.z, u2 = o2 - a2, c2 = i2 - s2, h2 = u2 / Sl, p2 = -c2 / kl[r2], f2 = [0, h2, 0, p2, 0, 0, i2, a2, 0];
            if (t2.z > 0) {
              const t3 = 180 / n2;
              Bo(f2, f2, [t3 / u2 + 1, 0, 0, 0, t3 / c2 + 1, 0, -0.5 * t3 / h2, 0.5 * t3 / p2, 1]);
            }
            return f2[2] = l2, f2[5] = t2.x, f2[8] = t2.y, f2;
          }, t.getImage = dt, t.getJSON = function(t2, e2) {
            return lt(z(t2, { type: "json" }), e2);
          }, t.getLatitudinalLod = function(t2) {
            const e2 = cu - 5;
            t2 = S(t2, -e2, e2) / e2 * 90;
            const r2 = Math.pow(Math.abs(Math.sin(x(t2))), 3);
            return Math.round(r2 * (kl.length - 1));
          }, t.getMapSessionAPI = Pt, t.getPerformanceMeasurement = jt, t.getProjection = rd, t.getRTLTextPluginStatus = Fs, t.getReferrer = ot, t.getTilePoint = function(t2, { x: e2, y: r2 }, n2 = 0) {
            return new d(((e2 - n2) * t2.scale - t2.x) * ko, (r2 * t2.scale - t2.y) * ko);
          }, t.getTileVec3 = function(t2, e2, r2 = 0) {
            return No(((e2.x - r2) * t2.scale - t2.x) * ko, (e2.y * t2.scale - t2.y) * ko, uu(e2.z, e2.y));
          }, t.getVideo = function(t2, r2) {
            const n2 = e.document.createElement("video");
            n2.muted = true, n2.onloadstart = function() {
              r2(null, n2);
            };
            for (let r3 = 0; r3 < t2.length; r3++) {
              const i2 = e.document.createElement("source");
              ct(t2[r3]) || (n2.crossOrigin = "Anonymous"), i2.src = t2[r3], n2.appendChild(i2);
            }
            return { cancel: () => {
            } };
          }, t.globeCenterToScreenPoint = function(t2) {
            const e2 = [0, 0, 0], r2 = Eo(new Float64Array(16));
            return Po(r2, t2.pixelMatrix, t2.globeMatrix), el(e2, e2, r2), new d(e2[0], e2[1]);
          }, t.globeDenormalizeECEF = Zl, t.globeECEFOrigin = function(t2, e2) {
            const r2 = [0, 0, 0];
            return el(r2, r2, Gl(Pl(e2.canonical))), el(r2, r2, t2), r2;
          }, t.globeMetersToEcef = zl, t.globeNormalizeECEF = Gl, t.globePixelsToTileUnits = function(t2, e2) {
            return ko / (512 * Math.pow(2, t2)) * ql(Pl(e2));
          }, t.globePoleMatrixForTile = function(t2, e2, r2) {
            const n2 = Eo(new Float64Array(16)), i2 = (e2 / (1 << t2) - 0.5) * Math.PI * 2;
            return Fo(n2, r2.globeMatrix, i2), Float32Array.from(n2);
          }, t.globeTileBounds = Pl, t.globeTiltAtLngLat = Yl, t.globeToMercatorTransition = Kl, t.globeUseCustomAntiAliasing = function(t2, e2, r2) {
            const n2 = Kl(r2.zoom), i2 = t2.style.map._antialias, s2 = !!e2.extStandardDerivatives, a2 = e2.extStandardDerivativesForceOff || t2.terrain && t2.terrain.exaggeration() > 0;
            return 0 === n2 && !i2 && !a2 && s2;
          }, t.identity = Eo, t.identity$1 = hl, t.invert = Co, t.isFullscreen = function() {
            return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement;
          }, t.isLngLatBehindGlobe = Hl, t.isMapAuthenticated = function(t2) {
            return Dt.has(t2);
          }, t.isMapboxURL = mt, t.isSafariWithAntialiasingBug = function(t2) {
            const e2 = t2.navigator ? t2.navigator.userAgent : null;
            return !!X(t2) && e2 && (e2.match("Version/15.4") || e2.match("Version/15.5") || e2.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
          }, t.latFromMercatorY = lu, t.latLngToECEF = Ul, t.len = al, t.length = qo, t.length$1 = function(t2) {
            return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
          }, t.lngFromMercatorX = ou, t.loadVectorTile = xy, t.makeRequest = lt, t.mapValue = function(t2, e2, r2, n2, i2) {
            return S((t2 - e2) / (r2 - e2) * (i2 - n2) + n2, n2, i2);
          }, t.mercatorScale = hu, t.mercatorXfromLng = iu, t.mercatorYfromLat = su, t.mercatorZfromAltitude = au, t.mul = $o, t.mul$1 = sl, t.multiply = Po, t.multiply$1 = Bo, t.multiply$2 = Xo, t.nextPowerOfTwo = P, t.normalize = Jo, t.normalize$1 = dl, t.normalize$2 = ll, t.number = Mr, t.ortho = function(t2, e2, r2, n2, i2, s2, a2) {
            var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
            return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
          }, t.pbf = op, t.perspective = function(t2, e2, r2, n2, i2) {
            var s2, a2 = 1 / Math.tan(e2 / 2);
            return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
          }, t.pick = function(t2, e2) {
            const r2 = {};
            for (let n2 = 0; n2 < e2.length; n2++) {
              const i2 = e2[n2];
              i2 in t2 && (r2[i2] = t2[i2]);
            }
            return r2;
          }, t.plugin = js, t.pointGeometry = d, t.polesInViewport = function(t2) {
            const e2 = Eo(new Float64Array(16));
            Po(e2, t2.pixelMatrix, t2.globeMatrix);
            const r2 = [0, Il, 0], n2 = [0, Ml, 0];
            return el(r2, r2, e2), el(n2, n2, e2), [r2[0] > 0 && r2[0] <= t2.width && r2[1] > 0 && r2[1] <= t2.height && !Hl(t2, new ru(t2.center.lat, 90)), n2[0] > 0 && n2[0] <= t2.width && n2[1] > 0 && n2[1] <= t2.height && !Hl(t2, new ru(t2.center.lat, -90))];
          }, t.polygonContainsPoint = Du, t.polygonIntersectsBox = Vu, t.polygonIntersectsPolygon = ku, t.polygonizeBounds = function(t2, e2, r2 = 0, n2 = true) {
            const i2 = new d(r2, r2), s2 = t2.sub(i2), a2 = e2.add(i2), o2 = [s2, new d(a2.x, s2.y), a2, new d(s2.x, a2.y)];
            return n2 && o2.push(s2.clone()), o2;
          }, t.posAttributes = xl, t.postMapLoadEvent = zt, t.postPerformanceEvent = Et, t.postTurnstileEvent = Mt, t.potpack = Cp, t.prevPowerOfTwo = function(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
          }, t.radToDeg = v, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.registerForPluginStateChange = function(t2) {
            return t2({ pluginStatus: Cs, pluginURL: Ps }), Ls.on("pluginStateChange", t2), t2;
          }, t.removeAuthState = function(t2) {
            Dt.delete(t2);
          }, t.renderColorRamp = ec, t.resample = du, t.rotateX = Lo, t.rotateX$1 = pl, t.rotateY = Fo, t.rotateY$1 = fl, t.rotateZ = function(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
            return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
          }, t.rotateZ$1 = function(t2, e2, r2) {
            r2 *= 0.5;
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
            return t2[0] = n2 * l2 + i2 * o2, t2[1] = i2 * l2 - n2 * o2, t2[2] = s2 * l2 + a2 * o2, t2[3] = a2 * l2 - s2 * o2, t2;
          }, t.scale = Vo, t.scale$1 = ol, t.scale$2 = Ho, t.scaleAndAdd = Wo, t.set = function(t2, e2, r2, n2) {
            return t2[0] = e2, t2[1] = r2, t2[2] = n2, t2;
          }, t.setCacheLimits = function(t2, e2) {
            Q = t2, tt = e2;
          }, t.setColumn = function(t2, e2, r2) {
            t2[4 * e2 + 0] = r2[0], t2[4 * e2 + 1] = r2[1], t2[4 * e2 + 2] = r2[2], t2[4 * e2 + 3] = r2[3];
          }, t.setRTLTextPlugin = function(t2, e2, r2 = false) {
            if (Cs === Ts || Cs === zs || Cs === Bs)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Ps = Nt.resolveURL(t2), Cs = Ts, Es = e2, Vs(), r2 || Rs();
          }, t.smoothstep = k, t.spec = Ht, t.squaredLength = function(t2) {
            var e2 = t2[0], r2 = t2[1], n2 = t2[2];
            return e2 * e2 + r2 * r2 + n2 * n2;
          }, t.storeAuthState = function(t2, e2) {
            e2 ? Dt.add(t2) : Dt.delete(t2);
          }, t.sub = il, t.subtract = Zo, t.symbolSize = rp, t.tileAABB = function(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            if ("globe" === l2.name)
              return Fl(t2, e2, new kh(r2, n2, i2));
            const u2 = Vf({ z: r2, x: n2, y: i2 }, l2);
            return new _l([(s2 + u2.x / u2.scale) * e2, e2 * (u2.y / u2.scale), a2], [(s2 + u2.x2 / u2.scale) * e2, e2 * (u2.y2 / u2.scale), o2]);
          }, t.tileCornersToBounds = Rl, t.tileTransform = Vf, t.transformMat3 = function(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2];
            return t2[0] = n2 * r2[0] + i2 * r2[3] + s2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + s2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + s2 * r2[8], t2;
          }, t.transformMat4 = el, t.transformMat4$1 = ul, t.transformQuat = rl, t.transitionTileAABBinECEF = Vl, t.translate = Do, t.transpose = function(t2, e2) {
            if (t2 === e2) {
              var r2 = e2[1], n2 = e2[2], i2 = e2[5];
              t2[1] = e2[3], t2[2] = e2[6], t2[3] = r2, t2[5] = e2[7], t2[6] = n2, t2[7] = i2;
            } else
              t2[0] = e2[0], t2[1] = e2[3], t2[2] = e2[6], t2[3] = e2[1], t2[4] = e2[4], t2[5] = e2[7], t2[6] = e2[2], t2[7] = e2[5], t2[8] = e2[8];
            return t2;
          }, t.triggerPluginCompletionEvent = Ds, t.uniqueId = E, t.updateGlobeVertexNormal = function(t2, e2, r2, n2, i2) {
            const s2 = 5 * e2 + 2;
            t2.float32[s2 + 0] = r2, t2.float32[s2 + 1] = n2, t2.float32[s2 + 2] = i2;
          }, t.validateCustomStyleLayer = function(t2) {
            const e2 = [], r2 = t2.id;
            return void 0 === r2 && e2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
          }, t.validateFilter = (t2) => Fi(xi(t2)), t.validateFog = (t2) => Fi(Bi(t2)), t.validateLayer = (t2) => Fi(Ai(t2)), t.validateLight = (t2) => Fi(Ti(t2)), t.validateSource = (t2) => Fi(Ii(t2)), t.validateStyle = Di, t.validateTerrain = (t2) => Fi(zi(t2)), t.values = T, t.vectorTile = Xc, t.version = r, t.warnOnce = U, t.window = e, t.wrap = I;
        });
        define2(["./shared"], function(e) {
          "use strict";
          function t(e2) {
            if ("number" == typeof e2 || "boolean" == typeof e2 || "string" == typeof e2 || null == e2)
              return JSON.stringify(e2);
            if (Array.isArray(e2)) {
              let r3 = "[";
              for (const o2 of e2)
                r3 += `${t(o2)},`;
              return `${r3}]`;
            }
            let r2 = "{";
            for (const o2 of Object.keys(e2).sort())
              r2 += `${o2}:${t(e2[o2])},`;
            return `${r2}}`;
          }
          function r(r2) {
            let o2 = "";
            for (const n2 of e.refProperties)
              o2 += `/${t(r2[n2])}`;
            return o2;
          }
          class o {
            constructor(e2) {
              this.keyCache = {}, e2 && this.replace(e2);
            }
            replace(e2) {
              this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
            }
            update(t2, o2) {
              for (const r2 of t2)
                this._layerConfigs[r2.id] = r2, (this._layers[r2.id] = e.createStyleLayer(r2)).compileFilter(), this.keyCache[r2.id] && delete this.keyCache[r2.id];
              for (const e2 of o2)
                delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
              this.familiesBySource = {};
              const n2 = function(e2, t3) {
                const o3 = {};
                for (let n4 = 0; n4 < e2.length; n4++) {
                  const i2 = t3 && t3[e2[n4].id] || r(e2[n4]);
                  t3 && (t3[e2[n4].id] = i2);
                  let s2 = o3[i2];
                  s2 || (s2 = o3[i2] = []), s2.push(e2[n4]);
                }
                const n3 = [];
                for (const e3 in o3)
                  n3.push(o3[e3]);
                return n3;
              }(e.values(this._layerConfigs), this.keyCache);
              for (const e2 of n2) {
                const t3 = e2.map((e3) => this._layers[e3.id]), r2 = t3[0];
                if ("none" === r2.visibility)
                  continue;
                const o3 = r2.source || "";
                let n3 = this.familiesBySource[o3];
                n3 || (n3 = this.familiesBySource[o3] = {});
                const i2 = r2.sourceLayer || "_geojsonTileLayer";
                let s2 = n3[i2];
                s2 || (s2 = n3[i2] = []), s2.push(t3);
              }
            }
          }
          class n {
            loadTile(t2, r2) {
              const { uid: o2, encoding: n2, rawImageData: i2, padding: s2, buildQuadTree: a2 } = t2, l2 = e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap ? this.getImageData(i2, s2) : i2;
              r2(null, new e.DEMData(o2, l2, n2, s2 < 1, a2));
            }
            getImageData(e2, t2) {
              this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e2.width, e2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e2.width, this.offscreenCanvas.height = e2.height, this.offscreenCanvasContext.drawImage(e2, 0, 0, e2.width, e2.height);
              const r2 = this.offscreenCanvasContext.getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
              return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r2;
            }
          }
          var i = function e2(t2, r2) {
            var o2, n2 = t2 && t2.type;
            if ("FeatureCollection" === n2)
              for (o2 = 0; o2 < t2.features.length; o2++)
                e2(t2.features[o2], r2);
            else if ("GeometryCollection" === n2)
              for (o2 = 0; o2 < t2.geometries.length; o2++)
                e2(t2.geometries[o2], r2);
            else if ("Feature" === n2)
              e2(t2.geometry, r2);
            else if ("Polygon" === n2)
              s(t2.coordinates, r2);
            else if ("MultiPolygon" === n2)
              for (o2 = 0; o2 < t2.coordinates.length; o2++)
                s(t2.coordinates[o2], r2);
            return t2;
          };
          function s(e2, t2) {
            if (0 !== e2.length) {
              a(e2[0], t2);
              for (var r2 = 1; r2 < e2.length; r2++)
                a(e2[r2], !t2);
            }
          }
          function a(e2, t2) {
            for (var r2 = 0, o2 = 0, n2 = 0, i2 = e2.length, s2 = i2 - 1; n2 < i2; s2 = n2++) {
              var a2 = (e2[n2][0] - e2[s2][0]) * (e2[s2][1] + e2[n2][1]), l2 = r2 + a2;
              o2 += Math.abs(r2) >= Math.abs(a2) ? r2 - l2 + a2 : a2 - l2 + r2, r2 = l2;
            }
            r2 + o2 >= 0 != !!t2 && e2.reverse();
          }
          const l = e.VectorTileFeature.prototype.toGeoJSON;
          class u {
            constructor(t2) {
              this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
            }
            loadGeometry() {
              if (1 === this._feature.type) {
                const t2 = [];
                for (const r2 of this._feature.geometry)
                  t2.push([new e.pointGeometry(r2[0], r2[1])]);
                return t2;
              }
              {
                const t2 = [];
                for (const r2 of this._feature.geometry) {
                  const o2 = [];
                  for (const t3 of r2)
                    o2.push(new e.pointGeometry(t3[0], t3[1]));
                  t2.push(o2);
                }
                return t2;
              }
            }
            toGeoJSON(e2, t2, r2) {
              return l.call(this, e2, t2, r2);
            }
          }
          class h {
            constructor(t2) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
            }
            feature(e2) {
              return new u(this._features[e2]);
            }
          }
          var c = {}, f = { get exports() {
            return c;
          }, set exports(e2) {
            c = e2;
          } }, p = e.pointGeometry, g = e.vectorTile.VectorTileFeature, d = m;
          function m(e2, t2) {
            this.options = t2 || {}, this.features = e2, this.length = e2.length;
          }
          function y(e2, t2) {
            this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
          }
          m.prototype.feature = function(e2) {
            return new y(this.features[e2], this.options.extent);
          }, y.prototype.loadGeometry = function() {
            var e2 = this.rawGeometry;
            this.geometry = [];
            for (var t2 = 0; t2 < e2.length; t2++) {
              for (var r2 = e2[t2], o2 = [], n2 = 0; n2 < r2.length; n2++)
                o2.push(new p(r2[n2][0], r2[n2][1]));
              this.geometry.push(o2);
            }
            return this.geometry;
          }, y.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e2 = this.geometry, t2 = 1 / 0, r2 = -1 / 0, o2 = 1 / 0, n2 = -1 / 0, i2 = 0; i2 < e2.length; i2++)
              for (var s2 = e2[i2], a2 = 0; a2 < s2.length; a2++) {
                var l2 = s2[a2];
                t2 = Math.min(t2, l2.x), r2 = Math.max(r2, l2.x), o2 = Math.min(o2, l2.y), n2 = Math.max(n2, l2.y);
              }
            return [t2, o2, r2, n2];
          }, y.prototype.toGeoJSON = g.prototype.toGeoJSON;
          var v = e.pbf, x = d;
          function w(e2) {
            var t2 = new v();
            return function(e3, t3) {
              for (var r2 in e3.layers)
                t3.writeMessage(3, S, e3.layers[r2]);
            }(e2, t2), t2.finish();
          }
          function S(e2, t2) {
            var r2;
            t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
            var o2 = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (r2 = 0; r2 < e2.length; r2++)
              o2.feature = e2.feature(r2), t2.writeMessage(2, M, o2);
            var n2 = o2.keys;
            for (r2 = 0; r2 < n2.length; r2++)
              t2.writeStringField(3, n2[r2]);
            var i2 = o2.values;
            for (r2 = 0; r2 < i2.length; r2++)
              t2.writeMessage(4, T, i2[r2]);
          }
          function M(e2, t2) {
            var r2 = e2.feature;
            void 0 !== r2.id && t2.writeVarintField(1, r2.id), t2.writeMessage(2, P, e2), t2.writeVarintField(3, r2.type), t2.writeMessage(4, I, r2);
          }
          function P(e2, t2) {
            var r2 = e2.feature, o2 = e2.keys, n2 = e2.values, i2 = e2.keycache, s2 = e2.valuecache;
            for (var a2 in r2.properties) {
              var l2 = r2.properties[a2], u2 = i2[a2];
              if (null !== l2) {
                void 0 === u2 && (o2.push(a2), i2[a2] = u2 = o2.length - 1), t2.writeVarint(u2);
                var h2 = typeof l2;
                "string" !== h2 && "boolean" !== h2 && "number" !== h2 && (l2 = JSON.stringify(l2));
                var c2 = h2 + ":" + l2, f2 = s2[c2];
                void 0 === f2 && (n2.push(l2), s2[c2] = f2 = n2.length - 1), t2.writeVarint(f2);
              }
            }
          }
          function b(e2, t2) {
            return (t2 << 3) + (7 & e2);
          }
          function k(e2) {
            return e2 << 1 ^ e2 >> 31;
          }
          function I(e2, t2) {
            for (var r2 = e2.loadGeometry(), o2 = e2.type, n2 = 0, i2 = 0, s2 = r2.length, a2 = 0; a2 < s2; a2++) {
              var l2 = r2[a2], u2 = 1;
              1 === o2 && (u2 = l2.length), t2.writeVarint(b(1, u2));
              for (var h2 = 3 === o2 ? l2.length - 1 : l2.length, c2 = 0; c2 < h2; c2++) {
                1 === c2 && 1 !== o2 && t2.writeVarint(b(2, h2 - 1));
                var f2 = l2[c2].x - n2, p2 = l2[c2].y - i2;
                t2.writeVarint(k(f2)), t2.writeVarint(k(p2)), n2 += f2, i2 += p2;
              }
              3 === o2 && t2.writeVarint(b(7, 1));
            }
          }
          function T(e2, t2) {
            var r2 = typeof e2;
            "string" === r2 ? t2.writeStringField(1, e2) : "boolean" === r2 ? t2.writeBooleanField(7, e2) : "number" === r2 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
          }
          function _(e2, t2, r2, o2, n2, i2) {
            if (n2 - o2 <= r2)
              return;
            const s2 = o2 + n2 >> 1;
            L(e2, t2, s2, o2, n2, i2 % 2), _(e2, t2, r2, o2, s2 - 1, i2 + 1), _(e2, t2, r2, s2 + 1, n2, i2 + 1);
          }
          function L(e2, t2, r2, o2, n2, i2) {
            for (; n2 > o2; ) {
              if (n2 - o2 > 600) {
                const s3 = n2 - o2 + 1, a3 = r2 - o2 + 1, l3 = Math.log(s3), u2 = 0.5 * Math.exp(2 * l3 / 3), h2 = 0.5 * Math.sqrt(l3 * u2 * (s3 - u2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
                L(e2, t2, r2, Math.max(o2, Math.floor(r2 - a3 * u2 / s3 + h2)), Math.min(n2, Math.floor(r2 + (s3 - a3) * u2 / s3 + h2)), i2);
              }
              const s2 = t2[2 * r2 + i2];
              let a2 = o2, l2 = n2;
              for (C(e2, t2, o2, r2), t2[2 * n2 + i2] > s2 && C(e2, t2, o2, n2); a2 < l2; ) {
                for (C(e2, t2, a2, l2), a2++, l2--; t2[2 * a2 + i2] < s2; )
                  a2++;
                for (; t2[2 * l2 + i2] > s2; )
                  l2--;
              }
              t2[2 * o2 + i2] === s2 ? C(e2, t2, o2, l2) : (l2++, C(e2, t2, l2, n2)), l2 <= r2 && (o2 = l2 + 1), r2 <= l2 && (n2 = l2 - 1);
            }
          }
          function C(e2, t2, r2, o2) {
            O(e2, r2, o2), O(t2, 2 * r2, 2 * o2), O(t2, 2 * r2 + 1, 2 * o2 + 1);
          }
          function O(e2, t2, r2) {
            const o2 = e2[t2];
            e2[t2] = e2[r2], e2[r2] = o2;
          }
          function z(e2, t2, r2, o2) {
            const n2 = e2 - r2, i2 = t2 - o2;
            return n2 * n2 + i2 * i2;
          }
          f.exports = w, c.fromVectorTileJs = w, c.fromGeojsonVt = function(e2, t2) {
            t2 = t2 || {};
            var r2 = {};
            for (var o2 in e2)
              r2[o2] = new x(e2[o2].features, t2), r2[o2].name = o2, r2[o2].version = t2.version, r2[o2].extent = t2.extent;
            return w({ layers: r2 });
          }, c.GeoJSONWrapper = x;
          const E = (e2) => e2[0], F = (e2) => e2[1];
          class N {
            constructor(e2, t2 = E, r2 = F, o2 = 64, n2 = Float64Array) {
              this.nodeSize = o2, this.points = e2;
              const i2 = e2.length < 65536 ? Uint16Array : Uint32Array, s2 = this.ids = new i2(e2.length), a2 = this.coords = new n2(2 * e2.length);
              for (let o3 = 0; o3 < e2.length; o3++)
                s2[o3] = o3, a2[2 * o3] = t2(e2[o3]), a2[2 * o3 + 1] = r2(e2[o3]);
              _(s2, a2, o2, 0, s2.length - 1, 0);
            }
            range(e2, t2, r2, o2) {
              return function(e3, t3, r3, o3, n2, i2, s2) {
                const a2 = [0, e3.length - 1, 0], l2 = [];
                let u2, h2;
                for (; a2.length; ) {
                  const c2 = a2.pop(), f2 = a2.pop(), p2 = a2.pop();
                  if (f2 - p2 <= s2) {
                    for (let s3 = p2; s3 <= f2; s3++)
                      u2 = t3[2 * s3], h2 = t3[2 * s3 + 1], u2 >= r3 && u2 <= n2 && h2 >= o3 && h2 <= i2 && l2.push(e3[s3]);
                    continue;
                  }
                  const g2 = Math.floor((p2 + f2) / 2);
                  u2 = t3[2 * g2], h2 = t3[2 * g2 + 1], u2 >= r3 && u2 <= n2 && h2 >= o3 && h2 <= i2 && l2.push(e3[g2]);
                  const d2 = (c2 + 1) % 2;
                  (0 === c2 ? r3 <= u2 : o3 <= h2) && (a2.push(p2), a2.push(g2 - 1), a2.push(d2)), (0 === c2 ? n2 >= u2 : i2 >= h2) && (a2.push(g2 + 1), a2.push(f2), a2.push(d2));
                }
                return l2;
              }(this.ids, this.coords, e2, t2, r2, o2, this.nodeSize);
            }
            within(e2, t2, r2) {
              return function(e3, t3, r3, o2, n2, i2) {
                const s2 = [0, e3.length - 1, 0], a2 = [], l2 = n2 * n2;
                for (; s2.length; ) {
                  const u2 = s2.pop(), h2 = s2.pop(), c2 = s2.pop();
                  if (h2 - c2 <= i2) {
                    for (let n3 = c2; n3 <= h2; n3++)
                      z(t3[2 * n3], t3[2 * n3 + 1], r3, o2) <= l2 && a2.push(e3[n3]);
                    continue;
                  }
                  const f2 = Math.floor((c2 + h2) / 2), p2 = t3[2 * f2], g2 = t3[2 * f2 + 1];
                  z(p2, g2, r3, o2) <= l2 && a2.push(e3[f2]);
                  const d2 = (u2 + 1) % 2;
                  (0 === u2 ? r3 - n2 <= p2 : o2 - n2 <= g2) && (s2.push(c2), s2.push(f2 - 1), s2.push(d2)), (0 === u2 ? r3 + n2 >= p2 : o2 + n2 >= g2) && (s2.push(f2 + 1), s2.push(h2), s2.push(d2));
                }
                return a2;
              }(this.ids, this.coords, e2, t2, r2, this.nodeSize);
            }
          }
          const j = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, Z = Math.fround || (G = new Float32Array(1), (e2) => (G[0] = +e2, G[0]));
          var G;
          class J {
            constructor(e2) {
              this.options = B(Object.create(j), e2), this.trees = new Array(this.options.maxZoom + 1);
            }
            load(e2) {
              const { log: t2, minZoom: r2, maxZoom: o2, nodeSize: n2 } = this.options;
              t2 && console.time("total time");
              const i2 = `prepare ${e2.length} points`;
              t2 && console.time(i2), this.points = e2;
              let s2 = [];
              for (let t3 = 0; t3 < e2.length; t3++)
                e2[t3].geometry && s2.push(Y(e2[t3], t3));
              this.trees[o2 + 1] = new N(s2, R, q, n2, Float32Array), t2 && console.timeEnd(i2);
              for (let e3 = o2; e3 >= r2; e3--) {
                const r3 = +Date.now();
                s2 = this._cluster(s2, e3), this.trees[e3] = new N(s2, R, q, n2, Float32Array), t2 && console.log("z%d: %d clusters in %dms", e3, s2.length, +Date.now() - r3);
              }
              return t2 && console.timeEnd("total time"), this;
            }
            getClusters(e2, t2) {
              let r2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
              const o2 = Math.max(-90, Math.min(90, e2[1]));
              let n2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
              const i2 = Math.max(-90, Math.min(90, e2[3]));
              if (e2[2] - e2[0] >= 360)
                r2 = -180, n2 = 180;
              else if (r2 > n2) {
                const e3 = this.getClusters([r2, o2, 180, i2], t2), s3 = this.getClusters([-180, o2, n2, i2], t2);
                return e3.concat(s3);
              }
              const s2 = this.trees[this._limitZoom(t2)], a2 = s2.range(A(r2), D(i2), A(n2), D(o2)), l2 = [];
              for (const e3 of a2) {
                const t3 = s2.points[e3];
                l2.push(t3.numPoints ? X(t3) : this.points[t3.index]);
              }
              return l2;
            }
            getChildren(e2) {
              const t2 = this._getOriginId(e2), r2 = this._getOriginZoom(e2), o2 = "No cluster with the specified id.", n2 = this.trees[r2];
              if (!n2)
                throw new Error(o2);
              const i2 = n2.points[t2];
              if (!i2)
                throw new Error(o2);
              const s2 = this.options.radius / (this.options.extent * Math.pow(2, r2 - 1)), a2 = n2.within(i2.x, i2.y, s2), l2 = [];
              for (const t3 of a2) {
                const r3 = n2.points[t3];
                r3.parentId === e2 && l2.push(r3.numPoints ? X(r3) : this.points[r3.index]);
              }
              if (0 === l2.length)
                throw new Error(o2);
              return l2;
            }
            getLeaves(e2, t2, r2) {
              const o2 = [];
              return this._appendLeaves(o2, e2, t2 = t2 || 10, r2 = r2 || 0, 0), o2;
            }
            getTile(e2, t2, r2) {
              const o2 = this.trees[this._limitZoom(e2)], n2 = Math.pow(2, e2), { extent: i2, radius: s2 } = this.options, a2 = s2 / i2, l2 = (r2 - a2) / n2, u2 = (r2 + 1 + a2) / n2, h2 = { features: [] };
              return this._addTileFeatures(o2.range((t2 - a2) / n2, l2, (t2 + 1 + a2) / n2, u2), o2.points, t2, r2, n2, h2), 0 === t2 && this._addTileFeatures(o2.range(1 - a2 / n2, l2, 1, u2), o2.points, n2, r2, n2, h2), t2 === n2 - 1 && this._addTileFeatures(o2.range(0, l2, a2 / n2, u2), o2.points, -1, r2, n2, h2), h2.features.length ? h2 : null;
            }
            getClusterExpansionZoom(e2) {
              let t2 = this._getOriginZoom(e2) - 1;
              for (; t2 <= this.options.maxZoom; ) {
                const r2 = this.getChildren(e2);
                if (t2++, 1 !== r2.length)
                  break;
                e2 = r2[0].properties.cluster_id;
              }
              return t2;
            }
            _appendLeaves(e2, t2, r2, o2, n2) {
              const i2 = this.getChildren(t2);
              for (const t3 of i2) {
                const i3 = t3.properties;
                if (i3 && i3.cluster ? n2 + i3.point_count <= o2 ? n2 += i3.point_count : n2 = this._appendLeaves(e2, i3.cluster_id, r2, o2, n2) : n2 < o2 ? n2++ : e2.push(t3), e2.length === r2)
                  break;
              }
              return n2;
            }
            _addTileFeatures(e2, t2, r2, o2, n2, i2) {
              for (const s2 of e2) {
                const e3 = t2[s2], a2 = e3.numPoints;
                let l2, u2, h2;
                if (a2)
                  l2 = V(e3), u2 = e3.x, h2 = e3.y;
                else {
                  const t3 = this.points[e3.index];
                  l2 = t3.properties, u2 = A(t3.geometry.coordinates[0]), h2 = D(t3.geometry.coordinates[1]);
                }
                const c2 = { type: 1, geometry: [[Math.round(this.options.extent * (u2 * n2 - r2)), Math.round(this.options.extent * (h2 * n2 - o2))]], tags: l2 };
                let f2;
                a2 ? f2 = e3.id : this.options.generateId ? f2 = e3.index : this.points[e3.index].id && (f2 = this.points[e3.index].id), void 0 !== f2 && (c2.id = f2), i2.features.push(c2);
              }
            }
            _limitZoom(e2) {
              return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
            }
            _cluster(e2, t2) {
              const r2 = [], { radius: o2, extent: n2, reduce: i2, minPoints: s2 } = this.options, a2 = o2 / (n2 * Math.pow(2, t2));
              for (let o3 = 0; o3 < e2.length; o3++) {
                const n3 = e2[o3];
                if (n3.zoom <= t2)
                  continue;
                n3.zoom = t2;
                const l2 = this.trees[t2 + 1], u2 = l2.within(n3.x, n3.y, a2), h2 = n3.numPoints || 1;
                let c2 = h2;
                for (const e3 of u2) {
                  const r3 = l2.points[e3];
                  r3.zoom > t2 && (c2 += r3.numPoints || 1);
                }
                if (c2 > h2 && c2 >= s2) {
                  let e3 = n3.x * h2, s3 = n3.y * h2, a3 = i2 && h2 > 1 ? this._map(n3, true) : null;
                  const f2 = (o3 << 5) + (t2 + 1) + this.points.length;
                  for (const r3 of u2) {
                    const o4 = l2.points[r3];
                    if (o4.zoom <= t2)
                      continue;
                    o4.zoom = t2;
                    const u3 = o4.numPoints || 1;
                    e3 += o4.x * u3, s3 += o4.y * u3, o4.parentId = f2, i2 && (a3 || (a3 = this._map(n3, true)), i2(a3, this._map(o4)));
                  }
                  n3.parentId = f2, r2.push(W(e3 / c2, s3 / c2, f2, c2, a3));
                } else if (r2.push(n3), c2 > 1)
                  for (const e3 of u2) {
                    const o4 = l2.points[e3];
                    o4.zoom <= t2 || (o4.zoom = t2, r2.push(o4));
                  }
              }
              return r2;
            }
            _getOriginId(e2) {
              return e2 - this.points.length >> 5;
            }
            _getOriginZoom(e2) {
              return (e2 - this.points.length) % 32;
            }
            _map(e2, t2) {
              if (e2.numPoints)
                return t2 ? B({}, e2.properties) : e2.properties;
              const r2 = this.points[e2.index].properties, o2 = this.options.map(r2);
              return t2 && o2 === r2 ? B({}, o2) : o2;
            }
          }
          function W(e2, t2, r2, o2, n2) {
            return { x: Z(e2), y: Z(t2), zoom: 1 / 0, id: r2, parentId: -1, numPoints: o2, properties: n2 };
          }
          function Y(e2, t2) {
            const [r2, o2] = e2.geometry.coordinates;
            return { x: Z(A(r2)), y: Z(D(o2)), zoom: 1 / 0, index: t2, parentId: -1 };
          }
          function X(e2) {
            return { type: "Feature", id: e2.id, properties: V(e2), geometry: { type: "Point", coordinates: [(t2 = e2.x, 360 * (t2 - 0.5)), $(e2.y)] } };
            var t2;
          }
          function V(e2) {
            const t2 = e2.numPoints, r2 = t2 >= 1e4 ? `${Math.round(t2 / 1e3)}k` : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
            return B(B({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t2, point_count_abbreviated: r2 });
          }
          function A(e2) {
            return e2 / 360 + 0.5;
          }
          function D(e2) {
            const t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
          }
          function $(e2) {
            const t2 = (180 - 360 * e2) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
          }
          function B(e2, t2) {
            for (const r2 in t2)
              e2[r2] = t2[r2];
            return e2;
          }
          function R(e2) {
            return e2.x;
          }
          function q(e2) {
            return e2.y;
          }
          function U(e2, t2, r2, o2) {
            for (var n2, i2 = o2, s2 = r2 - t2 >> 1, a2 = r2 - t2, l2 = e2[t2], u2 = e2[t2 + 1], h2 = e2[r2], c2 = e2[r2 + 1], f2 = t2 + 3; f2 < r2; f2 += 3) {
              var p2 = Q(e2[f2], e2[f2 + 1], l2, u2, h2, c2);
              if (p2 > i2)
                n2 = f2, i2 = p2;
              else if (p2 === i2) {
                var g2 = Math.abs(f2 - s2);
                g2 < a2 && (n2 = f2, a2 = g2);
              }
            }
            i2 > o2 && (n2 - t2 > 3 && U(e2, t2, n2, o2), e2[n2 + 2] = i2, r2 - n2 > 3 && U(e2, n2, r2, o2));
          }
          function Q(e2, t2, r2, o2, n2, i2) {
            var s2 = n2 - r2, a2 = i2 - o2;
            if (0 !== s2 || 0 !== a2) {
              var l2 = ((e2 - r2) * s2 + (t2 - o2) * a2) / (s2 * s2 + a2 * a2);
              l2 > 1 ? (r2 = n2, o2 = i2) : l2 > 0 && (r2 += s2 * l2, o2 += a2 * l2);
            }
            return (s2 = e2 - r2) * s2 + (a2 = t2 - o2) * a2;
          }
          function H(e2, t2, r2, o2) {
            var n2 = { id: void 0 === e2 ? null : e2, type: t2, geometry: r2, tags: o2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            return function(e3) {
              var t3 = e3.geometry, r3 = e3.type;
              if ("Point" === r3 || "MultiPoint" === r3 || "LineString" === r3)
                K(e3, t3);
              else if ("Polygon" === r3 || "MultiLineString" === r3)
                for (var o3 = 0; o3 < t3.length; o3++)
                  K(e3, t3[o3]);
              else if ("MultiPolygon" === r3)
                for (o3 = 0; o3 < t3.length; o3++)
                  for (var n3 = 0; n3 < t3[o3].length; n3++)
                    K(e3, t3[o3][n3]);
            }(n2), n2;
          }
          function K(e2, t2) {
            for (var r2 = 0; r2 < t2.length; r2 += 3)
              e2.minX = Math.min(e2.minX, t2[r2]), e2.minY = Math.min(e2.minY, t2[r2 + 1]), e2.maxX = Math.max(e2.maxX, t2[r2]), e2.maxY = Math.max(e2.maxY, t2[r2 + 1]);
          }
          function ee(e2, t2, r2, o2) {
            if (t2.geometry) {
              var n2 = t2.geometry.coordinates, i2 = t2.geometry.type, s2 = Math.pow(r2.tolerance / ((1 << r2.maxZoom) * r2.extent), 2), a2 = [], l2 = t2.id;
              if (r2.promoteId ? l2 = t2.properties[r2.promoteId] : r2.generateId && (l2 = o2 || 0), "Point" === i2)
                te(n2, a2);
              else if ("MultiPoint" === i2)
                for (var u2 = 0; u2 < n2.length; u2++)
                  te(n2[u2], a2);
              else if ("LineString" === i2)
                re(n2, a2, s2, false);
              else if ("MultiLineString" === i2) {
                if (r2.lineMetrics) {
                  for (u2 = 0; u2 < n2.length; u2++)
                    re(n2[u2], a2 = [], s2, false), e2.push(H(l2, "LineString", a2, t2.properties));
                  return;
                }
                oe(n2, a2, s2, false);
              } else if ("Polygon" === i2)
                oe(n2, a2, s2, true);
              else {
                if ("MultiPolygon" !== i2) {
                  if ("GeometryCollection" === i2) {
                    for (u2 = 0; u2 < t2.geometry.geometries.length; u2++)
                      ee(e2, { id: l2, geometry: t2.geometry.geometries[u2], properties: t2.properties }, r2, o2);
                    return;
                  }
                  throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (u2 = 0; u2 < n2.length; u2++) {
                  var h2 = [];
                  oe(n2[u2], h2, s2, true), a2.push(h2);
                }
              }
              e2.push(H(l2, i2, a2, t2.properties));
            }
          }
          function te(e2, t2) {
            t2.push(ne(e2[0])), t2.push(ie(e2[1])), t2.push(0);
          }
          function re(e2, t2, r2, o2) {
            for (var n2, i2, s2 = 0, a2 = 0; a2 < e2.length; a2++) {
              var l2 = ne(e2[a2][0]), u2 = ie(e2[a2][1]);
              t2.push(l2), t2.push(u2), t2.push(0), a2 > 0 && (s2 += o2 ? (n2 * u2 - l2 * i2) / 2 : Math.sqrt(Math.pow(l2 - n2, 2) + Math.pow(u2 - i2, 2))), n2 = l2, i2 = u2;
            }
            var h2 = t2.length - 3;
            t2[2] = 1, U(t2, 0, h2, r2), t2[h2 + 2] = 1, t2.size = Math.abs(s2), t2.start = 0, t2.end = t2.size;
          }
          function oe(e2, t2, r2, o2) {
            for (var n2 = 0; n2 < e2.length; n2++) {
              var i2 = [];
              re(e2[n2], i2, r2, o2), t2.push(i2);
            }
          }
          function ne(e2) {
            return e2 / 360 + 0.5;
          }
          function ie(e2) {
            var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
          }
          function se(e2, t2, r2, o2, n2, i2, s2, a2) {
            if (o2 /= t2, i2 >= (r2 /= t2) && s2 < o2)
              return e2;
            if (s2 < r2 || i2 >= o2)
              return null;
            for (var l2 = [], u2 = 0; u2 < e2.length; u2++) {
              var h2 = e2[u2], c2 = h2.geometry, f2 = h2.type, p2 = 0 === n2 ? h2.minX : h2.minY, g2 = 0 === n2 ? h2.maxX : h2.maxY;
              if (p2 >= r2 && g2 < o2)
                l2.push(h2);
              else if (!(g2 < r2 || p2 >= o2)) {
                var d2 = [];
                if ("Point" === f2 || "MultiPoint" === f2)
                  ae(c2, d2, r2, o2, n2);
                else if ("LineString" === f2)
                  le(c2, d2, r2, o2, n2, false, a2.lineMetrics);
                else if ("MultiLineString" === f2)
                  he(c2, d2, r2, o2, n2, false);
                else if ("Polygon" === f2)
                  he(c2, d2, r2, o2, n2, true);
                else if ("MultiPolygon" === f2)
                  for (var m2 = 0; m2 < c2.length; m2++) {
                    var y2 = [];
                    he(c2[m2], y2, r2, o2, n2, true), y2.length && d2.push(y2);
                  }
                if (d2.length) {
                  if (a2.lineMetrics && "LineString" === f2) {
                    for (m2 = 0; m2 < d2.length; m2++)
                      l2.push(H(h2.id, f2, d2[m2], h2.tags));
                    continue;
                  }
                  "LineString" !== f2 && "MultiLineString" !== f2 || (1 === d2.length ? (f2 = "LineString", d2 = d2[0]) : f2 = "MultiLineString"), "Point" !== f2 && "MultiPoint" !== f2 || (f2 = 3 === d2.length ? "Point" : "MultiPoint"), l2.push(H(h2.id, f2, d2, h2.tags));
                }
              }
            }
            return l2.length ? l2 : null;
          }
          function ae(e2, t2, r2, o2, n2) {
            for (var i2 = 0; i2 < e2.length; i2 += 3) {
              var s2 = e2[i2 + n2];
              s2 >= r2 && s2 <= o2 && (t2.push(e2[i2]), t2.push(e2[i2 + 1]), t2.push(e2[i2 + 2]));
            }
          }
          function le(e2, t2, r2, o2, n2, i2, s2) {
            for (var a2, l2, u2 = ue(e2), h2 = 0 === n2 ? fe : pe, c2 = e2.start, f2 = 0; f2 < e2.length - 3; f2 += 3) {
              var p2 = e2[f2], g2 = e2[f2 + 1], d2 = e2[f2 + 2], m2 = e2[f2 + 3], y2 = e2[f2 + 4], v2 = 0 === n2 ? p2 : g2, x2 = 0 === n2 ? m2 : y2, w2 = false;
              s2 && (a2 = Math.sqrt(Math.pow(p2 - m2, 2) + Math.pow(g2 - y2, 2))), v2 < r2 ? x2 > r2 && (l2 = h2(u2, p2, g2, m2, y2, r2), s2 && (u2.start = c2 + a2 * l2)) : v2 > o2 ? x2 < o2 && (l2 = h2(u2, p2, g2, m2, y2, o2), s2 && (u2.start = c2 + a2 * l2)) : ce(u2, p2, g2, d2), x2 < r2 && v2 >= r2 && (l2 = h2(u2, p2, g2, m2, y2, r2), w2 = true), x2 > o2 && v2 <= o2 && (l2 = h2(u2, p2, g2, m2, y2, o2), w2 = true), !i2 && w2 && (s2 && (u2.end = c2 + a2 * l2), t2.push(u2), u2 = ue(e2)), s2 && (c2 += a2);
            }
            var S2 = e2.length - 3;
            p2 = e2[S2], g2 = e2[S2 + 1], d2 = e2[S2 + 2], (v2 = 0 === n2 ? p2 : g2) >= r2 && v2 <= o2 && ce(u2, p2, g2, d2), S2 = u2.length - 3, i2 && S2 >= 3 && (u2[S2] !== u2[0] || u2[S2 + 1] !== u2[1]) && ce(u2, u2[0], u2[1], u2[2]), u2.length && t2.push(u2);
          }
          function ue(e2) {
            var t2 = [];
            return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
          }
          function he(e2, t2, r2, o2, n2, i2) {
            for (var s2 = 0; s2 < e2.length; s2++)
              le(e2[s2], t2, r2, o2, n2, i2, false);
          }
          function ce(e2, t2, r2, o2) {
            e2.push(t2), e2.push(r2), e2.push(o2);
          }
          function fe(e2, t2, r2, o2, n2, i2) {
            var s2 = (i2 - t2) / (o2 - t2);
            return e2.push(i2), e2.push(r2 + (n2 - r2) * s2), e2.push(1), s2;
          }
          function pe(e2, t2, r2, o2, n2, i2) {
            var s2 = (i2 - r2) / (n2 - r2);
            return e2.push(t2 + (o2 - t2) * s2), e2.push(i2), e2.push(1), s2;
          }
          function ge(e2, t2) {
            for (var r2 = [], o2 = 0; o2 < e2.length; o2++) {
              var n2, i2 = e2[o2], s2 = i2.type;
              if ("Point" === s2 || "MultiPoint" === s2 || "LineString" === s2)
                n2 = de(i2.geometry, t2);
              else if ("MultiLineString" === s2 || "Polygon" === s2) {
                n2 = [];
                for (var a2 = 0; a2 < i2.geometry.length; a2++)
                  n2.push(de(i2.geometry[a2], t2));
              } else if ("MultiPolygon" === s2)
                for (n2 = [], a2 = 0; a2 < i2.geometry.length; a2++) {
                  for (var l2 = [], u2 = 0; u2 < i2.geometry[a2].length; u2++)
                    l2.push(de(i2.geometry[a2][u2], t2));
                  n2.push(l2);
                }
              r2.push(H(i2.id, s2, n2, i2.tags));
            }
            return r2;
          }
          function de(e2, t2) {
            var r2 = [];
            r2.size = e2.size, void 0 !== e2.start && (r2.start = e2.start, r2.end = e2.end);
            for (var o2 = 0; o2 < e2.length; o2 += 3)
              r2.push(e2[o2] + t2, e2[o2 + 1], e2[o2 + 2]);
            return r2;
          }
          function me(e2, t2) {
            if (e2.transformed)
              return e2;
            var r2, o2, n2, i2 = 1 << e2.z, s2 = e2.x, a2 = e2.y;
            for (r2 = 0; r2 < e2.features.length; r2++) {
              var l2 = e2.features[r2], u2 = l2.geometry, h2 = l2.type;
              if (l2.geometry = [], 1 === h2)
                for (o2 = 0; o2 < u2.length; o2 += 2)
                  l2.geometry.push(ye(u2[o2], u2[o2 + 1], t2, i2, s2, a2));
              else
                for (o2 = 0; o2 < u2.length; o2++) {
                  var c2 = [];
                  for (n2 = 0; n2 < u2[o2].length; n2 += 2)
                    c2.push(ye(u2[o2][n2], u2[o2][n2 + 1], t2, i2, s2, a2));
                  l2.geometry.push(c2);
                }
            }
            return e2.transformed = true, e2;
          }
          function ye(e2, t2, r2, o2, n2, i2) {
            return [Math.round(r2 * (e2 * o2 - n2)), Math.round(r2 * (t2 * o2 - i2))];
          }
          function ve(e2, t2, r2, o2, n2) {
            for (var i2 = t2 === n2.maxZoom ? 0 : n2.tolerance / ((1 << t2) * n2.extent), s2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r2, y: o2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
              s2.numFeatures++, xe(s2, e2[a2], i2, n2);
              var l2 = e2[a2].minX, u2 = e2[a2].minY, h2 = e2[a2].maxX, c2 = e2[a2].maxY;
              l2 < s2.minX && (s2.minX = l2), u2 < s2.minY && (s2.minY = u2), h2 > s2.maxX && (s2.maxX = h2), c2 > s2.maxY && (s2.maxY = c2);
            }
            return s2;
          }
          function xe(e2, t2, r2, o2) {
            var n2 = t2.geometry, i2 = t2.type, s2 = [];
            if ("Point" === i2 || "MultiPoint" === i2)
              for (var a2 = 0; a2 < n2.length; a2 += 3)
                s2.push(n2[a2]), s2.push(n2[a2 + 1]), e2.numPoints++, e2.numSimplified++;
            else if ("LineString" === i2)
              we(s2, n2, e2, r2, false, false);
            else if ("MultiLineString" === i2 || "Polygon" === i2)
              for (a2 = 0; a2 < n2.length; a2++)
                we(s2, n2[a2], e2, r2, "Polygon" === i2, 0 === a2);
            else if ("MultiPolygon" === i2)
              for (var l2 = 0; l2 < n2.length; l2++) {
                var u2 = n2[l2];
                for (a2 = 0; a2 < u2.length; a2++)
                  we(s2, u2[a2], e2, r2, true, 0 === a2);
              }
            if (s2.length) {
              var h2 = t2.tags || null;
              if ("LineString" === i2 && o2.lineMetrics) {
                for (var c2 in h2 = {}, t2.tags)
                  h2[c2] = t2.tags[c2];
                h2.mapbox_clip_start = n2.start / n2.size, h2.mapbox_clip_end = n2.end / n2.size;
              }
              var f2 = { geometry: s2, type: "Polygon" === i2 || "MultiPolygon" === i2 ? 3 : "LineString" === i2 || "MultiLineString" === i2 ? 2 : 1, tags: h2 };
              null !== t2.id && (f2.id = t2.id), e2.features.push(f2);
            }
          }
          function we(e2, t2, r2, o2, n2, i2) {
            var s2 = o2 * o2;
            if (o2 > 0 && t2.size < (n2 ? s2 : o2))
              r2.numPoints += t2.length / 3;
            else {
              for (var a2 = [], l2 = 0; l2 < t2.length; l2 += 3)
                (0 === o2 || t2[l2 + 2] > s2) && (r2.numSimplified++, a2.push(t2[l2]), a2.push(t2[l2 + 1])), r2.numPoints++;
              n2 && function(e3, t3) {
                for (var r3 = 0, o3 = 0, n3 = e3.length, i3 = n3 - 2; o3 < n3; i3 = o3, o3 += 2)
                  r3 += (e3[o3] - e3[i3]) * (e3[o3 + 1] + e3[i3 + 1]);
                if (r3 > 0 === t3)
                  for (o3 = 0, n3 = e3.length; o3 < n3 / 2; o3 += 2) {
                    var s3 = e3[o3], a3 = e3[o3 + 1];
                    e3[o3] = e3[n3 - 2 - o3], e3[o3 + 1] = e3[n3 - 1 - o3], e3[n3 - 2 - o3] = s3, e3[n3 - 1 - o3] = a3;
                  }
              }(a2, i2), e2.push(a2);
            }
          }
          function Se(e2, t2) {
            var r2 = (t2 = this.options = function(e3, t3) {
              for (var r3 in t3)
                e3[r3] = t3[r3];
              return e3;
            }(Object.create(this.options), t2)).debug;
            if (r2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
              throw new Error("maxZoom should be in the 0-24 range");
            if (t2.promoteId && t2.generateId)
              throw new Error("promoteId and generateId cannot be used together.");
            var o2 = function(e3, t3) {
              var r3 = [];
              if ("FeatureCollection" === e3.type)
                for (var o3 = 0; o3 < e3.features.length; o3++)
                  ee(r3, e3.features[o3], t3, o3);
              else
                ee(r3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
              return r3;
            }(e2, t2);
            this.tiles = {}, this.tileCoords = [], r2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o2 = function(e3, t3) {
              var r3 = t3.buffer / t3.extent, o3 = e3, n2 = se(e3, 1, -1 - r3, r3, 0, -1, 2, t3), i2 = se(e3, 1, 1 - r3, 2 + r3, 0, -1, 2, t3);
              return (n2 || i2) && (o3 = se(e3, 1, -r3, 1 + r3, 0, -1, 2, t3) || [], n2 && (o3 = ge(n2, 1).concat(o3)), i2 && (o3 = o3.concat(ge(i2, -1)))), o3;
            }(o2, t2), o2.length && this.splitTile(o2, 0, 0, 0), r2 && (o2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          function Me(e2, t2, r2) {
            return 32 * ((1 << e2) * r2 + t2) + e2;
          }
          function Pe(e2, t2) {
            const r2 = e2.tileID.canonical;
            if (!this._geoJSONIndex)
              return t2(null, null);
            const o2 = this._geoJSONIndex.getTile(r2.z, r2.x, r2.y);
            if (!o2)
              return t2(null, null);
            const n2 = new h(o2.features);
            let i2 = c(n2);
            0 === i2.byteOffset && i2.byteLength === i2.buffer.byteLength || (i2 = new Uint8Array(i2)), t2(null, { vectorTile: n2, rawData: i2.buffer });
          }
          Se.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, Se.prototype.splitTile = function(e2, t2, r2, o2, n2, i2, s2) {
            for (var a2 = [e2, t2, r2, o2], l2 = this.options, u2 = l2.debug; a2.length; ) {
              o2 = a2.pop(), r2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
              var h2 = 1 << t2, c2 = Me(t2, r2, o2), f2 = this.tiles[c2];
              if (!f2 && (u2 > 1 && console.time("creation"), f2 = this.tiles[c2] = ve(e2, t2, r2, o2, l2), this.tileCoords.push({ z: t2, x: r2, y: o2 }), u2)) {
                u2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, r2, o2, f2.numFeatures, f2.numPoints, f2.numSimplified), console.timeEnd("creation"));
                var p2 = "z" + t2;
                this.stats[p2] = (this.stats[p2] || 0) + 1, this.total++;
              }
              if (f2.source = e2, n2) {
                if (t2 === l2.maxZoom || t2 === n2)
                  continue;
                var g2 = 1 << n2 - t2;
                if (r2 !== Math.floor(i2 / g2) || o2 !== Math.floor(s2 / g2))
                  continue;
              } else if (t2 === l2.indexMaxZoom || f2.numPoints <= l2.indexMaxPoints)
                continue;
              if (f2.source = null, 0 !== e2.length) {
                u2 > 1 && console.time("clipping");
                var d2, m2, y2, v2, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, M2 = 0.5 - S2, P2 = 0.5 + S2, b2 = 1 + S2;
                d2 = m2 = y2 = v2 = null, x2 = se(e2, h2, r2 - S2, r2 + P2, 0, f2.minX, f2.maxX, l2), w2 = se(e2, h2, r2 + M2, r2 + b2, 0, f2.minX, f2.maxX, l2), e2 = null, x2 && (d2 = se(x2, h2, o2 - S2, o2 + P2, 1, f2.minY, f2.maxY, l2), m2 = se(x2, h2, o2 + M2, o2 + b2, 1, f2.minY, f2.maxY, l2), x2 = null), w2 && (y2 = se(w2, h2, o2 - S2, o2 + P2, 1, f2.minY, f2.maxY, l2), v2 = se(w2, h2, o2 + M2, o2 + b2, 1, f2.minY, f2.maxY, l2), w2 = null), u2 > 1 && console.timeEnd("clipping"), a2.push(d2 || [], t2 + 1, 2 * r2, 2 * o2), a2.push(m2 || [], t2 + 1, 2 * r2, 2 * o2 + 1), a2.push(y2 || [], t2 + 1, 2 * r2 + 1, 2 * o2), a2.push(v2 || [], t2 + 1, 2 * r2 + 1, 2 * o2 + 1);
              }
            }
          }, Se.prototype.getTile = function(e2, t2, r2) {
            var o2 = this.options, n2 = o2.extent, i2 = o2.debug;
            if (e2 < 0 || e2 > 24)
              return null;
            var s2 = 1 << e2, a2 = Me(e2, t2 = (t2 % s2 + s2) % s2, r2);
            if (this.tiles[a2])
              return me(this.tiles[a2], n2);
            i2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, r2);
            for (var l2, u2 = e2, h2 = t2, c2 = r2; !l2 && u2 > 0; )
              u2--, h2 = Math.floor(h2 / 2), c2 = Math.floor(c2 / 2), l2 = this.tiles[Me(u2, h2, c2)];
            return l2 && l2.source ? (i2 > 1 && console.log("found parent tile z%d-%d-%d", u2, h2, c2), i2 > 1 && console.time("drilling down"), this.splitTile(l2.source, u2, h2, c2, e2, t2, r2), i2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? me(this.tiles[a2], n2) : null) : null;
          };
          class be extends e.VectorTileWorkerSource {
            constructor(e2, t2, r2, o2, n2) {
              super(e2, t2, r2, o2, Pe), n2 && (this.loadGeoJSON = n2);
            }
            loadData(t2, r2) {
              const o2 = t2 && t2.request, n2 = o2 && o2.collectResourceTiming;
              this.loadGeoJSON(t2, (s2, a2) => {
                if (s2 || !a2)
                  return r2(s2);
                if ("object" != typeof a2)
                  return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                {
                  i(a2, true);
                  try {
                    if (t2.filter) {
                      const r3 = e.createExpression(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                      if ("error" === r3.result)
                        throw new Error(r3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                      const o3 = a2.features.filter((e2) => r3.value.evaluate({ zoom: 0 }, e2));
                      a2 = { type: "FeatureCollection", features: o3 };
                    }
                    this._geoJSONIndex = t2.cluster ? new J(function({ superclusterOptions: t3, clusterProperties: r3 }) {
                      if (!r3 || !t3)
                        return t3;
                      const o3 = {}, n3 = {}, i2 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, a3 = Object.keys(r3);
                      for (const t4 of a3) {
                        const [i3, s4] = r3[t4], a4 = e.createExpression(s4), l3 = e.createExpression("string" == typeof i3 ? [i3, ["accumulated"], ["get", t4]] : i3);
                        o3[t4] = a4.value, n3[t4] = l3.value;
                      }
                      return t3.map = (e2) => {
                        s3.properties = e2;
                        const t4 = {};
                        for (const e3 of a3)
                          t4[e3] = o3[e3].evaluate(i2, s3);
                        return t4;
                      }, t3.reduce = (e2, t4) => {
                        s3.properties = t4;
                        for (const t5 of a3)
                          i2.accumulated = e2[t5], e2[t5] = n3[t5].evaluate(i2, s3);
                      }, t3;
                    }(t2)).load(a2.features) : function(e2, t3) {
                      return new Se(e2, t3);
                    }(a2, t2.geojsonVtOptions);
                  } catch (s3) {
                    return r2(s3);
                  }
                  this.loaded = {};
                  const l2 = {};
                  if (n2) {
                    const r3 = e.getPerformanceMeasurement(o2);
                    r3 && (l2.resourceTiming = {}, l2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(r3)));
                  }
                  r2(null, l2);
                }
              });
            }
            reloadTile(e2, t2) {
              const r2 = this.loaded;
              return r2 && r2[e2.uid] ? super.reloadTile(e2, t2) : this.loadTile(e2, t2);
            }
            loadGeoJSON(t2, r2) {
              if (t2.request)
                e.getJSON(t2.request, r2);
              else {
                if ("string" != typeof t2.data)
                  return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                try {
                  return r2(null, JSON.parse(t2.data));
                } catch (e2) {
                  return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                }
              }
            }
            getClusterExpansionZoom(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
              } catch (e3) {
                t2(e3);
              }
            }
            getClusterChildren(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
              } catch (e3) {
                t2(e3);
              }
            }
            getClusterLeaves(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
              } catch (e3) {
                t2(e3);
              }
            }
          }
          class ke {
            constructor(t2) {
              this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({ name: "mercator" }), this.workerSourceTypes = { vector: e.VectorTileWorkerSource, geojson: be }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
                if (this.workerSourceTypes[e2])
                  throw new Error(`Worker source with name "${e2}" already registered.`);
                this.workerSourceTypes[e2] = t3;
              }, this.self.registerRTLTextPlugin = (t3) => {
                if (e.plugin.isParsed())
                  throw new Error("RTL text plugin already registered.");
                e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
              };
            }
            clearCaches(e2, t2, r2) {
              delete this.layerIndexes[e2], delete this.availableImages[e2], delete this.workerSources[e2], delete this.demWorkerSources[e2], r2();
            }
            checkIfReady(e2, t2, r2) {
              r2();
            }
            setReferrer(e2, t2) {
              this.referrer = t2;
            }
            spriteLoaded(t2, r2) {
              this.isSpriteLoaded[t2] = r2;
              for (const o2 in this.workerSources[t2]) {
                const n2 = this.workerSources[t2][o2];
                for (const t3 in n2)
                  n2[t3] instanceof e.VectorTileWorkerSource && (n2[t3].isSpriteLoaded = r2, n2[t3].fire(new e.Event("isSpriteLoaded")));
              }
            }
            setImages(e2, t2, r2) {
              this.availableImages[e2] = t2;
              for (const r3 in this.workerSources[e2]) {
                const o2 = this.workerSources[e2][r3];
                for (const e3 in o2)
                  o2[e3].availableImages = t2;
              }
              r2();
            }
            enableTerrain(e2, t2, r2) {
              this.terrain = t2, r2();
            }
            setProjection(t2, r2) {
              this.projections[t2] = e.getProjection(r2);
            }
            setLayers(e2, t2, r2) {
              this.getLayerIndex(e2).replace(t2), r2();
            }
            updateLayers(e2, t2, r2) {
              this.getLayerIndex(e2).update(t2.layers, t2.removedIds), r2();
            }
            loadTile(t2, r2, o2) {
              const n2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r2) : r2;
              n2.projection = this.projections[t2] || this.defaultProjection, this.getWorkerSource(t2, r2.type, r2.source).loadTile(n2, o2);
            }
            loadDEMTile(t2, r2, o2) {
              const n2 = this.enableTerrain ? e.extend({ buildQuadTree: this.terrain }, r2) : r2;
              this.getDEMWorkerSource(t2, r2.source).loadTile(n2, o2);
            }
            reloadTile(t2, r2, o2) {
              const n2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r2) : r2;
              n2.projection = this.projections[t2] || this.defaultProjection, this.getWorkerSource(t2, r2.type, r2.source).reloadTile(n2, o2);
            }
            abortTile(e2, t2, r2) {
              this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, r2);
            }
            removeTile(e2, t2, r2) {
              this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, r2);
            }
            removeSource(e2, t2, r2) {
              if (!this.workerSources[e2] || !this.workerSources[e2][t2.type] || !this.workerSources[e2][t2.type][t2.source])
                return;
              const o2 = this.workerSources[e2][t2.type][t2.source];
              delete this.workerSources[e2][t2.type][t2.source], void 0 !== o2.removeSource ? o2.removeSource(t2, r2) : r2();
            }
            loadWorkerSource(e2, t2, r2) {
              try {
                this.self.importScripts(t2.url), r2();
              } catch (e3) {
                r2(e3.toString());
              }
            }
            syncRTLPluginState(t2, r2, o2) {
              try {
                e.plugin.setState(r2);
                const t3 = e.plugin.getPluginURL();
                if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t3) {
                  this.self.importScripts(t3);
                  const r3 = e.plugin.isParsed();
                  o2(r3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), r3);
                }
              } catch (e2) {
                o2(e2.toString());
              }
            }
            getAvailableImages(e2) {
              let t2 = this.availableImages[e2];
              return t2 || (t2 = []), t2;
            }
            getLayerIndex(e2) {
              let t2 = this.layerIndexes[e2];
              return t2 || (t2 = this.layerIndexes[e2] = new o()), t2;
            }
            getWorkerSource(e2, t2, r2) {
              if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][r2]) {
                const o2 = { send: (t3, r3, o3, n2, i2, s2) => {
                  this.actor.send(t3, r3, o3, e2, i2, s2);
                }, scheduler: this.actor.scheduler };
                this.workerSources[e2][t2][r2] = new this.workerSourceTypes[t2](o2, this.getLayerIndex(e2), this.getAvailableImages(e2), this.isSpriteLoaded[e2]);
              }
              return this.workerSources[e2][t2][r2];
            }
            getDEMWorkerSource(e2, t2) {
              return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new n()), this.demWorkerSources[e2][t2];
            }
            enforceCacheSizeLimit(t2, r2) {
              e.enforceCacheSizeLimit(r2);
            }
            getWorkerPerformanceMetrics(e2, t2, r2) {
              r2(void 0, void 0);
            }
          }
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new ke(self)), ke;
        });
        define2(["./shared"], function(e) {
          "use strict";
          function t(e2, i2) {
            if (Array.isArray(e2)) {
              if (!Array.isArray(i2) || e2.length !== i2.length)
                return false;
              for (let o2 = 0; o2 < e2.length; o2++)
                if (!t(e2[o2], i2[o2]))
                  return false;
              return true;
            }
            if ("object" == typeof e2 && null !== e2 && null !== i2) {
              if ("object" != typeof i2)
                return false;
              if (Object.keys(e2).length !== Object.keys(i2).length)
                return false;
              for (const o2 in e2)
                if (!t(e2[o2], i2[o2]))
                  return false;
              return true;
            }
            return e2 === i2;
          }
          var i = o;
          function o(e2) {
            return !function(e3) {
              return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
                if (!("Worker" in window && "Blob" in window && "URL" in window))
                  return false;
                var e4, t3, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
                try {
                  t3 = new Worker(o2), e4 = true;
                } catch (t4) {
                  e4 = false;
                }
                return t3 && t3.terminate(), URL.revokeObjectURL(o2), e4;
              }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
                var e4 = document.createElement("canvas");
                e4.width = e4.height = 1;
                var t3 = e4.getContext("2d");
                if (!t3)
                  return false;
                var i2 = t3.getImageData(0, 0, 1, 1);
                return i2 && i2.width === e4.width;
              }() ? (void 0 === r[t2 = e3 && e3.failIfMajorPerformanceCaveat] && (r[t2] = function(e4) {
                var t3, i2 = function(e5) {
                  var t4 = document.createElement("canvas"), i3 = Object.create(o.webGLContextAttributes);
                  return i3.failIfMajorPerformanceCaveat = e5, t4.getContext("webgl", i3) || t4.getContext("experimental-webgl", i3);
                }(e4);
                if (!i2)
                  return false;
                try {
                  t3 = i2.createShader(i2.VERTEX_SHADER);
                } catch (e5) {
                  return false;
                }
                return !(!t3 || i2.isContextLost()) && (i2.shaderSource(t3, "void main() {}"), i2.compileShader(t3), true === i2.getShaderParameter(t3, i2.COMPILE_STATUS));
              }(t2)), r[t2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
              var t2;
            }(e2);
          }
          var r = {};
          function n(t2, i2, o2) {
            const r2 = e.window.document.createElement(t2);
            return void 0 !== i2 && (r2.className = i2), o2 && o2.appendChild(r2), r2;
          }
          function s(t2, i2, o2) {
            const r2 = e.window.document.createElementNS("http://www.w3.org/2000/svg", t2);
            for (const e2 of Object.keys(i2))
              r2.setAttributeNS(null, e2, i2[e2]);
            return o2 && o2.appendChild(r2), r2;
          }
          o.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
          const a = e.window.document && e.window.document.documentElement.style, l = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect";
          let c;
          function h() {
            a && l && (c = a[l], a[l] = "none");
          }
          function u() {
            a && l && (a[l] = c);
          }
          function _(t2) {
            t2.preventDefault(), t2.stopPropagation(), e.window.removeEventListener("click", _, true);
          }
          function d() {
            e.window.addEventListener("click", _, true), e.window.setTimeout(() => {
              e.window.removeEventListener("click", _, true);
            }, 0);
          }
          function p(e2, t2) {
            const i2 = e2.getBoundingClientRect();
            return g(e2, i2, t2);
          }
          function m(e2, t2) {
            const i2 = e2.getBoundingClientRect(), o2 = [];
            for (let r2 = 0; r2 < t2.length; r2++)
              o2.push(g(e2, i2, t2[r2]));
            return o2;
          }
          function f(t2) {
            return void 0 !== e.window.InstallTrigger && 2 === t2.button && t2.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t2.button;
          }
          function g(t2, i2, o2) {
            const r2 = t2.offsetWidth === i2.width ? 1 : t2.offsetWidth / i2.width;
            return new e.pointGeometry((o2.clientX - i2.left) * r2, (o2.clientY - i2.top) * r2);
          }
          function v(e2, t2) {
            var i2 = t2[0], o2 = t2[1], r2 = t2[2], n2 = t2[3], s2 = i2 * n2 - r2 * o2;
            return s2 ? (e2[0] = n2 * (s2 = 1 / s2), e2[1] = -o2 * s2, e2[2] = -r2 * s2, e2[3] = i2 * s2, e2) : null;
          }
          function x(e2) {
            const { userImage: t2 } = e2;
            return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
          }
          class y extends e.Evented {
            constructor() {
              super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
            }
            isLoaded() {
              return this.loaded;
            }
            setLoaded(e2) {
              if (this.loaded !== e2 && (this.loaded = e2, e2)) {
                for (const { ids: e3, callback: t2 } of this.requestors)
                  this._notify(e3, t2);
                this.requestors = [];
              }
            }
            hasImage(e2) {
              return !!this.getImage(e2);
            }
            getImage(e2) {
              return this.images[e2];
            }
            addImage(e2, t2) {
              this._validate(e2, t2) && (this.images[e2] = t2);
            }
            _validate(t2, i2) {
              let o2 = true;
              return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "content" value`))), o2 = false), o2;
            }
            _validateStretch(e2, t2) {
              if (!e2)
                return true;
              let i2 = 0;
              for (const o2 of e2) {
                if (o2[0] < i2 || o2[1] < o2[0] || t2 < o2[1])
                  return false;
                i2 = o2[1];
              }
              return true;
            }
            _validateContent(e2, t2) {
              return !(e2 && (4 !== e2.length || e2[0] < 0 || t2.data.width < e2[0] || e2[1] < 0 || t2.data.height < e2[1] || e2[2] < 0 || t2.data.width < e2[2] || e2[3] < 0 || t2.data.height < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]));
            }
            updateImage(e2, t2) {
              t2.version = this.images[e2].version + 1, this.images[e2] = t2, this.updatedImages[e2] = true;
            }
            removeImage(e2) {
              const t2 = this.images[e2];
              delete this.images[e2], delete this.patterns[e2], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
            }
            listImages() {
              return Object.keys(this.images);
            }
            getImages(e2, t2) {
              let i2 = true;
              if (!this.isLoaded())
                for (const t3 of e2)
                  this.images[t3] || (i2 = false);
              this.isLoaded() || i2 ? this._notify(e2, t2) : this.requestors.push({ ids: e2, callback: t2 });
            }
            _notify(t2, i2) {
              const o2 = {};
              for (const i3 of t2) {
                this.images[i3] || this.fire(new e.Event("styleimagemissing", { id: i3 }));
                const t3 = this.images[i3];
                t3 ? o2[i3] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
              }
              i2(null, o2);
            }
            getPixelSize() {
              const { width: e2, height: t2 } = this.atlasImage;
              return { width: e2, height: t2 };
            }
            getPattern(t2) {
              const i2 = this.patterns[t2], o2 = this.getImage(t2);
              if (!o2)
                return null;
              if (i2 && i2.position.version === o2.version)
                return i2.position;
              if (i2)
                i2.position.version = o2.version;
              else {
                const i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, r2 = new e.ImagePosition(i3, o2);
                this.patterns[t2] = { bin: i3, position: r2 };
              }
              return this._updatePatternAtlas(), this.patterns[t2].position;
            }
            bind(t2) {
              const i2 = t2.gl;
              this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new e.Texture(t2, this.atlasImage, i2.RGBA), this.atlasTexture && this.atlasTexture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
              const t2 = [];
              for (const e2 in this.patterns)
                t2.push(this.patterns[e2].bin);
              const { w: i2, h: o2 } = e.potpack(t2), r2 = this.atlasImage;
              r2.resize({ width: i2 || 1, height: o2 || 1 });
              for (const t3 in this.patterns) {
                const { bin: i3 } = this.patterns[t3], o3 = i3.x + 1, n2 = i3.y + 1, s2 = this.images[t3].data, a2 = s2.width, l2 = s2.height;
                e.RGBAImage.copy(s2, r2, { x: 0, y: 0 }, { x: o3, y: n2 }, { width: a2, height: l2 }), e.RGBAImage.copy(s2, r2, { x: 0, y: l2 - 1 }, { x: o3, y: n2 - 1 }, { width: a2, height: 1 }), e.RGBAImage.copy(s2, r2, { x: 0, y: 0 }, { x: o3, y: n2 + l2 }, { width: a2, height: 1 }), e.RGBAImage.copy(s2, r2, { x: a2 - 1, y: 0 }, { x: o3 - 1, y: n2 }, { width: 1, height: l2 }), e.RGBAImage.copy(s2, r2, { x: 0, y: 0 }, { x: o3 + a2, y: n2 }, { width: 1, height: l2 });
              }
              this.dirty = true;
            }
            beginFrame() {
              this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(e2) {
              for (const t2 of e2) {
                if (this.callbackDispatchedThisFrame[t2])
                  continue;
                this.callbackDispatchedThisFrame[t2] = true;
                const e3 = this.images[t2];
                x(e3) && this.updateImage(t2, e3);
              }
            }
          }
          const b = new e.Properties({ anchor: new e.DataConstantProperty(e.spec.light.anchor), position: new class {
            constructor() {
              this.specification = e.spec.light.position;
            }
            possiblyEvaluate(t2, i2) {
              return function([t3, i3, o2]) {
                const r2 = e.degToRad(i3 + 90), n2 = e.degToRad(o2);
                return { x: t3 * Math.cos(r2) * Math.sin(n2), y: t3 * Math.sin(r2) * Math.sin(n2), z: t3 * Math.cos(n2), azimuthal: i3, polar: o2 };
              }(t2.expression.evaluate(i2));
            }
            interpolate(t2, i2, o2) {
              return { x: e.number(t2.x, i2.x, o2), y: e.number(t2.y, i2.y, o2), z: e.number(t2.z, i2.z, o2), azimuthal: e.number(t2.azimuthal, i2.azimuthal, o2), polar: e.number(t2.polar, i2.polar, o2) };
            }
          }(), color: new e.DataConstantProperty(e.spec.light.color), intensity: new e.DataConstantProperty(e.spec.light.intensity) }), w = "-transition";
          class T extends e.Evented {
            constructor(t2) {
              super(), this._transitionable = new e.Transitionable(b), this.setLight(t2), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
              return this._transitionable.serialize();
            }
            setLight(t2, i2 = {}) {
              if (!this._validate(e.validateLight, t2, i2))
                for (const i3 in t2) {
                  const o2 = t2[i3];
                  e.endsWith(i3, w) ? this._transitionable.setTransition(i3.slice(0, -w.length), o2) : this._transitionable.setValue(i3, o2);
                }
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            _validate(t2, i2, o2) {
              return (!o2 || false !== o2.validate) && e.emitValidationErrors(this, t2.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
            }
          }
          const E = new e.Properties({ source: new e.DataConstantProperty(e.spec.terrain.source), exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration) }), C = "-transition";
          class M extends e.Evented {
            constructor(t2, i2) {
              super(), this._transitionable = new e.Transitionable(E), this.set(t2), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i2;
            }
            get() {
              return this._transitionable.serialize();
            }
            set(t2) {
              for (const i2 in t2) {
                const o2 = t2[i2];
                e.endsWith(i2, C) ? this._transitionable.setTransition(i2.slice(0, -C.length), o2) : this._transitionable.setValue(i2, o2);
              }
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
          }
          function I(t2, i2, o2, r2) {
            const n2 = e.smoothstep(45, 65, o2), [s2, a2] = S(t2, r2), l2 = e.length(i2);
            let c2 = 1 - Math.min(1, Math.exp((l2 - s2) / (a2 - s2) * -6));
            return c2 *= c2 * c2, c2 = Math.min(1, 1.00747 * c2), c2 * n2 * t2.alpha;
          }
          function S(e2, t2) {
            const i2 = 0.5 / Math.tan(0.5 * t2);
            return [e2.range[0] + i2, e2.range[1] + i2];
          }
          const D = new e.Properties({ range: new e.DataConstantProperty(e.spec.fog.range), color: new e.DataConstantProperty(e.spec.fog.color), "high-color": new e.DataConstantProperty(e.spec.fog["high-color"]), "space-color": new e.DataConstantProperty(e.spec.fog["space-color"]), "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"]), "star-intensity": new e.DataConstantProperty(e.spec.fog["star-intensity"]) }), L = "-transition";
          class A extends e.Evented {
            constructor(t2, i2) {
              super(), this._transitionable = new e.Transitionable(D), this.set(t2), this._transitioning = this._transitionable.untransitioned(), this._transform = i2;
            }
            get state() {
              const t2 = this._transform, i2 = "globe" === t2.projection.name, o2 = e.globeToMercatorTransition(t2.zoom), r2 = this.properties.get("range"), n2 = [0.5, 3];
              return { range: i2 ? [e.number(n2[0], r2[0], o2), e.number(n2[1], r2[1], o2)] : r2, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
            }
            get() {
              return this._transitionable.serialize();
            }
            set(t2, i2 = {}) {
              if (!this._validate(e.validateFog, t2, i2)) {
                for (const i3 of Object.keys(e.spec.fog))
                  t2 && void 0 === t2[i3] && (t2[i3] = e.spec.fog[i3].default);
                for (const i3 in t2) {
                  const o2 = t2[i3];
                  e.endsWith(i3, L) ? this._transitionable.setTransition(i3.slice(0, -L.length), o2) : this._transitionable.setValue(i3, o2);
                }
              }
            }
            getOpacity(t2) {
              if (!this._transform.projection.supportsFog)
                return 0;
              const i2 = this.properties && this.properties.get("color") || 1;
              return ("globe" === this._transform.projection.name ? 1 : e.smoothstep(45, 65, t2)) * i2.a;
            }
            getOpacityAtLatLng(t2, i2) {
              return this._transform.projection.supportsFog ? function(t3, i3, o2) {
                const r2 = e.MercatorCoordinate.fromLngLat(i3), n2 = o2.elevation ? o2.elevation.getAtPointOrZero(r2) : 0, s2 = [r2.x, r2.y, n2];
                return e.transformMat4(s2, s2, o2.mercatorFogMatrix), I(t3, s2, o2.pitch, o2._fov);
              }(this.state, t2, i2) : 0;
            }
            getFovAdjustedRange(e2) {
              return this._transform.projection.supportsFog ? S(this.state, e2) : [0, 1];
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            _validate(t2, i2, o2) {
              return (!o2 || false !== o2.validate) && e.emitValidationErrors(this, t2.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
            }
          }
          class z {
            constructor(t2, i2) {
              this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();
              const o2 = this.workerPool.acquire(this.id);
              for (let e2 = 0; e2 < o2.length; e2++) {
                const t3 = new z.Actor(o2[e2], i2, this.id);
                t3.name = `Worker ${e2}`, this.actors.push(t3);
              }
              this.ready = false, this.broadcast("checkIfReady", null, () => {
                this.ready = true;
              });
            }
            broadcast(t2, i2, o2) {
              e.asyncAll(this.actors, (e2, o3) => {
                e2.send(t2, i2, o3);
              }, o2 = o2 || function() {
              });
            }
            getActor() {
              return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
              this.actors.forEach((e2) => {
                e2.remove();
              }), this.actors = [], this.workerPool.release(this.id);
            }
          }
          function P(t2, i2, o2) {
            return i2 * (e.EXTENT / (t2.tileSize * Math.pow(2, o2 - t2.tileID.overscaledZ)));
          }
          z.Actor = e.Actor;
          class R {
            constructor(e2, t2, i2, o2) {
              this.screenBounds = e2, this.cameraPoint = t2, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o2);
            }
            static createFromScreenPoints(t2, i2) {
              let o2, r2;
              if (t2 instanceof e.pointGeometry || "number" == typeof t2[0]) {
                const n2 = e.pointGeometry.convert(t2);
                o2 = [n2], r2 = i2.isPointAboveHorizon(n2);
              } else {
                const n2 = e.pointGeometry.convert(t2[0]), s2 = e.pointGeometry.convert(t2[1]);
                o2 = [n2, s2], r2 = e.polygonizeBounds(n2, s2).every((e2) => i2.isPointAboveHorizon(e2));
              }
              return new R(o2, i2.getCameraPoint(), r2, i2);
            }
            isPointQuery() {
              return 1 === this.screenBounds.length;
            }
            bufferedScreenGeometry(t2) {
              return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t2);
            }
            bufferedCameraGeometry(t2) {
              const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], r2 = e.polygonizeBounds(i2, o2, 0, false);
              return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? r2.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r2[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (r2[3] = this.cameraPoint)), e.bufferConvexPolygon(r2, t2);
            }
            bufferedCameraGeometryGlobe(t2) {
              const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], r2 = e.polygonizeBounds(i2, o2, t2), n2 = this.cameraPoint.clone();
              switch (3 * ((n2.y > i2.y) + (n2.y > o2.y)) + ((n2.x > i2.x) + (n2.x > o2.x))) {
                case 0:
                  r2[0] = n2, r2[4] = n2.clone();
                  break;
                case 1:
                  r2.splice(1, 0, n2);
                  break;
                case 2:
                  r2[1] = n2;
                  break;
                case 3:
                  r2.splice(4, 0, n2);
                  break;
                case 5:
                  r2.splice(2, 0, n2);
                  break;
                case 6:
                  r2[3] = n2;
                  break;
                case 7:
                  r2.splice(3, 0, n2);
                  break;
                case 8:
                  r2[2] = n2;
              }
              return r2;
            }
            containsTile(t2, i2, o2, r2 = 0) {
              const n2 = t2.queryPadding / i2._pixelsPerMercatorPixel + 1, s2 = o2 ? this._bufferedCameraMercator(n2, i2) : this._bufferedScreenMercator(n2, i2);
              let a2 = t2.tileID.wrap + (s2.unwrapped ? r2 : 0);
              const l2 = s2.polygon.map((i3) => e.getTilePoint(t2.tileTransform, i3, a2));
              if (!e.polygonIntersectsBox(l2, 0, 0, e.EXTENT, e.EXTENT))
                return;
              a2 = t2.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r2 : 0);
              const c2 = this.screenGeometryMercator.polygon.map((i3) => e.getTileVec3(t2.tileTransform, i3, a2)), h2 = c2.map((t3) => new e.pointGeometry(t3[0], t3[1])), u2 = i2.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0), _2 = e.getTileVec3(t2.tileTransform, u2, a2), d2 = c2.map((t3) => {
                const i3 = e.sub(t3, t3, _2);
                return e.normalize(i3, i3), new e.Ray(_2, i3);
              }), p2 = P(t2, 1, i2.zoom) * i2._pixelsPerMercatorPixel;
              return { queryGeometry: this, tilespaceGeometry: h2, tilespaceRays: d2, bufferedTilespaceGeometry: l2, bufferedTilespaceBounds: (m2 = e.getBounds(l2), m2.min.x = e.clamp(m2.min.x, 0, e.EXTENT), m2.min.y = e.clamp(m2.min.y, 0, e.EXTENT), m2.max.x = e.clamp(m2.max.x, 0, e.EXTENT), m2.max.y = e.clamp(m2.max.y, 0, e.EXTENT), m2), tile: t2, tileID: t2.tileID, pixelToTileUnitsFactor: p2 };
              var m2;
            }
            _bufferedScreenMercator(e2, t2) {
              const i2 = k(e2);
              if (this._screenRaycastCache[i2])
                return this._screenRaycastCache[i2];
              {
                let o2;
                return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e2), t2) : { polygon: this.bufferedScreenGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = o2, o2;
              }
            }
            _bufferedCameraMercator(e2, t2) {
              const i2 = k(e2);
              if (this._cameraRaycastCache[i2])
                return this._cameraRaycastCache[i2];
              {
                let o2;
                return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e2), t2) : { polygon: this.bufferedCameraGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = o2, o2;
              }
            }
            _projectAndResample(t2, i2) {
              const o2 = function(t3, i3) {
                const o3 = e.multiply([], i3.pixelMatrix, i3.globeMatrix), r3 = [0, -e.GLOBE_RADIUS, 0, 1], n2 = [0, e.GLOBE_RADIUS, 0, 1], s2 = [0, 0, 0, 1];
                e.transformMat4$1(r3, r3, o3), e.transformMat4$1(n2, n2, o3), e.transformMat4$1(s2, s2, o3);
                const a2 = new e.pointGeometry(r3[0] / r3[3], r3[1] / r3[3]), l2 = new e.pointGeometry(n2[0] / n2[3], n2[1] / n2[3]), c2 = e.polygonContainsPoint(t3, a2) && r3[3] < s2[3], h2 = e.polygonContainsPoint(t3, l2) && n2[3] < s2[3];
                if (!c2 && !h2)
                  return null;
                const u2 = function(e2, t4, i4) {
                  for (let o4 = 1; o4 < e2.length; o4++) {
                    const r4 = B(t4.pointCoordinate3D(e2[o4 - 1]).x), n3 = B(t4.pointCoordinate3D(e2[o4]).x);
                    if (i4 < 0) {
                      if (r4 < n3)
                        return { idx: o4, t: -r4 / (n3 - 1 - r4) };
                    } else if (n3 < r4)
                      return { idx: o4, t: (1 - r4) / (n3 + 1 - r4) };
                  }
                  return null;
                }(t3, i3, c2 ? -1 : 1);
                if (!u2)
                  return null;
                const { idx: _2, t: d2 } = u2;
                let p2 = _2 > 1 ? O(t3.slice(0, _2), i3) : [], m2 = _2 < t3.length ? O(t3.slice(_2), i3) : [];
                p2 = p2.map((t4) => new e.pointGeometry(B(t4.x), t4.y)), m2 = m2.map((t4) => new e.pointGeometry(B(t4.x), t4.y));
                const f2 = [...p2];
                0 === f2.length && f2.push(m2[m2.length - 1]);
                const g2 = e.number(f2[f2.length - 1].y, (0 === m2.length ? p2[0] : m2[0]).y, d2);
                let v2;
                return v2 = c2 ? [new e.pointGeometry(0, g2), new e.pointGeometry(0, 0), new e.pointGeometry(1, 0), new e.pointGeometry(1, g2)] : [new e.pointGeometry(1, g2), new e.pointGeometry(1, 1), new e.pointGeometry(0, 1), new e.pointGeometry(0, g2)], f2.push(...v2), 0 === m2.length ? f2.push(p2[0]) : f2.push(...m2), { polygon: f2.map((t4) => new e.MercatorCoordinate(t4.x, t4.y)), unwrapped: false };
              }(t2, i2);
              if (o2)
                return o2;
              const r2 = function(t3, i3) {
                let o3 = false, r3 = -1 / 0, n2 = 0;
                for (let e2 = 0; e2 < t3.length - 1; e2++)
                  t3[e2].x > r3 && (r3 = t3[e2].x, n2 = e2);
                for (let e2 = 0; e2 < t3.length - 1; e2++) {
                  const i4 = (n2 + e2) % (t3.length - 1), r4 = t3[i4], s3 = t3[i4 + 1];
                  Math.abs(r4.x - s3.x) > 0.5 && (r4.x < s3.x ? (r4.x += 1, 0 === i4 && (t3[t3.length - 1].x += 1)) : (s3.x += 1, i4 + 1 === t3.length - 1 && (t3[0].x += 1)), o3 = true);
                }
                const s2 = e.mercatorXfromLng(i3.center.lng);
                return o3 && s2 < Math.abs(s2 - 1) && t3.forEach((e2) => {
                  e2.x -= 1;
                }), { polygon: t3, unwrapped: o3 };
              }(O(t2, i2).map((t3) => new e.pointGeometry(B(t3.x), t3.y)), i2);
              return { polygon: r2.polygon.map((t3) => new e.MercatorCoordinate(t3.x, t3.y)), unwrapped: r2.unwrapped };
            }
          }
          function O(t2, i2) {
            return e.resample(t2, (e2) => {
              const t3 = i2.pointCoordinate3D(e2);
              e2.x = t3.x, e2.y = t3.y;
            }, 1 / 256);
          }
          function B(e2) {
            return e2 < 0 ? 1 + e2 % 1 : e2 % 1;
          }
          function k(e2) {
            return 100 * e2 | 0;
          }
          function F(t2, i2, o2, r2, n2) {
            const s2 = function(o3, r3) {
              if (o3)
                return n2(o3);
              if (r3) {
                t2.url && r3.tiles && t2.tiles && delete t2.tiles;
                const o4 = e.pick(e.extend(r3, t2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
                r3.vector_layers && (o4.vectorLayers = r3.vector_layers, o4.vectorLayerIds = o4.vectorLayers.map((e2) => e2.id)), o4.tiles = i2.canonicalizeTileset(o4, t2.url), n2(null, o4);
              }
            };
            return t2.url ? e.getJSON(i2.transformRequest(i2.normalizeSourceURL(t2.url, null, o2, r2), e.ResourceType.Source), s2) : e.exported.frame(() => s2(null, t2));
          }
          class U {
            constructor(t2, i2, o2) {
              this.bounds = e.LngLatBounds.convert(this.validateBounds(t2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
            }
            validateBounds(e2) {
              return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
            }
            contains(t2) {
              const i2 = Math.pow(2, t2.z), o2 = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i2), r2 = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i2), n2 = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i2), s2 = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i2);
              return t2.x >= o2 && t2.x < n2 && t2.y >= r2 && t2.y < s2;
            }
          }
          class N {
            constructor(e2, t2, i2) {
              this.context = e2;
              const o2 = e2.gl;
              this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || t2.destroy();
            }
            bind() {
              this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e2) {
              const t2 = this.context.gl;
              this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          const G = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
          class j {
            constructor(e2, t2, i2, o2) {
              this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = o2, this.context = e2;
              const r2 = e2.gl;
              this.buffer = r2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), r2.bufferData(r2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || t2.destroy();
            }
            bind() {
              this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e2) {
              const t2 = this.context.gl;
              this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
            }
            enableAttributes(e2, t2) {
              for (let i2 = 0; i2 < this.attributes.length; i2++) {
                const o2 = t2.attributes[this.attributes[i2].name];
                void 0 !== o2 && e2.enableVertexAttribArray(o2);
              }
            }
            setVertexAttribPointers(e2, t2, i2) {
              for (let o2 = 0; o2 < this.attributes.length; o2++) {
                const r2 = this.attributes[o2], n2 = t2.attributes[r2.name];
                void 0 !== n2 && e2.vertexAttribPointer(n2, r2.components, e2[G[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i2 || 0));
              }
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          class Z {
            constructor(e2) {
              this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
            }
            get() {
              return this.current;
            }
            set(e2) {
            }
            getDefault() {
              return this.default;
            }
            setDefault() {
              this.set(this.default);
            }
          }
          class V extends Z {
            getDefault() {
              return e.Color.transparent;
            }
            set(e2) {
              const t2 = this.current;
              (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
            }
          }
          class W extends Z {
            getDefault() {
              return 1;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
            }
          }
          class X extends Z {
            getDefault() {
              return 0;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
            }
          }
          class q extends Z {
            getDefault() {
              return [true, true, true, true];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
            }
          }
          class $ extends Z {
            getDefault() {
              return true;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
            }
          }
          class H extends Z {
            getDefault() {
              return 255;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
            }
          }
          class Y extends Z {
            getDefault() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }
            set(e2) {
              const t2 = this.current;
              (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
            }
          }
          class K extends Z {
            getDefault() {
              const e2 = this.gl;
              return [e2.KEEP, e2.KEEP, e2.KEEP];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
            }
          }
          class J extends Z {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
            }
          }
          class Q extends Z {
            getDefault() {
              return [0, 1];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
            }
          }
          class ee extends Z {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
            }
          }
          class te extends Z {
            getDefault() {
              return this.gl.LESS;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
            }
          }
          class ie extends Z {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
            }
          }
          class oe extends Z {
            getDefault() {
              const e2 = this.gl;
              return [e2.ONE, e2.ZERO];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
            }
          }
          class re extends Z {
            getDefault() {
              return e.Color.transparent;
            }
            set(e2) {
              const t2 = this.current;
              (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
            }
          }
          class ne extends Z {
            getDefault() {
              return this.gl.FUNC_ADD;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
            }
          }
          class se extends Z {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
            }
          }
          class ae extends Z {
            getDefault() {
              return this.gl.BACK;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
            }
          }
          class le extends Z {
            getDefault() {
              return this.gl.CCW;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
            }
          }
          class ce extends Z {
            getDefault() {
              return null;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
            }
          }
          class he extends Z {
            getDefault() {
              return this.gl.TEXTURE0;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
            }
          }
          class ue extends Z {
            getDefault() {
              const e2 = this.gl;
              return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
            }
          }
          class _e extends Z {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class de extends Z {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class pe extends Z {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
            }
          }
          class me extends Z {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class fe extends Z {
            getDefault() {
              return null;
            }
            set(e2) {
              const t2 = this.gl;
              t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class ge extends Z {
            constructor(e2) {
              super(e2), this.vao = e2.extVertexArrayObject;
            }
            getDefault() {
              return null;
            }
            set(e2) {
              this.vao && (e2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e2), this.current = e2, this.dirty = false);
            }
          }
          class ve extends Z {
            getDefault() {
              return 4;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
            }
          }
          class xe extends Z {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
            }
          }
          class ye extends Z {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
            }
          }
          class be extends Z {
            constructor(e2, t2) {
              super(e2), this.context = e2, this.parent = t2;
            }
            getDefault() {
              return null;
            }
          }
          class we extends be {
            setDirty() {
              this.dirty = true;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
            }
          }
          class Te extends be {
            attachment() {
              return this.gl.DEPTH_ATTACHMENT;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferRenderbuffer(t2.FRAMEBUFFER, this.attachment(), t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class Ee extends Te {
            attachment() {
              return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
          }
          class Ce {
            constructor(e2, t2, i2, o2) {
              this.context = e2, this.width = t2, this.height = i2;
              const r2 = this.framebuffer = e2.gl.createFramebuffer();
              this.colorAttachment = new we(e2, r2), o2 && (this.depthAttachment = new Te(e2, r2));
            }
            destroy() {
              const e2 = this.context.gl, t2 = this.colorAttachment.get();
              if (t2 && e2.deleteTexture(t2), this.depthAttachment) {
                const t3 = this.depthAttachment.get();
                t3 && e2.deleteRenderbuffer(t3);
              }
              e2.deleteFramebuffer(this.framebuffer);
            }
          }
          class Me {
            constructor(e2, t2 = false) {
              if (this.gl = e2, this.isWebGL2 = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), t2) {
                const t3 = e2;
                this.extVertexArrayObject = { createVertexArrayOES: t3.createVertexArray.bind(e2), deleteVertexArrayOES: t3.deleteVertexArray.bind(e2), bindVertexArrayOES: t3.bindVertexArray.bind(e2) };
              }
              this.clearColor = new V(this), this.clearDepth = new W(this), this.clearStencil = new X(this), this.colorMask = new q(this), this.depthMask = new $(this), this.stencilMask = new H(this), this.stencilFunc = new Y(this), this.stencilOp = new K(this), this.stencilTest = new J(this), this.depthRange = new Q(this), this.depthTest = new ee(this), this.depthFunc = new te(this), this.blend = new ie(this), this.blendFunc = new oe(this), this.blendColor = new re(this), this.blendEquation = new ne(this), this.cullFace = new se(this), this.cullFaceSide = new ae(this), this.frontFace = new le(this), this.program = new ce(this), this.activeTexture = new he(this), this.viewport = new ue(this), this.bindFramebuffer = new _e(this), this.bindRenderbuffer = new de(this), this.bindTexture = new pe(this), this.bindVertexBuffer = new me(this), this.bindElementBuffer = new fe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ge(this), this.pixelStoreUnpack = new ve(this), this.pixelStoreUnpackPremultiplyAlpha = new xe(this), this.pixelStoreUnpackFlipY = new ye(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = false, this.extStandardDerivativesForceOff = false, this.extDebugRendererInfo = e2.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e2.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e2.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t2 || (this.extTextureHalfFloat = e2.getExtension("OES_texture_half_float")), (t2 || this.extTextureHalfFloat && e2.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = e2.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = t2 || e2.getExtension("OES_standard_derivatives"), this.extTimerQuery = e2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE);
            }
            setDefault() {
              this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
              this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
            }
            createIndexBuffer(e2, t2) {
              return new N(this, e2, t2);
            }
            createVertexBuffer(e2, t2, i2) {
              return new j(this, e2, t2, i2);
            }
            createRenderbuffer(e2, t2, i2) {
              const o2 = this.gl, r2 = o2.createRenderbuffer();
              return this.bindRenderbuffer.set(r2), o2.renderbufferStorage(o2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), r2;
            }
            createFramebuffer(e2, t2, i2) {
              return new Ce(this, e2, t2, i2);
            }
            clear({ color: e2, depth: t2, stencil: i2 }) {
              const o2 = this.gl;
              let r2 = 0;
              e2 && (r2 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== t2 && (r2 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (r2 |= o2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), o2.clear(r2);
            }
            setCullFace(e2) {
              false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
            }
            setDepthMode(e2) {
              e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
            }
            setStencilMode(e2) {
              e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
            }
            setColorMode(i2) {
              t(i2.blendFunction, e.ColorMode.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(i2.blendFunction), this.blendColor.set(i2.blendColor)), this.colorMask.set(i2.mask);
            }
            unbindVAO() {
              this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
            }
          }
          class Ie extends e.Evented {
            constructor(t2, i2, o2, r2) {
              if (super(), this.id = t2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.extend(this, e.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize)
                throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(r2), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();
            }
            load(t2) {
              this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" }));
              const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map._worldview;
              this._tileJSONRequest = F(this._options, this.map._requestManager, i2, o2, (r2, n2) => {
                this._tileJSONRequest = null, this._loaded = true, r2 ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && 2 !== o2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.ErrorEvent(r2))) : n2 && (e.extend(this, n2), n2.bounds && (this.tileBounds = new U(n2.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(r2);
              });
            }
            loaded() {
              return this._loaded;
            }
            hasTile(e2) {
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            reload() {
              this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
            }
            setTiles(e2) {
              return this._options.tiles = e2, this.reload(), this;
            }
            setUrl(e2) {
              return this.url = e2, this._options.url = e2, this.reload(), this;
            }
            onRemove() {
              this.cancelTileJSONRequest();
            }
            serialize() {
              return e.extend({}, this._options);
            }
            loadTile(t2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), r2 = { request: this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t2.isSymbolTile };
              if (r2.request.collectResourceTiming = this._collectResourceTiming, t2.actor && "expired" !== t2.state)
                "loading" === t2.state ? t2.reloadCallback = i2 : t2.request = t2.actor.send("reloadTile", r2, n2.bind(this));
              else if (t2.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready)
                t2.request = t2.actor.send("loadTile", r2, n2.bind(this), void 0, true);
              else {
                const i3 = e.loadVectorTile.call({ deduped: this._deduped }, r2, (e2, i4) => {
                  e2 || !i4 ? n2.call(this, e2) : (r2.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t2.actor && t2.actor.send("loadTile", r2, n2.bind(this), void 0, true));
                }, true);
                t2.request = { cancel: i3 };
              }
              function n2(o3, r3) {
                return delete t2.request, t2.aborted ? i2(null) : o3 && 404 !== o3.status ? i2(o3) : (r3 && r3.resourceTiming && (t2.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && t2.setExpiryData(r3), t2.loadVectorData(r3, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (t2.reloadCallback && (this.loadTile(t2, t2.reloadCallback), t2.reloadCallback = null)));
              }
            }
            abortTile(e2) {
              e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id });
            }
            unloadTile(e2) {
              e2.unloadVectorData(), e2.actor && e2.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
            }
            hasTransition() {
              return false;
            }
            afterUpdate() {
              this._tileWorkers = {};
            }
            cancelTileJSONRequest() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
          }
          class Se extends e.Evented {
            constructor(t2, i2, o2, r2) {
              super(), this.id = t2, this.dispatcher = o2, this.setEventedParent(r2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.extend({ type: "raster" }, i2), e.extend(this, e.pick(i2, ["url", "scheme", "tileSize"]));
            }
            load(t2) {
              this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = F(this._options, this.map._requestManager, null, null, (i2, o2) => {
                this._tileJSONRequest = null, this._loaded = true, i2 ? this.fire(new e.ErrorEvent(i2)) : o2 && (e.extend(this, o2), o2.bounds && (this.tileBounds = new U(o2.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(o2.tiles), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(i2);
              });
            }
            loaded() {
              return this._loaded;
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            reload() {
              this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
            }
            setTiles(e2) {
              return this._options.tiles = e2, this.reload(), this;
            }
            setUrl(e2) {
              return this.url = e2, this._options.url = e2, this.reload(), this;
            }
            onRemove() {
              this.cancelTileJSONRequest();
            }
            serialize() {
              return e.extend({}, this._options);
            }
            hasTile(e2) {
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            loadTile(t2, i2) {
              const o2 = e.exported.devicePixelRatio >= 2, r2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
              t2.request = e.getImage(this.map._requestManager.transformRequest(r2, e.ResourceType.Tile), (o3, r3, n2, s2) => (delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : o3 ? (t2.state = "errored", i2(o3)) : r3 ? (this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: n2, expires: s2 }), t2.setTexture(r3, this.map.painter), t2.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), void i2(null)) : i2(null)));
            }
            static loadTileData(e2, t2, i2) {
              e2.setTexture(t2, i2);
            }
            static unloadTileData(e2, t2) {
              e2.texture && t2.saveTileTexture(e2.texture);
            }
            abortTile(e2, t2) {
              e2.request && (e2.request.cancel(), delete e2.request), t2();
            }
            unloadTile(e2, t2) {
              e2.texture && this.map.painter.saveTileTexture(e2.texture), t2();
            }
            hasTransition() {
              return false;
            }
            cancelTileJSONRequest() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
          }
          let De;
          function Le(t2, i2, o2, r2, n2, s2, a2, l2) {
            const c2 = [t2, o2, n2, i2, r2, s2, 1, 1, 1], h2 = [a2, l2, 1], u2 = e.adjoint([], c2), [_2, d2, p2] = e.transformMat3(h2, h2, e.transpose(u2, u2));
            return e.multiply$1(c2, [_2, 0, 0, 0, d2, 0, 0, 0, p2], c2);
          }
          class Ae extends e.Evented {
            constructor(e2, t2, i2, o2) {
              super(), this.id = e2, this.dispatcher = i2, this.coordinates = t2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = t2, this._dirty = false;
            }
            load(t2, i2) {
              this._loaded = i2 || false, this.fire(new e.Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._imageRequest = e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i3, o2) => {
                if (this._imageRequest = null, this._loaded = true, i3)
                  this.fire(new e.ErrorEvent(i3));
                else if (o2) {
                  const { HTMLImageElement: i4 } = e.window;
                  this.image = o2 instanceof i4 ? e.exported.getImageData(o2) : o2, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t2 && (this.coordinates = t2), this._finishLoading();
                }
              });
            }
            loaded() {
              return this._loaded;
            }
            updateImage(e2) {
              return this.image && e2.url ? (this._imageRequest && e2.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e2.url, this.load(e2.coordinates, this._loaded), this) : this;
            }
            _finishLoading() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })));
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            onRemove() {
              this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
            }
            setCoordinates(t2) {
              this.coordinates = t2, this._boundsArray = void 0;
              const i2 = t2.map(e.MercatorCoordinate.fromLngLat);
              return this.tileID = function(t3) {
                let i3 = 1 / 0, o2 = 1 / 0, r2 = -1 / 0, n2 = -1 / 0;
                for (const e2 of t3)
                  i3 = Math.min(i3, e2.x), o2 = Math.min(o2, e2.y), r2 = Math.max(r2, e2.x), n2 = Math.max(n2, e2.y);
                const s2 = Math.max(r2 - i3, n2 - o2), a2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), l2 = Math.pow(2, a2);
                return new e.CanonicalTileID(a2, Math.floor((i3 + r2) / 2 * l2), Math.floor((o2 + n2) / 2 * l2));
              }(i2), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })), this;
            }
            _clear() {
              this._boundsArray = void 0;
            }
            _prepareData(t2) {
              for (const e2 in this.tiles) {
                const t3 = this.tiles[e2];
                "loaded" !== t3.state && (t3.state = "loaded", t3.texture = this.texture);
              }
              if (this._boundsArray)
                return;
              const i2 = e.tileTransform(this.tileID, this.map.transform.projection), [o2, r2, n2, s2] = this.coordinates.map((t3) => {
                const o3 = i2.projection.project(t3[0], t3[1]);
                return e.getTilePoint(i2, o3)._round();
              });
              this.perspectiveTransform = function(t3, i3, o3, r3, n3, s3, a3, l2, c2, h2) {
                const u2 = Le(0, 0, t3, 0, 0, i3, t3, i3), _2 = Le(o3, r3, n3, s3, a3, l2, c2, h2);
                return e.multiply$1(_2, e.adjoint(u2, u2), _2), [_2[6] / _2[8] * t3 / e.EXTENT, _2[7] / _2[8] * i3 / e.EXTENT];
              }(this.width, this.height, o2.x, o2.y, r2.x, r2.y, s2.x, s2.y, n2.x, n2.y);
              const a2 = this._boundsArray = new e.StructArrayLayout4i8();
              a2.emplaceBack(o2.x, o2.y, 0, 0), a2.emplaceBack(r2.x, r2.y, e.EXTENT, 0), a2.emplaceBack(s2.x, s2.y, 0, e.EXTENT), a2.emplaceBack(n2.x, n2.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t2.createVertexBuffer(a2, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
            }
            prepare() {
              if (0 === Object.keys(this.tiles).length || !this.image)
                return;
              const t2 = this.map.painter.context, i2 = t2.gl;
              this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE)), this._dirty = false), this._prepareData(t2);
            }
            loadTile(e2, t2) {
              this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}, t2(null)) : (e2.state = "errored", t2(null));
            }
            serialize() {
              return { type: "image", url: this.options.url, coordinates: this.coordinates };
            }
            hasTransition() {
              return false;
            }
          }
          const ze = { vector: Ie, raster: Se, "raster-dem": class extends Se {
            constructor(t2, i2, o2, r2) {
              super(t2, i2, o2, r2), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
            }
            loadTile(t2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
              function r2(e2, o3) {
                e2 && (t2.state = "errored", i2(e2)), o3 && (t2.dem = o3, t2.dem.onDeserialize(), t2.needsHillshadePrepare = true, t2.needsDEMTextureUpload = true, t2.state = "loaded", i2(null));
              }
              t2.request = e.getImage(this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), function(o3, n2, s2, a2) {
                if (delete t2.request, t2.aborted)
                  t2.state = "unloaded", i2(null);
                else if (o3)
                  t2.state = "errored", i2(o3);
                else if (n2) {
                  this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: s2, expires: a2 });
                  const i3 = e.window.ImageBitmap && n2 instanceof e.window.ImageBitmap && (null == De && (De = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e.window.createImageBitmap), De), o4 = 1 - (n2.width - e.prevPowerOfTwo(n2.width)) / 2;
                  o4 < 1 || t2.neighboringTiles || (t2.neighboringTiles = this._getNeighboringTiles(t2.tileID));
                  const l2 = i3 ? n2 : e.exported.getImageData(n2, o4), c2 = { uid: t2.uid, coord: t2.tileID, source: this.id, rawImageData: l2, encoding: this.encoding, padding: o4 };
                  t2.actor && "expired" !== t2.state || (t2.actor = this.dispatcher.getActor(), t2.actor.send("loadDEMTile", c2, r2.bind(this), void 0, true));
                }
              }.bind(this));
            }
            _getNeighboringTiles(t2) {
              const i2 = t2.canonical, o2 = Math.pow(2, i2.z), r2 = (i2.x - 1 + o2) % o2, n2 = 0 === i2.x ? t2.wrap - 1 : t2.wrap, s2 = (i2.x + 1 + o2) % o2, a2 = i2.x + 1 === o2 ? t2.wrap + 1 : t2.wrap, l2 = {};
              return l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r2, i2.y).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r2, i2.y - 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r2, i2.y + 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s2, i2.y + 1).key] = { backfilled: false }), l2;
            }
            unloadTile(e2) {
              e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded";
            }
          }, geojson: class extends e.Evented {
            constructor(t2, i2, o2, r2) {
              super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r2), this._data = i2.data, this._options = e.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
              const n2 = e.EXTENT / this.tileSize;
              this.workerOptions = e.extend({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * n2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * n2, extent: e.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.EXTENT, radius: (void 0 !== i2.clusterRadius ? i2.clusterRadius : 50) * n2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
            }
            onAdd(e2) {
              this.map = e2, this.setData(this._data);
            }
            setData(e2) {
              return this._data = e2, this._updateWorkerData(), this;
            }
            getClusterExpansionZoom(e2, t2) {
              return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e2, source: this.id }, t2), this;
            }
            getClusterChildren(e2, t2) {
              return this.actor.send("geojson.getClusterChildren", { clusterId: e2, source: this.id }, t2), this;
            }
            getClusterLeaves(e2, t2, i2, o2) {
              return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e2, limit: t2, offset: i2 }, o2), this;
            }
            _updateWorkerData() {
              if (this._pendingLoad)
                return void (this._coalesce = true);
              this.fire(new e.Event("dataloading", { dataType: "source" })), this._loaded = false;
              const t2 = e.extend({}, this.workerOptions), i2 = this._data;
              "string" == typeof i2 ? (t2.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i2), e.ResourceType.Source), t2.request.collectResourceTiming = this._collectResourceTiming) : t2.data = JSON.stringify(i2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t2, (t3, i3) => {
                if (this._loaded = true, this._pendingLoad = null, t3)
                  this.fire(new e.ErrorEvent(t3));
                else {
                  const t4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                  this._collectResourceTiming && i3 && i3.resourceTiming && i3.resourceTiming[this.id] && (t4.resourceTiming = i3.resourceTiming[this.id]), this.fire(new e.Event("data", t4)), this._metadataFired = true;
                }
                this._coalesce && (this._updateWorkerData(), this._coalesce = false);
              });
            }
            loaded() {
              return this._loaded;
            }
            loadTile(t2, i2) {
              const o2 = t2.actor ? "reloadTile" : "loadTile";
              t2.actor = this.actor, t2.request = this.actor.send(o2, { type: this.type, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (e2, r2) => (delete t2.request, t2.unloadVectorData(), t2.aborted ? i2(null) : e2 ? i2(e2) : (t2.loadVectorData(r2, this.map.painter, "reloadTile" === o2), i2(null))), void 0, "loadTile" === o2);
            }
            abortTile(e2) {
              e2.request && (e2.request.cancel(), delete e2.request), e2.aborted = true;
            }
            unloadTile(e2) {
              e2.unloadVectorData(), this.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
            }
            onRemove() {
              this._pendingLoad && this._pendingLoad.cancel();
            }
            serialize() {
              return e.extend({}, this._options, { type: this.type, data: this._data });
            }
            hasTransition() {
              return false;
            }
          }, video: class extends Ae {
            constructor(e2, t2, i2, o2) {
              super(e2, t2, i2, o2), this.roundZoom = true, this.type = "video", this.options = t2;
            }
            load() {
              this._loaded = false;
              const t2 = this.options;
              this.urls = [];
              for (const i2 of t2.urls)
                this.urls.push(this.map._requestManager.transformRequest(i2, e.ResourceType.Source).url);
              e.getVideo(this.urls, (t3, i2) => {
                this._loaded = true, t3 ? this.fire(new e.ErrorEvent(t3)) : i2 && (this.video = i2, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading());
              });
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(t2) {
              if (this.video) {
                const i2 = this.video.seekable;
                t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(e2) {
              this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            prepare() {
              if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
                return;
              const t2 = this.map.painter.context, i2 = t2.gl;
              this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t2);
            }
            serialize() {
              return { type: "video", urls: this.urls, coordinates: this.coordinates };
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          }, image: Ae, canvas: class extends Ae {
            constructor(t2, i2, o2, r2) {
              super(t2, i2, o2, r2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e2) => !Array.isArray(e2) || 2 !== e2.length || e2.some((e3) => "number" != typeof e3)) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
            }
            load() {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(e2) {
              this.map = e2, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove() {
              this.pause();
            }
            prepare() {
              let t2 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions())
                return;
              if (0 === Object.keys(this.tiles).length)
                return;
              const i2 = this.map.painter.context;
              this.texture ? (t2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e.Texture(i2, this.canvas, i2.gl.RGBA, { premultiply: true }), this._prepareData(i2);
            }
            serialize() {
              return { type: "canvas", coordinates: this.coordinates };
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const e2 of [this.canvas.width, this.canvas.height])
                if (isNaN(e2) || e2 <= 0)
                  return true;
              return false;
            }
          }, custom: class extends e.Evented {
            constructor(t2, i2, o2, r2) {
              super(), this.id = t2, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i2, this.setEventedParent(r2), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new U(this._implementation.bounds, this.minzoom, this.maxzoom)), i2.update = this._update.bind(this), i2.clearTiles = this._clearTiles.bind(this), i2.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(i2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
            }
            serialize() {
              return e.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
            }
            load() {
              this._loaded = true, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
            }
            loaded() {
              return this._loaded;
            }
            onAdd(t2) {
              this._map = t2, this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t2), this.load();
            }
            onRemove(e2) {
              this._implementation.onRemove && this._implementation.onRemove(e2);
            }
            hasTile(e2) {
              if (this._implementation.hasTile) {
                const { x: t2, y: i2, z: o2 } = e2.canonical;
                return this._implementation.hasTile({ x: t2, y: i2, z: o2 });
              }
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            loadTile(t2, i2) {
              const { x: o2, y: r2, z: n2 } = t2.tileID.canonical, s2 = new e.window.AbortController();
              t2.request = Promise.resolve(this._implementation.loadTile({ x: o2, y: r2, z: n2 }, { signal: s2.signal })).then(function(o3) {
                return delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : void 0 === o3 ? (t2.state = "errored", i2(null)) : null === o3 ? (this.loadTileData(t2, { width: this.tileSize, height: this.tileSize, data: null }), t2.state = "loaded", i2(null)) : function(t3) {
                  return t3 instanceof e.window.ImageData || t3 instanceof e.window.HTMLCanvasElement || t3 instanceof e.window.ImageBitmap || t3 instanceof e.window.HTMLImageElement;
                }(o3) ? (this.loadTileData(t2, o3), t2.state = "loaded", void i2(null)) : (t2.state = "errored", i2(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
              }.bind(this)).catch((e2) => {
                20 !== e2.code && (t2.state = "errored", i2(e2));
              }), t2.request.cancel = () => s2.abort();
            }
            loadTileData(e2, t2) {
              Se.loadTileData(e2, t2, this._map.painter);
            }
            unloadTileData(e2) {
              Se.unloadTileData(e2, this._map.painter);
            }
            unloadTile(e2, t2) {
              if (this.unloadTileData(e2), this._implementation.unloadTile) {
                const { x: t3, y: i2, z: o2 } = e2.tileID.canonical;
                this._implementation.unloadTile({ x: t3, y: i2, z: o2 });
              }
              t2();
            }
            abortTile(e2, t2) {
              e2.request && e2.request.cancel && (e2.request.cancel(), delete e2.request), t2();
            }
            hasTransition() {
              return false;
            }
            _coveringTiles() {
              return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e2) => ({ x: e2.canonical.x, y: e2.canonical.y, z: e2.canonical.z }));
            }
            _clearTiles() {
              this._map.style._clearSource(this.id);
            }
            _update() {
              this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
            }
          } }, Pe = function(t2, i2, o2, r2) {
            const n2 = new ze[i2.type](t2, i2, o2, r2);
            if (n2.id !== t2)
              throw new Error(`Expected Source id to be ${t2} instead of ${n2.id}`);
            return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], n2), n2;
          };
          function Re(t2, i2) {
            const o2 = e.identity([]);
            return e.scale(o2, o2, [0.5 * t2.width, 0.5 * -t2.height, 1]), e.translate(o2, o2, [1, -1, 0]), e.multiply(o2, o2, t2.calculateProjMatrix(i2.toUnwrapped())), Float32Array.from(o2);
          }
          function Oe(e2, t2, i2, o2, r2, n2, s2, a2 = false) {
            const l2 = e2.tilesIn(o2, s2, a2);
            l2.sort(ke);
            const c2 = [];
            for (const o3 of l2)
              c2.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(t2, i2, e2._state, o3, r2, n2, Re(e2.transform, o3.tile.tileID), a2) });
            const h2 = function(e3) {
              const t3 = {}, i3 = {};
              for (const o3 of e3) {
                const e4 = o3.queryResults, r3 = o3.wrappedTileID, n3 = i3[r3] = i3[r3] || {};
                for (const i4 in e4) {
                  const o4 = e4[i4], r4 = n3[i4] = n3[i4] || {}, s3 = t3[i4] = t3[i4] || [];
                  for (const e5 of o4)
                    r4[e5.featureIndex] || (r4[e5.featureIndex] = true, s3.push(e5));
                }
              }
              return t3;
            }(c2);
            for (const t3 in h2)
              h2[t3].forEach((t4) => {
                const i3 = t4.feature, o3 = i3.layer;
                o3 && "background" !== o3.type && "sky" !== o3.type && (i3.source = o3.source, o3["source-layer"] && (i3.sourceLayer = o3["source-layer"]), i3.state = void 0 !== i3.id ? e2.getFeatureState(o3["source-layer"], i3.id) : {});
              });
            return h2;
          }
          function Be(e2, t2) {
            const i2 = e2.getRenderableIds().map((t3) => e2.getTileByID(t3)), o2 = [], r2 = {};
            for (let e3 = 0; e3 < i2.length; e3++) {
              const n2 = i2[e3], s2 = n2.tileID.canonical.key;
              r2[s2] || (r2[s2] = true, n2.querySourceFeatures(o2, t2));
            }
            return o2;
          }
          function ke(e2, t2) {
            const i2 = e2.tileID, o2 = t2.tileID;
            return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
          }
          function Fe() {
            return null != fn2.workerClass ? new fn2.workerClass() : new e.window.Worker(fn2.workerUrl);
          }
          const Ue = "mapboxgl_preloaded_worker_pool";
          class Ne {
            constructor() {
              this.active = {};
            }
            acquire(e2) {
              if (!this.workers)
                for (this.workers = []; this.workers.length < Ne.workerCount; )
                  this.workers.push(new Fe());
              return this.active[e2] = true, this.workers.slice();
            }
            release(e2) {
              delete this.active[e2], 0 === this.numActive() && (this.workers.forEach((e3) => {
                e3.terminate();
              }), this.workers = null);
            }
            isPreloaded() {
              return !!this.active[Ue];
            }
            numActive() {
              return Object.keys(this.active).length;
            }
          }
          let Ge;
          function je() {
            return Ge || (Ge = new Ne()), Ge;
          }
          function Ze(t2, i2) {
            const o2 = {};
            for (const e2 in t2)
              "ref" !== e2 && (o2[e2] = t2[e2]);
            return e.refProperties.forEach((e2) => {
              e2 in i2 && (o2[e2] = i2[e2]);
            }), o2;
          }
          function Ve(e2) {
            e2 = e2.slice();
            const t2 = /* @__PURE__ */ Object.create(null);
            for (let i2 = 0; i2 < e2.length; i2++)
              t2[e2[i2].id] = e2[i2];
            for (let i2 = 0; i2 < e2.length; i2++)
              "ref" in e2[i2] && (e2[i2] = Ze(e2[i2], t2[e2[i2].ref]));
            return e2;
          }
          Ne.workerCount = 2;
          const We = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" };
          function Xe(e2, t2, i2) {
            i2.push({ command: We.addSource, args: [e2, t2[e2]] });
          }
          function qe(e2, t2, i2) {
            t2.push({ command: We.removeSource, args: [e2] }), i2[e2] = true;
          }
          function $e(e2, t2, i2, o2) {
            qe(e2, i2, o2), Xe(e2, t2, i2);
          }
          function He(e2, i2, o2) {
            let r2;
            for (r2 in e2[o2])
              if (e2[o2].hasOwnProperty(r2) && "data" !== r2 && !t(e2[o2][r2], i2[o2][r2]))
                return false;
            for (r2 in i2[o2])
              if (i2[o2].hasOwnProperty(r2) && "data" !== r2 && !t(e2[o2][r2], i2[o2][r2]))
                return false;
            return true;
          }
          function Ye(e2, i2, o2, r2, n2, s2) {
            let a2;
            for (a2 in i2 = i2 || {}, e2 = e2 || {})
              e2.hasOwnProperty(a2) && (t(e2[a2], i2[a2]) || o2.push({ command: s2, args: [r2, a2, i2[a2], n2] }));
            for (a2 in i2)
              i2.hasOwnProperty(a2) && !e2.hasOwnProperty(a2) && (t(e2[a2], i2[a2]) || o2.push({ command: s2, args: [r2, a2, i2[a2], n2] }));
          }
          function Ke(e2) {
            return e2.id;
          }
          function Je(e2, t2) {
            return e2[t2.id] = t2, e2;
          }
          class Qe {
            constructor(e2, t2) {
              this.reset(e2, t2);
            }
            reset(e2, t2) {
              this.points = e2 || [], this._distances = [0];
              for (let e3 = 1; e3 < this.points.length; e3++)
                this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
              this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(t2) {
              if (1 === this.points.length)
                return this.points[0];
              t2 = e.clamp(t2, 0, 1);
              let i2 = 1, o2 = this._distances[i2];
              const r2 = t2 * this.paddedLength + this.padding;
              for (; o2 < r2 && i2 < this._distances.length; )
                o2 = this._distances[++i2];
              const n2 = i2 - 1, s2 = this._distances[n2], a2 = o2 - s2, l2 = a2 > 0 ? (r2 - s2) / a2 : 0;
              return this.points[n2].mult(1 - l2).add(this.points[i2].mult(l2));
            }
          }
          class et {
            constructor(e2, t2, i2) {
              const o2 = this.boxCells = [], r2 = this.circleCells = [];
              this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
              for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++)
                o2.push([]), r2.push([]);
              this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
              return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e2, t2, i2, o2, r2) {
              this._forEachCell(t2, i2, o2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r2);
            }
            insertCircle(e2, t2, i2, o2) {
              this._forEachCell(t2 - o2, i2 - o2, t2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(o2);
            }
            _insertBoxCell(e2, t2, i2, o2, r2, n2) {
              this.boxCells[r2].push(n2);
            }
            _insertCircleCell(e2, t2, i2, o2, r2, n2) {
              this.circleCells[r2].push(n2);
            }
            _query(e2, t2, i2, o2, r2, n2) {
              if (i2 < 0 || e2 > this.width || o2 < 0 || t2 > this.height)
                return !r2 && [];
              const s2 = [];
              if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= o2) {
                if (r2)
                  return true;
                for (let e3 = 0; e3 < this.boxKeys.length; e3++)
                  s2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
                for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
                  const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
                  s2.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
                }
                return n2 ? s2.filter(n2) : s2;
              }
              return this._forEachCell(e2, t2, i2, o2, this._queryCell, s2, { hitTest: r2, seenUids: { box: {}, circle: {} } }, n2), r2 ? s2.length > 0 : s2;
            }
            _queryCircle(e2, t2, i2, o2, r2) {
              const n2 = e2 - i2, s2 = e2 + i2, a2 = t2 - i2, l2 = t2 + i2;
              if (s2 < 0 || n2 > this.width || l2 < 0 || a2 > this.height)
                return !o2 && [];
              const c2 = [];
              return this._forEachCell(n2, a2, s2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r2), o2 ? c2.length > 0 : c2;
            }
            query(e2, t2, i2, o2, r2) {
              return this._query(e2, t2, i2, o2, false, r2);
            }
            hitTest(e2, t2, i2, o2, r2) {
              return this._query(e2, t2, i2, o2, true, r2);
            }
            hitTestCircle(e2, t2, i2, o2) {
              return this._queryCircle(e2, t2, i2, true, o2);
            }
            _queryCell(e2, t2, i2, o2, r2, n2, s2, a2) {
              const l2 = s2.seenUids, c2 = this.boxCells[r2];
              if (null !== c2) {
                const r3 = this.bboxes;
                for (const h3 of c2)
                  if (!l2.box[h3]) {
                    l2.box[h3] = true;
                    const c3 = 4 * h3;
                    if (e2 <= r3[c3 + 2] && t2 <= r3[c3 + 3] && i2 >= r3[c3 + 0] && o2 >= r3[c3 + 1] && (!a2 || a2(this.boxKeys[h3]))) {
                      if (s2.hitTest)
                        return n2.push(true), true;
                      n2.push({ key: this.boxKeys[h3], x1: r3[c3], y1: r3[c3 + 1], x2: r3[c3 + 2], y2: r3[c3 + 3] });
                    }
                  }
              }
              const h2 = this.circleCells[r2];
              if (null !== h2) {
                const r3 = this.circles;
                for (const c3 of h2)
                  if (!l2.circle[c3]) {
                    l2.circle[c3] = true;
                    const h3 = 3 * c3;
                    if (this._circleAndRectCollide(r3[h3], r3[h3 + 1], r3[h3 + 2], e2, t2, i2, o2) && (!a2 || a2(this.circleKeys[c3]))) {
                      if (s2.hitTest)
                        return n2.push(true), true;
                      {
                        const e3 = r3[h3], t3 = r3[h3 + 1], i3 = r3[h3 + 2];
                        n2.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                      }
                    }
                  }
              }
            }
            _queryCellCircle(e2, t2, i2, o2, r2, n2, s2, a2) {
              const l2 = s2.circle, c2 = s2.seenUids, h2 = this.boxCells[r2];
              if (null !== h2) {
                const e3 = this.bboxes;
                for (const t3 of h2)
                  if (!c2.box[t3]) {
                    c2.box[t3] = true;
                    const i3 = 4 * t3;
                    if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!a2 || a2(this.boxKeys[t3])))
                      return n2.push(true), true;
                  }
              }
              const u2 = this.circleCells[r2];
              if (null !== u2) {
                const e3 = this.circles;
                for (const t3 of u2)
                  if (!c2.circle[t3]) {
                    c2.circle[t3] = true;
                    const i3 = 3 * t3;
                    if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!a2 || a2(this.circleKeys[t3])))
                      return n2.push(true), true;
                  }
              }
            }
            _forEachCell(e2, t2, i2, o2, r2, n2, s2, a2) {
              const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(o2);
              for (let _2 = l2; _2 <= h2; _2++)
                for (let l3 = c2; l3 <= u2; l3++)
                  if (r2.call(this, e2, t2, i2, o2, this.xCellCount * l3 + _2, n2, s2, a2))
                    return;
            }
            _convertToXCellCoord(e2) {
              return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
            }
            _convertToYCellCoord(e2) {
              return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
            }
            _circlesCollide(e2, t2, i2, o2, r2, n2) {
              const s2 = o2 - e2, a2 = r2 - t2, l2 = i2 + n2;
              return l2 * l2 > s2 * s2 + a2 * a2;
            }
            _circleAndRectCollide(e2, t2, i2, o2, r2, n2, s2) {
              const a2 = (n2 - o2) / 2, l2 = Math.abs(e2 - (o2 + a2));
              if (l2 > a2 + i2)
                return false;
              const c2 = (s2 - r2) / 2, h2 = Math.abs(t2 - (r2 + c2));
              if (h2 > c2 + i2)
                return false;
              if (l2 <= a2 || h2 <= c2)
                return true;
              const u2 = l2 - a2, _2 = h2 - c2;
              return u2 * u2 + _2 * _2 <= i2 * i2;
            }
          }
          const tt = Math.tan(85 * Math.PI / 180);
          function it(t2, i2, o2, r2, n2, s2, a2) {
            const l2 = e.create();
            if (o2)
              if ("globe" === s2.name) {
                const t3 = e.calculateGlobeLabelMatrix(n2, i2);
                e.multiply(l2, l2, t3);
              } else {
                const t3 = v([], a2);
                l2[0] = t3[0], l2[1] = t3[1], l2[4] = t3[2], l2[5] = t3[3], r2 || e.rotateZ(l2, l2, n2.angle);
              }
            else
              e.multiply(l2, n2.labelPlaneMatrix, t2);
            return l2;
          }
          function ot(e2, t2, i2, o2, r2, n2, s2) {
            const a2 = it(e2, t2, i2, o2, r2, n2, s2);
            return "globe" === n2.name && i2 || (a2[2] = a2[6] = a2[10] = a2[14] = 0), a2;
          }
          function rt(t2, i2, o2, r2, n2, s2, a2) {
            if (o2) {
              if ("globe" === s2.name) {
                const l2 = it(t2, i2, o2, r2, n2, s2, a2);
                return e.invert(l2, l2), e.multiply(l2, t2, l2), l2;
              }
              {
                const i3 = e.clone(t2), o3 = e.identity([]);
                return o3[0] = a2[0], o3[1] = a2[1], o3[4] = a2[2], o3[5] = a2[3], e.multiply(i3, i3, o3), r2 || e.rotateZ(i3, i3, -n2.angle), i3;
              }
            }
            return n2.glCoordMatrix;
          }
          function nt(t2, i2, o2, r2) {
            const n2 = [t2, i2, o2, 1];
            o2 ? e.transformMat4$1(n2, n2, r2) : ft(n2, n2, r2);
            const s2 = n2[3];
            return n2[0] /= s2, n2[1] /= s2, n2[2] /= s2, n2;
          }
          function st(e2, t2) {
            return Math.min(0.5 + e2 / t2 * 0.5, 1.5);
          }
          function at(e2, t2) {
            const i2 = e2[0] / e2[3], o2 = e2[1] / e2[3];
            return i2 >= -t2[0] && i2 <= t2[0] && o2 >= -t2[1] && o2 <= t2[1];
          }
          function lt(t2, i2, o2, r2, n2, s2, a2, l2, c2, h2) {
            const u2 = o2.transform, _2 = r2 ? t2.textSizeData : t2.iconSizeData, d2 = e.evaluateSizeForZoom(_2, o2.transform.zoom), p2 = "globe" === u2.projection.name, m2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], f2 = r2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
            f2.clear();
            let g2 = null;
            p2 && (g2 = r2 ? t2.text.globeExtVertexArray : t2.icon.globeExtVertexArray);
            const v2 = t2.lineVertexArray, x2 = r2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, y2 = o2.transform.width / o2.transform.height;
            let b2, w2 = false;
            for (let r3 = 0; r3 < x2.length; r3++) {
              const p3 = x2.get(r3), { numGlyphs: T2, writingMode: E2 } = p3;
              if (E2 !== e.WritingMode.vertical || w2 || b2 === e.WritingMode.horizontal || (w2 = true), b2 = E2, (p3.hidden || E2 === e.WritingMode.vertical) && !w2) {
                mt(T2, f2);
                continue;
              }
              w2 = false;
              const C2 = new e.pointGeometry(p3.tileAnchorX, p3.tileAnchorY);
              let { x: M2, y: I2, z: S2 } = u2.projection.projectTilePoint(C2.x, C2.y, h2.canonical);
              if (c2) {
                const [e2, t3, i3] = c2(C2);
                M2 += e2, I2 += t3, S2 += i3;
              }
              const D2 = [M2, I2, S2, 1];
              if (e.transformMat4$1(D2, D2, i2), !at(D2, m2)) {
                mt(T2, f2);
                continue;
              }
              const L2 = st(o2.transform.cameraToCenterDistance, D2[3]), A2 = e.evaluateSizeForFeature(_2, d2, p3), z2 = a2 ? A2 / L2 : A2 * L2, P2 = nt(M2, I2, S2, n2);
              if (P2[3] <= 0) {
                mt(T2, f2);
                continue;
              }
              let R2 = {};
              const O2 = a2 ? null : c2, B2 = ut(p3, z2, false, l2, i2, n2, s2, t2.glyphOffsetArray, v2, f2, g2, P2, C2, R2, y2, O2, u2.projection, h2, a2);
              w2 = B2.useVertical, O2 && B2.needsFlipping && (R2 = {}), (B2.notEnoughRoom || w2 || B2.needsFlipping && ut(p3, z2, true, l2, i2, n2, s2, t2.glyphOffsetArray, v2, f2, g2, P2, C2, R2, y2, O2, u2.projection, h2, a2).notEnoughRoom) && mt(T2, f2);
            }
            r2 ? (t2.text.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.text.globeExtVertexBuffer.updateData(g2)) : (t2.icon.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.icon.globeExtVertexBuffer.updateData(g2));
          }
          function ct(e2, t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2) {
            const { lineStartIndex: f2, glyphStartIndex: g2, segment: v2 } = a2, x2 = g2 + a2.numGlyphs, y2 = f2 + a2.lineLength, b2 = t2.getoffsetX(g2), w2 = t2.getoffsetX(x2 - 1), T2 = pt(e2 * b2, i2, o2, r2, n2, s2, v2, f2, y2, l2, c2, h2, u2, _2, true, d2, p2, m2);
            if (!T2)
              return null;
            const E2 = pt(e2 * w2, i2, o2, r2, n2, s2, v2, f2, y2, l2, c2, h2, u2, _2, true, d2, p2, m2);
            return E2 ? { first: T2, last: E2 } : null;
          }
          function ht(t2, i2, o2, r2) {
            return t2 === e.WritingMode.horizontal && Math.abs(r2) > Math.abs(o2) ? { useVertical: true } : t2 === e.WritingMode.vertical ? r2 > 0 ? { needsFlipping: true } : null : 0 !== i2 && function(e2, t3) {
              return 0 === e2 || Math.abs(t3 / e2) > tt;
            }(o2, r2) ? 1 === i2 ? { needsFlipping: true } : null : o2 < 0 ? { needsFlipping: true } : null;
          }
          function ut(t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2, g2, v2, x2) {
            const y2 = i2 / 24, b2 = t2.lineOffsetX * y2, w2 = t2.lineOffsetY * y2, { lineStartIndex: T2, glyphStartIndex: E2, numGlyphs: C2, segment: M2, writingMode: I2, flipState: S2 } = t2, D2 = T2 + t2.lineLength, L2 = (t3) => {
              if (u2) {
                const [i4, o4, r4] = t3.up, n3 = h2.length;
                e.updateGlobeVertexNormal(u2, n3 + 0, i4, o4, r4), e.updateGlobeVertexNormal(u2, n3 + 1, i4, o4, r4), e.updateGlobeVertexNormal(u2, n3 + 2, i4, o4, r4), e.updateGlobeVertexNormal(u2, n3 + 3, i4, o4, r4);
              }
              const [i3, o3, r3] = t3.point;
              e.addDynamicAttributes(h2, i3, o3, r3, t3.angle);
            };
            if (C2 > 1) {
              const e2 = ct(y2, l2, b2, w2, o2, _2, d2, t2, c2, s2, p2, f2, false, g2, v2, x2);
              if (!e2)
                return { notEnoughRoom: true };
              if (r2 && !o2) {
                let [i3, o3, r3] = e2.first.point, [n3, s3, l3] = e2.last.point;
                [i3, o3] = nt(i3, o3, r3, a2), [n3, s3] = nt(n3, s3, l3, a2);
                const c3 = ht(I2, S2, (n3 - i3) * m2, s3 - o3);
                if (t2.flipState = c3 && c3.needsFlipping ? 1 : 2, c3)
                  return c3;
              }
              L2(e2.first);
              for (let e3 = E2 + 1; e3 < E2 + C2 - 1; e3++) {
                const t3 = pt(y2 * l2.getoffsetX(e3), b2, w2, o2, _2, d2, M2, T2, D2, c2, s2, p2, f2, false, false, g2, v2, x2);
                if (!t3)
                  return h2.length -= 4 * (e3 - E2), { notEnoughRoom: true };
                L2(t3);
              }
              L2(e2.last);
            } else {
              if (r2 && !o2) {
                const i4 = nt(d2.x, d2.y, 0, n2), o3 = T2 + M2 + 1, r3 = new e.pointGeometry(c2.getx(o3), c2.gety(o3)), s3 = nt(r3.x, r3.y, 0, n2), a3 = s3[3] > 0 ? s3 : dt(d2, r3, i4, 1, n2, void 0, g2, v2.canonical), l3 = ht(I2, S2, (a3[0] - i4[0]) * m2, a3[1] - i4[1]);
                if (t2.flipState = l3 && l3.needsFlipping ? 1 : 2, l3)
                  return l3;
              }
              const i3 = pt(y2 * l2.getoffsetX(E2), b2, w2, o2, _2, d2, M2, T2, D2, c2, s2, p2, f2, false, false, g2, v2, x2);
              if (!i3)
                return { notEnoughRoom: true };
              L2(i3);
            }
            return {};
          }
          function _t(e2, t2, i2, o2, r2) {
            const { x: n2, y: s2, z: a2 } = o2.projectTilePoint(e2.x, e2.y, t2);
            if (!r2)
              return nt(n2, s2, a2, i2);
            const [l2, c2, h2] = r2(e2);
            return nt(n2 + l2, s2 + c2, a2 + h2, i2);
          }
          function dt(t2, i2, o2, r2, n2, s2, a2, l2) {
            const c2 = _t(t2.sub(i2)._unit()._add(t2), l2, n2, a2, s2);
            return e.sub(c2, o2, c2), e.normalize(c2, c2), e.scaleAndAdd(c2, o2, c2, r2);
          }
          function pt(t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2, g2, v2) {
            const x2 = r2 ? t2 - i2 : t2 + i2;
            let y2 = x2 > 0 ? 1 : -1, b2 = 0;
            r2 && (y2 *= -1, b2 = Math.PI), y2 < 0 && (b2 += Math.PI);
            let w2 = l2 + a2 + (y2 > 0 ? 0 : 1) | 0, T2 = n2, E2 = n2, C2 = 0, M2 = 0;
            const I2 = Math.abs(x2), S2 = [], D2 = [];
            let L2 = s2, A2 = L2;
            const z2 = () => dt(A2, L2, E2, I2 - C2 + 1, u2, d2, f2, g2.canonical);
            for (; C2 + M2 <= I2; ) {
              if (w2 += y2, w2 < l2 || w2 >= c2)
                return null;
              if (E2 = T2, A2 = L2, S2.push(E2), p2 && D2.push(A2), L2 = new e.pointGeometry(h2.getx(w2), h2.gety(w2)), T2 = _2[w2], !T2) {
                const e2 = _t(L2, g2.canonical, u2, f2, d2);
                T2 = e2[3] > 0 ? _2[w2] = e2 : z2();
              }
              C2 += M2, M2 = e.distance(E2, T2);
            }
            m2 && d2 && (_2[w2] && (T2 = z2(), M2 = e.distance(E2, T2)), _2[w2] = T2);
            const P2 = (I2 - C2) / M2, R2 = L2.sub(A2)._mult(P2)._add(A2), O2 = e.sub([], T2, E2), B2 = e.scaleAndAdd([], E2, O2, P2);
            let k2 = [0, 0, 1], F2 = O2[0], U2 = O2[1];
            if (v2 && (k2 = f2.upVector(g2.canonical, R2.x, R2.y), 0 !== k2[0] || 0 !== k2[1] || 1 !== k2[2])) {
              const t3 = [k2[2], 0, -k2[0]], i3 = e.cross([], k2, t3);
              e.normalize(t3, t3), e.normalize(i3, i3), F2 = e.dot(O2, t3), U2 = e.dot(O2, i3);
            }
            if (o2) {
              const t3 = e.cross([], k2, O2);
              e.normalize(t3, t3), e.scaleAndAdd(B2, B2, t3, o2 * y2);
            }
            const N2 = b2 + Math.atan2(U2, F2);
            return S2.push(B2), p2 && D2.push(R2), { point: B2, angle: N2, path: S2, tilePath: D2, up: k2 };
          }
          function mt(e2, t2) {
            const i2 = t2.length, o2 = i2 + 4 * e2;
            t2.resize(o2), t2.float32.fill(-1 / 0, 4 * i2, 4 * o2);
          }
          function ft(e2, t2, i2) {
            const o2 = t2[0], r2 = t2[1];
            return e2[0] = i2[0] * o2 + i2[4] * r2 + i2[12], e2[1] = i2[1] * o2 + i2[5] * r2 + i2[13], e2[3] = i2[3] * o2 + i2[7] * r2 + i2[15], e2;
          }
          const gt = 100;
          class vt {
            constructor(e2, t2, i2 = new et(e2.width + 200, e2.height + 200, 25), o2 = new et(e2.width + 200, e2.height + 200, 25)) {
              this.transform = e2, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e2._pitch) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + gt, this.screenBottomBoundary = e2.height + gt, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.fogState = t2;
            }
            placeCollisionBox(e2, t2, i2, o2, r2, n2, s2, a2) {
              let l2 = i2.projectedAnchorX, c2 = i2.projectedAnchorY, h2 = i2.projectedAnchorZ;
              const u2 = i2.elevation, _2 = i2.tileID, d2 = e2.getProjection();
              if (u2 && _2) {
                const [e3, t3, o3] = d2.upVector(_2.canonical, i2.tileAnchorX, i2.tileAnchorY), r3 = d2.upVectorScale(_2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                l2 += e3 * u2 * r3, c2 += t3 * u2 * r3, h2 += o3 * u2 * r3;
              }
              const p2 = this.projectAndGetPerspectiveRatio(s2, l2, c2, h2, i2.tileID, "globe" === d2.name || !!u2 || this.transform.pitch > 0, d2), m2 = n2 * p2.perspectiveRatio, f2 = (i2.x1 * t2 + o2.x - i2.padding) * m2 + p2.point.x, g2 = (i2.y1 * t2 + o2.y - i2.padding) * m2 + p2.point.y, v2 = (i2.x2 * t2 + o2.x + i2.padding) * m2 + p2.point.x, x2 = (i2.y2 * t2 + o2.y + i2.padding) * m2 + p2.point.y, y2 = p2.perspectiveRatio <= 0.55 || p2.occluded;
              return !this.isInsideGrid(f2, g2, v2, x2) || !r2 && this.grid.hitTest(f2, g2, v2, x2, a2) || y2 ? { box: [], offscreen: false, occluded: p2.occluded } : { box: [f2, g2, v2, x2], offscreen: this.isOffscreen(f2, g2, v2, x2), occluded: false };
            }
            placeCollisionCircles(t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2) {
              const f2 = [], g2 = this.transform.elevation, v2 = t2.getProjection(), x2 = g2 ? g2.getAtTileOffsetFunc(m2, this.transform.center.lat, this.transform.worldSize, v2) : null, y2 = new e.pointGeometry(o2.tileAnchorX, o2.tileAnchorY);
              let { x: b2, y: w2, z: T2 } = v2.projectTilePoint(y2.x, y2.y, m2.canonical);
              if (x2) {
                const [e2, t3, i3] = x2(y2);
                b2 += e2, w2 += t3, T2 += i3;
              }
              const E2 = "globe" === v2.name, C2 = this.projectAndGetPerspectiveRatio(a2, b2, w2, T2, m2, E2 || !!g2 || this.transform.pitch > 0, v2), { perspectiveRatio: M2 } = C2, I2 = (u2 ? s2 / M2 : s2 * M2) / e.ONE_EM, S2 = nt(b2, w2, T2, l2), D2 = C2.signedDistanceFromCamera > 0 ? ct(I2, n2, o2.lineOffsetX * I2, o2.lineOffsetY * I2, false, S2, y2, o2, r2, l2, {}, g2 && !u2 ? x2 : null, u2 && !!g2, v2, m2, u2) : null;
              let L2 = false, A2 = false, z2 = true;
              if (D2 && !C2.occluded) {
                const t3 = 0.5 * d2 * M2 + p2, o3 = new e.pointGeometry(-100, -100), r3 = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), n3 = new Qe(), { first: s3, last: a3 } = D2, l3 = s3.path.length;
                let u3 = [];
                for (let e2 = l3 - 1; e2 >= 1; e2--)
                  u3.push(s3.path[e2]);
                for (let e2 = 1; e2 < a3.path.length; e2++)
                  u3.push(a3.path[e2]);
                const m3 = 2.5 * t3;
                c2 && (u3 = u3.map(([e2, t4, i3], o4) => (x2 && !E2 && (i3 = x2(o4 < l3 - 1 ? s3.tilePath[l3 - 1 - o4] : a3.tilePath[o4 - l3 + 2])[2]), nt(e2, t4, i3, c2))), u3.some((e2) => e2[3] <= 0) && (u3 = []));
                let g3 = [];
                if (u3.length > 0) {
                  let t4 = 1 / 0, i3 = -1 / 0, n4 = 1 / 0, s4 = -1 / 0;
                  for (const e2 of u3)
                    t4 = Math.min(t4, e2[0]), n4 = Math.min(n4, e2[1]), i3 = Math.max(i3, e2[0]), s4 = Math.max(s4, e2[1]);
                  i3 >= o3.x && t4 <= r3.x && s4 >= o3.y && n4 <= r3.y && (g3 = [u3.map((t5) => new e.pointGeometry(t5[0], t5[1]))], (t4 < o3.x || i3 > r3.x || n4 < o3.y || s4 > r3.y) && (g3 = e.clipLine(g3, o3.x, o3.y, r3.x, r3.y)));
                }
                for (const e2 of g3) {
                  n3.reset(e2, 0.25 * t3);
                  let o4 = 0;
                  o4 = n3.length <= 0.5 * t3 ? 1 : Math.ceil(n3.paddedLength / m3) + 1;
                  for (let e3 = 0; e3 < o4; e3++) {
                    const r4 = e3 / Math.max(o4 - 1, 1), s4 = n3.lerp(r4), a4 = s4.x + gt, l4 = s4.y + gt;
                    f2.push(a4, l4, t3, 0);
                    const c3 = a4 - t3, u4 = l4 - t3, d3 = a4 + t3, p3 = l4 + t3;
                    if (z2 = z2 && this.isOffscreen(c3, u4, d3, p3), A2 = A2 || this.isInsideGrid(c3, u4, d3, p3), !i2 && this.grid.hitTestCircle(a4, l4, t3, _2) && (L2 = true, !h2))
                      return { circles: [], offscreen: false, collisionDetected: L2, occluded: false };
                  }
                }
              }
              return { circles: !h2 && L2 || !A2 ? [] : f2, offscreen: z2, collisionDetected: L2, occluded: C2.occluded };
            }
            queryRenderedSymbols(t2) {
              if (0 === t2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
                return {};
              const i2 = [];
              let o2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, s2 = -1 / 0;
              for (const a3 of t2) {
                const t3 = new e.pointGeometry(a3.x + gt, a3.y + gt);
                o2 = Math.min(o2, t3.x), r2 = Math.min(r2, t3.y), n2 = Math.max(n2, t3.x), s2 = Math.max(s2, t3.y), i2.push(t3);
              }
              const a2 = this.grid.query(o2, r2, n2, s2).concat(this.ignoredGrid.query(o2, r2, n2, s2)), l2 = {}, c2 = {};
              for (const t3 of a2) {
                const o3 = t3.key;
                if (void 0 === l2[o3.bucketInstanceId] && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
                  continue;
                const r3 = [new e.pointGeometry(t3.x1, t3.y1), new e.pointGeometry(t3.x2, t3.y1), new e.pointGeometry(t3.x2, t3.y2), new e.pointGeometry(t3.x1, t3.y2)];
                e.polygonIntersectsPolygon(i2, r3) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c2[o3.bucketInstanceId] && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
              }
              return c2;
            }
            insertCollisionBox(e2, t2, i2, o2, r2) {
              (t2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 }, e2[0], e2[1], e2[2], e2[3]);
            }
            insertCollisionCircles(e2, t2, i2, o2, r2) {
              const n2 = t2 ? this.ignoredGrid : this.grid, s2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 };
              for (let t3 = 0; t3 < e2.length; t3 += 4)
                n2.insertCircle(s2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
            }
            projectAndGetPerspectiveRatio(t2, i2, o2, r2, n2, s2, a2) {
              const l2 = [i2, o2, r2, 1];
              let c2 = false;
              if (r2 || this.transform.pitch > 0) {
                e.transformMat4$1(l2, l2, t2);
                const s3 = "globe" === a2.name;
                if (this.fogState && n2 && !s3) {
                  const t3 = function(t4, i3, o3, r3, n3, s4) {
                    const a3 = s4.calculateFogTileMatrix(n3), l3 = [i3, o3, r3];
                    return e.transformMat4(l3, l3, a3), I(t4, l3, s4.pitch, s4._fov);
                  }(this.fogState, i2, o2, r2, n2.toUnwrapped(), this.transform);
                  c2 = t3 > 0.9;
                }
              } else
                ft(l2, l2, t2);
              const h2 = l2[3];
              return { point: new e.pointGeometry((l2[0] / h2 + 1) / 2 * this.transform.width + gt, (-l2[1] / h2 + 1) / 2 * this.transform.height + gt), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a2) / h2 * 0.5, 1.5), signedDistanceFromCamera: h2, occluded: s2 && l2[2] > h2 || c2 };
            }
            isOffscreen(e2, t2, i2, o2) {
              return i2 < gt || e2 >= this.screenRightBoundary || o2 < gt || t2 > this.screenBottomBoundary;
            }
            isInsideGrid(e2, t2, i2, o2) {
              return i2 >= 0 && e2 < this.gridRightBoundary && o2 >= 0 && t2 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
              const t2 = e.identity([]);
              return e.translate(t2, t2, [-100, -100, 0]), t2;
            }
          }
          function xt(t2, i2, o2) {
            const r2 = i2.createTileMatrix(t2, t2.worldSize, o2.toUnwrapped());
            return e.multiply(new Float32Array(16), t2.projMatrix, r2);
          }
          function yt(e2, t2, i2) {
            if (t2.projection.name === i2.projection.name)
              return e2.projMatrix;
            const o2 = i2.clone();
            return o2.setProjection(t2.projection), xt(o2, t2.getProjection(), e2);
          }
          function bt(e2, t2, i2) {
            return t2.name === i2.projection.name ? e2.projMatrix : xt(i2, t2, e2);
          }
          class wt {
            constructor(e2, t2, i2, o2) {
              this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : o2 && i2 ? 1 : 0, this.placed = i2;
            }
            isHidden() {
              return 0 === this.opacity && !this.placed;
            }
          }
          class Tt {
            constructor(e2, t2, i2, o2, r2, n2 = false) {
              this.text = new wt(e2 ? e2.text : null, t2, i2, r2), this.icon = new wt(e2 ? e2.icon : null, t2, o2, r2), this.clipped = n2;
            }
            isHidden() {
              return this.text.isHidden() && this.icon.isHidden();
            }
          }
          class Et {
            constructor(e2, t2, i2, o2 = false) {
              this.text = e2, this.icon = t2, this.skipFade = i2, this.clipped = o2;
            }
          }
          class Ct {
            constructor() {
              this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [];
            }
          }
          class Mt {
            constructor(e2, t2, i2, o2, r2) {
              this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r2;
            }
          }
          class It {
            constructor(e2) {
              this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e2) {
              if (this.crossSourceCollisions)
                return { ID: 0, predicate: null };
              if (!this.collisionGroups[e2]) {
                const t2 = ++this.maxGroupID;
                this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
              }
              return this.collisionGroups[e2];
            }
          }
          function St(t2, i2, o2, r2, n2) {
            const { horizontalAlign: s2, verticalAlign: a2 } = e.getAnchorAlignment(t2), l2 = -(s2 - 0.5) * i2, c2 = -(a2 - 0.5) * o2, h2 = e.evaluateVariableOffset(t2, r2);
            return new e.pointGeometry(l2 + h2[0] * n2, c2 + h2[1] * n2);
          }
          function Dt(t2, i2, o2, r2, n2) {
            const s2 = new e.pointGeometry(t2, i2);
            return o2 && s2._rotate(r2 ? n2 : -n2), s2;
          }
          class Lt {
            constructor(e2, t2, i2, o2, r2) {
              this.transform = e2.clone(), this.projection = e2.projection.name, this.collisionIndex = new vt(this.transform, r2), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t2, this.retainedQueryData = {}, this.collisionGroups = new It(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(t2, i2, o2, r2) {
              const n2 = o2.getBucket(i2), s2 = o2.latestFeatureIndex;
              if (!n2 || !s2 || i2.id !== n2.layerIds[0])
                return;
              const a2 = n2.layers[0].layout, l2 = o2.collisionBoxArray, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h2 = o2.tileSize / e.EXTENT, u2 = o2.tileID.toUnwrapped();
              this.transform.setProjection(n2.projection);
              const _2 = (d2 = o2.tileID, p2 = n2.getProjection(), m2 = this.transform, p2.name === this.projection ? m2.calculateProjMatrix(d2.toUnwrapped()) : xt(m2, p2, d2));
              var d2, p2, m2;
              const f2 = "map" === a2.get("text-pitch-alignment"), g2 = "map" === a2.get("text-rotation-alignment");
              i2.compileFilter();
              const v2 = i2.dynamicFilter(), x2 = i2.dynamicFilterNeedsFeature(), y2 = this.transform.calculatePixelsToTileUnitsMatrix(o2), b2 = ot(_2, o2.tileID.canonical, f2, g2, this.transform, n2.getProjection(), y2);
              let w2 = null;
              if (f2) {
                const t3 = rt(_2, o2.tileID.canonical, f2, g2, this.transform, n2.getProjection(), y2);
                w2 = e.multiply([], this.transform.labelPlaneMatrix, t3);
              }
              let T2 = null;
              v2 && o2.latestFeatureIndex && (T2 = { unwrappedTileID: u2, dynamicFilter: v2, dynamicFilterNeedsFeature: x2, featureIndex: o2.latestFeatureIndex }), this.retainedQueryData[n2.bucketInstanceId] = new Mt(n2.bucketInstanceId, s2, n2.sourceLayerIndex, n2.index, o2.tileID);
              const E2 = { bucket: n2, layout: a2, posMatrix: _2, textLabelPlaneMatrix: b2, labelToScreenMatrix: w2, clippingData: T2, scale: c2, textPixelRatio: h2, holdingForFade: o2.holdingForFade(), collisionBoxArray: l2, partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n2.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n2.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n2.sourceID) };
              if (r2)
                for (const e2 of n2.sortKeyRanges) {
                  const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3 } = e2;
                  t2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3, parameters: E2 });
                }
              else
                t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: n2.symbolInstances.length, parameters: E2 });
            }
            attemptAnchorPlacement(e2, t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2, g2) {
              const { textOffset0: v2, textOffset1: x2, crossTileID: y2 } = u2, b2 = [v2, x2], w2 = St(e2, i2, o2, b2, r2), T2 = this.collisionIndex.placeCollisionBox(d2, r2, t2, Dt(w2.x, w2.y, n2, s2, this.transform.angle), h2, a2, l2, c2.predicate);
              if (m2) {
                const e3 = d2.getSymbolInstanceIconSize(g2, this.transform.zoom, u2.placedIconSymbolIndex);
                if (0 === this.collisionIndex.placeCollisionBox(d2, e3, m2, Dt(w2.x, w2.y, n2, s2, this.transform.angle), h2, a2, l2, c2.predicate).box.length)
                  return;
              }
              if (T2.box.length > 0) {
                let t3;
                return this.prevPlacement && this.prevPlacement.variableOffsets[y2] && this.prevPlacement.placements[y2] && this.prevPlacement.placements[y2].text && (t3 = this.prevPlacement.variableOffsets[y2].anchor), this.variableOffsets[y2] = { textOffset: b2, width: i2, height: o2, anchor: e2, textScale: r2, prevAnchor: t3 }, this.markUsedJustification(d2, e2, u2, p2), d2.allowVerticalPlacement && (this.markUsedOrientation(d2, p2, u2), this.placedOrientations[y2] = p2), { shift: w2, placedGlyphBoxes: T2 };
              }
            }
            placeLayerBucketPart(t2, i2, o2, r2) {
              const { bucket: n2, layout: s2, posMatrix: a2, textLabelPlaneMatrix: l2, labelToScreenMatrix: c2, clippingData: h2, textPixelRatio: u2, holdingForFade: _2, collisionBoxArray: d2, partiallyEvaluatedTextSize: p2, partiallyEvaluatedIconSize: m2, collisionGroup: f2 } = t2.parameters, g2 = s2.get("text-optional"), v2 = s2.get("icon-optional"), x2 = s2.get("text-allow-overlap"), y2 = s2.get("icon-allow-overlap"), b2 = "map" === s2.get("text-rotation-alignment"), w2 = "map" === s2.get("text-pitch-alignment"), T2 = "none" !== s2.get("icon-text-fit"), E2 = "viewport-y" === s2.get("symbol-z-order");
              this.transform.setProjection(n2.projection);
              let C2 = x2 && (y2 || !n2.hasIconData() || v2), M2 = y2 && (x2 || !n2.hasTextData() || g2);
              !n2.collisionArrays && d2 && n2.deserializeCollisionBoxes(d2), o2 && r2 && n2.updateCollisionDebugBuffers(this.transform.zoom, d2);
              const I2 = (t3, r3, d3) => {
                const { crossTileID: E3, numVerticalGlyphVertices: I3 } = t3;
                if (h2) {
                  const o3 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
                  let r4 = null;
                  if (h2.dynamicFilterNeedsFeature) {
                    const e2 = this.retainedQueryData[n2.bucketInstanceId];
                    r4 = h2.featureIndex.loadFeature({ featureIndex: t3.featureIndex, bucketIndex: e2.bucketIndex, sourceLayerIndex: e2.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                  }
                  if (!(0, h2.dynamicFilter)(o3, r4, this.retainedQueryData[n2.bucketInstanceId].tileID.canonical, new e.pointGeometry(t3.tileAnchorX, t3.tileAnchorY), this.transform.calculateDistanceTileData(h2.unwrappedTileID)))
                    return this.placements[E3] = new Et(false, false, false, true), void (i2[E3] = true);
                }
                if (i2[E3])
                  return;
                if (_2)
                  return void (this.placements[E3] = new Et(false, false, false));
                let S2 = false, D2 = false, L2 = true, A2 = false, z2 = false, P2 = null, R2 = { box: null, offscreen: null, occluded: null }, O2 = { box: null, offscreen: null, occluded: null }, B2 = null, k2 = null, F2 = null, U2 = 0, N2 = 0, G2 = 0;
                d3.textFeatureIndex ? U2 = d3.textFeatureIndex : t3.useRuntimeCollisionCircles && (U2 = t3.featureIndex), d3.verticalTextFeatureIndex && (N2 = d3.verticalTextFeatureIndex);
                const j2 = (e2) => {
                  e2.tileID = this.retainedQueryData[n2.bucketInstanceId].tileID;
                  const t4 = this.transform.elevation;
                  (t4 || e2.elevation) && (e2.elevation = t4 ? t4.getAtTileOffset(e2.tileID, e2.tileAnchorX, e2.tileAnchorY) : 0);
                }, Z2 = d3.textBox;
                if (Z2) {
                  j2(Z2);
                  const i3 = (i4) => {
                    let o4 = e.WritingMode.horizontal;
                    if (n2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                      const e2 = this.prevPlacement.placedOrientations[E3];
                      e2 && (this.placedOrientations[E3] = e2, o4 = e2, this.markUsedOrientation(n2, o4, t3));
                    }
                    return o4;
                  }, o3 = (t4, i4) => {
                    if (n2.allowVerticalPlacement && I3 > 0 && d3.verticalTextBox) {
                      for (const o4 of n2.writingModes)
                        if (o4 === e.WritingMode.vertical ? (R2 = i4(), O2 = R2) : R2 = t4(), R2 && R2.box && R2.box.length)
                          break;
                    } else
                      R2 = t4();
                  };
                  if (s2.get("text-variable-anchor")) {
                    let l3 = s2.get("text-variable-anchor");
                    if (this.prevPlacement && this.prevPlacement.variableOffsets[E3]) {
                      const e2 = this.prevPlacement.variableOffsets[E3];
                      l3.indexOf(e2.anchor) > 0 && (l3 = l3.filter((t4) => t4 !== e2.anchor), l3.unshift(e2.anchor));
                    }
                    const c3 = (e2, i4, o4) => {
                      const s3 = n2.getSymbolInstanceTextSize(p2, t3, this.transform.zoom, r3), c4 = (e2.x2 - e2.x1) * s3 + 2 * e2.padding, h4 = (e2.y2 - e2.y1) * s3 + 2 * e2.padding, _3 = T2 && !y2 ? i4 : null;
                      _3 && j2(_3);
                      let d4 = { box: [], offscreen: false, occluded: false };
                      const g3 = x2 ? 2 * l3.length : l3.length;
                      for (let i5 = 0; i5 < g3; ++i5) {
                        const g4 = this.attemptAnchorPlacement(l3[i5 % l3.length], e2, c4, h4, s3, b2, w2, u2, a2, f2, i5 >= l3.length, t3, r3, n2, o4, _3, p2, m2);
                        if (g4 && (d4 = g4.placedGlyphBoxes, d4 && d4.box && d4.box.length)) {
                          S2 = true, P2 = g4.shift;
                          break;
                        }
                      }
                      return d4;
                    };
                    o3(() => c3(Z2, d3.iconBox, e.WritingMode.horizontal), () => {
                      const t4 = d3.verticalTextBox;
                      return t4 && j2(t4), n2.allowVerticalPlacement && !(R2 && R2.box && R2.box.length) && I3 > 0 && t4 ? c3(t4, d3.verticalIconBox, e.WritingMode.vertical) : { box: null, offscreen: null, occluded: null };
                    }), R2 && (S2 = R2.box, L2 = R2.offscreen, A2 = R2.occluded);
                    const h3 = i3(R2 && R2.box);
                    if (!S2 && this.prevPlacement) {
                      const e2 = this.prevPlacement.variableOffsets[E3];
                      e2 && (this.variableOffsets[E3] = e2, this.markUsedJustification(n2, e2.anchor, t3, h3));
                    }
                  } else {
                    const s3 = (i4, o4) => {
                      const s4 = n2.getSymbolInstanceTextSize(p2, t3, this.transform.zoom, r3), l3 = this.collisionIndex.placeCollisionBox(n2, s4, i4, new e.pointGeometry(0, 0), x2, u2, a2, f2.predicate);
                      return l3 && l3.box && l3.box.length && (this.markUsedOrientation(n2, o4, t3), this.placedOrientations[E3] = o4), l3;
                    };
                    o3(() => s3(Z2, e.WritingMode.horizontal), () => {
                      const t4 = d3.verticalTextBox;
                      return n2.allowVerticalPlacement && I3 > 0 && t4 ? (j2(t4), s3(t4, e.WritingMode.vertical)) : { box: null, offscreen: null, occluded: null };
                    }), i3(R2 && R2.box && R2.box.length);
                  }
                }
                if (B2 = R2, S2 = B2 && B2.box && B2.box.length > 0, L2 = B2 && B2.offscreen, A2 = B2 && B2.occluded, t3.useRuntimeCollisionCircles) {
                  const i3 = n2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex), r4 = e.evaluateSizeForFeature(n2.textSizeData, p2, i3), h3 = s2.get("text-padding");
                  k2 = this.collisionIndex.placeCollisionCircles(n2, x2, i3, n2.lineVertexArray, n2.glyphOffsetArray, r4, a2, l2, c2, o2, w2, f2.predicate, t3.collisionCircleDiameter * r4 / e.ONE_EM, h3, this.retainedQueryData[n2.bucketInstanceId].tileID), S2 = x2 || k2.circles.length > 0 && !k2.collisionDetected, L2 = L2 && k2.offscreen, A2 = k2.occluded;
                }
                if (d3.iconFeatureIndex && (G2 = d3.iconFeatureIndex), d3.iconBox) {
                  const i3 = (i4) => {
                    j2(i4);
                    const o3 = T2 && P2 ? Dt(P2.x, P2.y, b2, w2, this.transform.angle) : new e.pointGeometry(0, 0), r4 = n2.getSymbolInstanceIconSize(m2, this.transform.zoom, t3.placedIconSymbolIndex);
                    return this.collisionIndex.placeCollisionBox(n2, r4, i4, o3, y2, u2, a2, f2.predicate);
                  };
                  O2 && O2.box && O2.box.length && d3.verticalIconBox ? (F2 = i3(d3.verticalIconBox), D2 = F2.box.length > 0) : (F2 = i3(d3.iconBox), D2 = F2.box.length > 0), L2 = L2 && F2.offscreen, z2 = F2.occluded;
                }
                const V2 = g2 || 0 === t3.numHorizontalGlyphVertices && 0 === I3, W2 = v2 || 0 === t3.numIconVertices;
                if (V2 || W2 ? W2 ? V2 || (D2 = D2 && S2) : S2 = D2 && S2 : D2 = S2 = D2 && S2, S2 && B2 && B2.box && this.collisionIndex.insertCollisionBox(B2.box, s2.get("text-ignore-placement"), n2.bucketInstanceId, O2 && O2.box && N2 ? N2 : U2, f2.ID), D2 && F2 && this.collisionIndex.insertCollisionBox(F2.box, s2.get("icon-ignore-placement"), n2.bucketInstanceId, G2, f2.ID), k2 && (S2 && this.collisionIndex.insertCollisionCircles(k2.circles, s2.get("text-ignore-placement"), n2.bucketInstanceId, U2, f2.ID), o2)) {
                  const e2 = n2.bucketInstanceId;
                  let t4 = this.collisionCircleArrays[e2];
                  void 0 === t4 && (t4 = this.collisionCircleArrays[e2] = new Ct());
                  for (let e3 = 0; e3 < k2.circles.length; e3 += 4)
                    t4.circles.push(k2.circles[e3 + 0]), t4.circles.push(k2.circles[e3 + 1]), t4.circles.push(k2.circles[e3 + 2]), t4.circles.push(k2.collisionDetected ? 1 : 0);
                }
                const X2 = "globe" !== n2.projection.name;
                C2 = C2 && (X2 || !A2), M2 = M2 && (X2 || !z2), this.placements[E3] = new Et(S2 || C2, D2 || M2, L2 || n2.justReloaded), i2[E3] = true;
              };
              if (E2) {
                const e2 = n2.getSortedSymbolIndexes(this.transform.angle);
                for (let t3 = e2.length - 1; t3 >= 0; --t3) {
                  const i3 = e2[t3];
                  I2(n2.symbolInstances.get(i3), i3, n2.collisionArrays[i3]);
                }
              } else
                for (let e2 = t2.symbolInstanceStart; e2 < t2.symbolInstanceEnd; e2++)
                  I2(n2.symbolInstances.get(e2), e2, n2.collisionArrays[e2]);
              if (o2 && n2.bucketInstanceId in this.collisionCircleArrays) {
                const t3 = this.collisionCircleArrays[n2.bucketInstanceId];
                e.invert(t3.invProjMatrix, a2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
              }
              n2.justReloaded = false;
            }
            markUsedJustification(t2, i2, o2, r2) {
              const { leftJustifiedTextSymbolIndex: n2, centerJustifiedTextSymbolIndex: s2, rightJustifiedTextSymbolIndex: a2, verticalPlacedTextSymbolIndex: l2, crossTileID: c2 } = o2, h2 = e.getAnchorJustification(i2), u2 = r2 === e.WritingMode.vertical ? l2 : "left" === h2 ? n2 : "center" === h2 ? s2 : "right" === h2 ? a2 : -1;
              n2 >= 0 && (t2.text.placedSymbolArray.get(n2).crossTileID = u2 >= 0 && n2 !== u2 ? 0 : c2), s2 >= 0 && (t2.text.placedSymbolArray.get(s2).crossTileID = u2 >= 0 && s2 !== u2 ? 0 : c2), a2 >= 0 && (t2.text.placedSymbolArray.get(a2).crossTileID = u2 >= 0 && a2 !== u2 ? 0 : c2), l2 >= 0 && (t2.text.placedSymbolArray.get(l2).crossTileID = u2 >= 0 && l2 !== u2 ? 0 : c2);
            }
            markUsedOrientation(t2, i2, o2) {
              const r2 = i2 === e.WritingMode.horizontal || i2 === e.WritingMode.horizontalOnly ? i2 : 0, n2 = i2 === e.WritingMode.vertical ? i2 : 0, { leftJustifiedTextSymbolIndex: s2, centerJustifiedTextSymbolIndex: a2, rightJustifiedTextSymbolIndex: l2, verticalPlacedTextSymbolIndex: c2 } = o2, h2 = t2.text.placedSymbolArray;
              s2 >= 0 && (h2.get(s2).placedOrientation = r2), a2 >= 0 && (h2.get(a2).placedOrientation = r2), l2 >= 0 && (h2.get(l2).placedOrientation = r2), c2 >= 0 && (h2.get(c2).placedOrientation = n2);
            }
            commit(e2) {
              this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
              const t2 = this.prevPlacement;
              let i2 = false;
              this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
              const o2 = t2 ? t2.symbolFadeChange(e2) : 1, r2 = t2 ? t2.opacities : {}, n2 = t2 ? t2.variableOffsets : {}, s2 = t2 ? t2.placedOrientations : {};
              for (const e3 in this.placements) {
                const t3 = this.placements[e3], n3 = r2[e3];
                n3 ? (this.opacities[e3] = new Tt(n3, o2, t3.text, t3.icon, null, t3.clipped), i2 = i2 || t3.text !== n3.text.placed || t3.icon !== n3.icon.placed) : (this.opacities[e3] = new Tt(null, o2, t3.text, t3.icon, t3.skipFade, t3.clipped), i2 = i2 || t3.text || t3.icon);
              }
              for (const e3 in r2) {
                const t3 = r2[e3];
                if (!this.opacities[e3]) {
                  const r3 = new Tt(t3, o2, false, false);
                  r3.isHidden() || (this.opacities[e3] = r3, i2 = i2 || t3.text.placed || t3.icon.placed);
                }
              }
              for (const e3 in n2)
                this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = n2[e3]);
              for (const e3 in s2)
                this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = s2[e3]);
              i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
            }
            updateLayerOpacities(e2, t2) {
              const i2 = {};
              for (const o2 of t2) {
                const t3 = o2.getBucket(e2);
                t3 && o2.latestFeatureIndex && e2.id === t3.layerIds[0] && this.updateBucketOpacities(t3, i2, o2.collisionBoxArray);
              }
            }
            updateBucketOpacities(t2, i2, o2) {
              t2.hasTextData() && t2.text.opacityVertexArray.clear(), t2.hasIconData() && t2.icon.opacityVertexArray.clear(), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
              const r2 = t2.layers[0].layout, n2 = !!t2.layers[0].dynamicFilter(), s2 = new Tt(null, 0, false, false, true), a2 = r2.get("text-allow-overlap"), l2 = r2.get("icon-allow-overlap"), c2 = r2.get("text-variable-anchor"), h2 = "map" === r2.get("text-rotation-alignment"), u2 = "map" === r2.get("text-pitch-alignment"), _2 = "none" !== r2.get("icon-text-fit"), d2 = new Tt(null, 0, a2 && (l2 || !t2.hasIconData() || r2.get("icon-optional")), l2 && (a2 || !t2.hasTextData() || r2.get("text-optional")), true);
              !t2.collisionArrays && o2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(o2);
              const p2 = (e2, t3, i3) => {
                for (let o3 = 0; o3 < t3 / 4; o3++)
                  e2.opacityVertexArray.emplaceBack(i3);
              };
              let m2 = 0;
              for (let o3 = 0; o3 < t2.symbolInstances.length; o3++) {
                const r3 = t2.symbolInstances.get(o3), { numHorizontalGlyphVertices: a3, numVerticalGlyphVertices: l3, crossTileID: f2, numIconVertices: g2 } = r3;
                let v2 = this.opacities[f2];
                i2[f2] ? v2 = s2 : v2 || (v2 = d2, this.opacities[f2] = v2), i2[f2] = true;
                const x2 = a3 > 0 || l3 > 0, y2 = g2 > 0, b2 = this.placedOrientations[f2], w2 = b2 === e.WritingMode.vertical, T2 = b2 === e.WritingMode.horizontal || b2 === e.WritingMode.horizontalOnly;
                if (!x2 && !y2 || v2.isHidden() || m2++, x2) {
                  const e2 = Ut(v2.text);
                  p2(t2.text, a3, w2 ? Nt : e2), p2(t2.text, l3, T2 ? Nt : e2);
                  const i3 = v2.text.isHidden(), { leftJustifiedTextSymbolIndex: o4, centerJustifiedTextSymbolIndex: n3, rightJustifiedTextSymbolIndex: s3, verticalPlacedTextSymbolIndex: c3 } = r3, h3 = t2.text.placedSymbolArray, u3 = i3 || w2 ? 1 : 0;
                  o4 >= 0 && (h3.get(o4).hidden = u3), n3 >= 0 && (h3.get(n3).hidden = u3), s3 >= 0 && (h3.get(s3).hidden = u3), c3 >= 0 && (h3.get(c3).hidden = i3 || T2 ? 1 : 0);
                  const _3 = this.variableOffsets[f2];
                  _3 && this.markUsedJustification(t2, _3.anchor, r3, b2);
                  const d3 = this.placedOrientations[f2];
                  d3 && (this.markUsedJustification(t2, "left", r3, d3), this.markUsedOrientation(t2, d3, r3));
                }
                if (y2) {
                  const e2 = Ut(v2.icon), { placedIconSymbolIndex: i3, verticalPlacedIconSymbolIndex: o4 } = r3, n3 = t2.icon.placedSymbolArray, s3 = v2.icon.isHidden() ? 1 : 0;
                  i3 >= 0 && (p2(t2.icon, g2, w2 ? Nt : e2), n3.get(i3).hidden = s3), o4 >= 0 && (p2(t2.icon, r3.numVerticalIconVertices, T2 ? Nt : e2), n3.get(o4).hidden = s3);
                }
                if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
                  const i3 = t2.collisionArrays[o3];
                  if (i3) {
                    let o4 = new e.pointGeometry(0, 0), r4 = true;
                    if (i3.textBox || i3.verticalTextBox) {
                      if (c2) {
                        const e2 = this.variableOffsets[f2];
                        e2 ? (o4 = St(e2.anchor, e2.width, e2.height, e2.textOffset, e2.textScale), h2 && o4._rotate(u2 ? this.transform.angle : -this.transform.angle)) : r4 = false;
                      }
                      n2 && (r4 = !v2.clipped), i3.textBox && At(t2.textCollisionBox.collisionVertexArray, v2.text.placed, !r4 || w2, o4.x, o4.y), i3.verticalTextBox && At(t2.textCollisionBox.collisionVertexArray, v2.text.placed, !r4 || T2, o4.x, o4.y);
                    }
                    const s3 = r4 && Boolean(!T2 && i3.verticalIconBox);
                    i3.iconBox && At(t2.iconCollisionBox.collisionVertexArray, v2.icon.placed, s3, _2 ? o4.x : 0, _2 ? o4.y : 0), i3.verticalIconBox && At(t2.iconCollisionBox.collisionVertexArray, v2.icon.placed, !s3, _2 ? o4.x : 0, _2 ? o4.y : 0);
                  }
                }
              }
              if (t2.fullyClipped = 0 === m2, t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.bucketInstanceId in this.collisionCircleArrays) {
                const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
                t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
              }
            }
            symbolFadeChange(e2) {
              return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e2) {
              return Math.max(0, (this.transform.zoom - e2) / 1.5);
            }
            hasTransitions(e2) {
              return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e2, t2) {
              const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
              return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
            }
            setStale() {
              this.stale = true;
            }
          }
          function At(e2, t2, i2, o2, r2) {
            e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0);
          }
          const zt = Math.pow(2, 25), Pt = Math.pow(2, 24), Rt = Math.pow(2, 17), Ot = Math.pow(2, 16), Bt = Math.pow(2, 9), kt = Math.pow(2, 8), Ft = Math.pow(2, 1);
          function Ut(e2) {
            if (0 === e2.opacity && !e2.placed)
              return 0;
            if (1 === e2.opacity && e2.placed)
              return 4294967295;
            const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
            return i2 * zt + t2 * Pt + i2 * Rt + t2 * Ot + i2 * Bt + t2 * kt + i2 * Ft + t2;
          }
          const Nt = 0;
          class Gt {
            constructor(e2) {
              this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && void 0 !== e2.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }
            continuePlacement(e2, t2, i2, o2, r2) {
              const n2 = this._bucketParts;
              for (; this._currentTileIndex < e2.length; )
                if (t2.getBucketParts(n2, o2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r2())
                  return true;
              for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < n2.length; ) {
                const e3 = n2[this._currentPartIndex];
                if (t2.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, 0 === e3.symbolInstanceStart), this._currentPartIndex++, r2())
                  return true;
              }
              return false;
            }
          }
          class jt {
            constructor(e2, t2, i2, o2, r2, n2, s2, a2) {
              this.placement = new Lt(e2, r2, n2, s2, a2), this._currentPlacementIndex = t2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
            }
            isDone() {
              return this._done;
            }
            continuePlacement(t2, i2, o2) {
              const r2 = e.exported.now(), n2 = () => {
                const t3 = e.exported.now() - r2;
                return !this._forceFullPlacement && t3 > 2;
              };
              for (; this._currentPlacementIndex >= 0; ) {
                const e2 = i2[t2[this._currentPlacementIndex]], r3 = this.placement.collisionIndex.transform.zoom;
                if ("symbol" === e2.type && (!e2.minzoom || e2.minzoom <= r3) && (!e2.maxzoom || e2.maxzoom > r3)) {
                  if (this._inProgressLayer || (this._inProgressLayer = new Gt(e2)), this._inProgressLayer.continuePlacement(o2[e2.source], this.placement, this._showCollisionBoxes, e2, n2))
                    return;
                  delete this._inProgressLayer;
                }
                this._currentPlacementIndex--;
              }
              this._done = true;
            }
            commit(e2) {
              return this.placement.commit(e2), this.placement;
            }
          }
          const Zt = 512 / e.EXTENT / 2;
          class Vt {
            constructor(e2, t2, i2) {
              this.tileID = e2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
              for (let i3 = 0; i3 < t2.length; i3++) {
                const o2 = t2.get(i3), r2 = o2.key;
                this.indexedSymbolInstances[r2] || (this.indexedSymbolInstances[r2] = []), this.indexedSymbolInstances[r2].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, e2) });
              }
            }
            getScaledCoordinates(t2, i2) {
              const o2 = Zt / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
              return { x: Math.floor((i2.canonical.x * e.EXTENT + t2.tileAnchorX) * o2), y: Math.floor((i2.canonical.y * e.EXTENT + t2.tileAnchorY) * o2) };
            }
            findMatches(e2, t2, i2) {
              const o2 = this.tileID.canonical.z < t2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t2.canonical.z);
              for (let r2 = 0; r2 < e2.length; r2++) {
                const n2 = e2.get(r2);
                if (n2.crossTileID)
                  continue;
                const s2 = this.indexedSymbolInstances[n2.key];
                if (!s2)
                  continue;
                const a2 = this.getScaledCoordinates(n2, t2);
                for (const e3 of s2)
                  if (Math.abs(e3.coord.x - a2.x) <= o2 && Math.abs(e3.coord.y - a2.y) <= o2 && !i2[e3.crossTileID]) {
                    i2[e3.crossTileID] = true, n2.crossTileID = e3.crossTileID;
                    break;
                  }
              }
            }
          }
          class Wt {
            constructor() {
              this.maxCrossTileID = 0;
            }
            generate() {
              return ++this.maxCrossTileID;
            }
          }
          class Xt {
            constructor() {
              this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e2) {
              const t2 = Math.round((e2 - this.lng) / 360);
              if (0 !== t2)
                for (const e3 in this.indexes) {
                  const i2 = this.indexes[e3], o2 = {};
                  for (const e4 in i2) {
                    const r2 = i2[e4];
                    r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + t2), o2[r2.tileID.key] = r2;
                  }
                  this.indexes[e3] = o2;
                }
              this.lng = e2;
            }
            addBucket(e2, t2, i2) {
              if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
                if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId)
                  return false;
                this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
              }
              for (let e3 = 0; e3 < t2.symbolInstances.length; e3++)
                t2.symbolInstances.get(e3).crossTileID = 0;
              this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = {});
              const o2 = this.usedCrossTileIDs[e2.overscaledZ];
              for (const i3 in this.indexes) {
                const r2 = this.indexes[i3];
                if (Number(i3) > e2.overscaledZ)
                  for (const i4 in r2) {
                    const n2 = r2[i4];
                    n2.tileID.isChildOf(e2) && n2.findMatches(t2.symbolInstances, e2, o2);
                  }
                else {
                  const n2 = r2[e2.scaledTo(Number(i3)).key];
                  n2 && n2.findMatches(t2.symbolInstances, e2, o2);
                }
              }
              for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
                const r2 = t2.symbolInstances.get(e3);
                r2.crossTileID || (r2.crossTileID = i2.generate(), o2[r2.crossTileID] = true);
              }
              return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new Vt(e2, t2.symbolInstances, t2.bucketInstanceId), true;
            }
            removeBucketCrossTileIDs(e2, t2) {
              for (const i2 in t2.indexedSymbolInstances)
                for (const o2 of t2.indexedSymbolInstances[i2])
                  delete this.usedCrossTileIDs[e2][o2.crossTileID];
            }
            removeStaleBuckets(e2) {
              let t2 = false;
              for (const i2 in this.indexes) {
                const o2 = this.indexes[i2];
                for (const r2 in o2)
                  e2[o2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r2]), delete o2[r2], t2 = true);
              }
              return t2;
            }
          }
          class qt {
            constructor() {
              this.layerIndexes = {}, this.crossTileIDs = new Wt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e2, t2, i2, o2) {
              let r2 = this.layerIndexes[e2.id];
              void 0 === r2 && (r2 = this.layerIndexes[e2.id] = new Xt());
              let n2 = false;
              const s2 = {};
              "globe" !== o2.name && r2.handleWrapJump(i2);
              for (const i3 of t2) {
                const t3 = i3.getBucket(e2);
                t3 && e2.id === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), r2.addBucket(i3.tileID, t3, this.crossTileIDs) && (n2 = true), s2[t3.bucketInstanceId] = true);
              }
              return r2.removeStaleBuckets(s2) && (n2 = true), n2;
            }
            pruneUnusedLayers(e2) {
              const t2 = {};
              e2.forEach((e3) => {
                t2[e3] = true;
              });
              for (const e3 in this.layerIndexes)
                t2[e3] || delete this.layerIndexes[e3];
            }
          }
          const $t = (t2, i2) => e.emitValidationErrors(t2, i2 && i2.filter((e2) => "source.canvas" !== e2.identifier)), Ht = e.pick(We, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]), Yt = e.pick(We, ["setCenter", "setZoom", "setBearing", "setPitch"]), Kt = { version: 8, layers: [], sources: {} }, Jt = { fill: true, line: true, background: true, hillshade: true, raster: true };
          class Qt extends e.Evented {
            constructor(t2, i2 = {}) {
              super(), this.map = t2, this.dispatcher = new z(je(), this), this.imageManager = new y(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t2._requestManager, i2.localFontFamily ? e.LocalGlyphMode.all : i2.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i2.localFontFamily || i2.localIdeographFontFamily), this.crossTileSymbolIndex = new qt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer());
              const o2 = this;
              this._rtlTextPluginCallback = Qt.registerForPluginStateChange((t3) => {
                o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
                  if (e.triggerPluginCompletionEvent(t4), i3 && i3.every((e2) => e2))
                    for (const e2 in o2._sourceCaches) {
                      const t5 = o2._sourceCaches[e2], i4 = t5.getSource().type;
                      "vector" !== i4 && "geojson" !== i4 || t5.reload();
                    }
                });
              }), this.on("data", (e2) => {
                if ("source" !== e2.dataType || "metadata" !== e2.sourceDataType)
                  return;
                const t3 = this.getSource(e2.sourceId);
                if (t3 && t3.vectorLayerIds)
                  for (const e3 in this._layers) {
                    const i3 = this._layers[e3];
                    i3.source === t3.id && this._validateLayer(i3);
                  }
              });
            }
            loadURL(t2, i2 = {}) {
              this.fire(new e.Event("dataloading", { dataType: "style" }));
              const o2 = "boolean" == typeof i2.validate ? i2.validate : !e.isMapboxURL(t2);
              t2 = this.map._requestManager.normalizeStyleURL(t2, i2.accessToken);
              const r2 = this.map._requestManager.transformRequest(t2, e.ResourceType.Style);
              this._request = e.getJSON(r2, (t3, i3) => {
                this._request = null, t3 ? this.fire(new e.ErrorEvent(t3)) : i3 && this._load(i3, o2);
              });
            }
            loadJSON(t2, i2 = {}) {
              this.fire(new e.Event("dataloading", { dataType: "style" })), this._request = e.exported.frame(() => {
                this._request = null, this._load(t2, false !== i2.validate);
              });
            }
            loadEmpty() {
              this.fire(new e.Event("dataloading", { dataType: "style" })), this._load(Kt, false);
            }
            _updateLayerCount(e2, t2) {
              const i2 = t2 ? 1 : -1;
              e2.is3D() && (this._num3DLayers += i2), "circle" === e2.type && (this._numCircleLayers += i2), "symbol" === e2.type && (this._numSymbolLayers += i2);
            }
            _load(t2, i2) {
              if (i2 && $t(this, e.validateStyle(t2)))
                return;
              this._loaded = true, this.stylesheet = e.clone$1(t2), this._updateMapProjection();
              for (const e2 in t2.sources)
                this.addSource(e2, t2.sources[e2], { validate: false });
              this._changed = false, t2.sprite ? this._loadSprite(t2.sprite) : (this.imageManager.setLoaded(true), this.dispatcher.broadcast("spriteLoaded", true)), this.glyphManager.setURL(t2.glyphs);
              const o2 = Ve(this.stylesheet.layers);
              this._order = o2.map((e2) => e2.id), this._layers = {}, this._serializedLayers = {};
              for (const t3 of o2) {
                const i3 = e.createStyleLayer(t3);
                i3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = i3, this._serializedLayers[i3.id] = i3.serialize(), this._updateLayerCount(i3, true);
              }
              this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new T(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", { dataType: "style" })), this.fire(new e.Event("style.load"));
            }
            terrainSetForDrapingOnly() {
              return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }
            setProjection(e2) {
              e2 ? this.stylesheet.projection = e2 : delete this.stylesheet.projection, this._updateMapProjection();
            }
            applyProjectionUpdate() {
              this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
            }
            _updateMapProjection() {
              this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
            }
            _loadSprite(t2) {
              this._spriteRequest = function(t3, i2, o2) {
                let r2, n2, s2;
                const a2 = e.exported.devicePixelRatio > 1 ? "@2x" : "";
                let l2 = e.getJSON(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".json"), e.ResourceType.SpriteJSON), (e2, t4) => {
                  l2 = null, s2 || (s2 = e2, r2 = t4, h2());
                }), c2 = e.getImage(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".png"), e.ResourceType.SpriteImage), (e2, t4) => {
                  c2 = null, s2 || (s2 = e2, n2 = t4, h2());
                });
                function h2() {
                  if (s2)
                    o2(s2);
                  else if (r2 && n2) {
                    const t4 = e.exported.getImageData(n2), i3 = {};
                    for (const o3 in r2) {
                      const { width: n3, height: s3, x: a3, y: l3, sdf: c3, pixelRatio: h3, stretchX: u2, stretchY: _2, content: d2 } = r2[o3], p2 = new e.RGBAImage({ width: n3, height: s3 });
                      e.RGBAImage.copy(t4, p2, { x: a3, y: l3 }, { x: 0, y: 0 }, { width: n3, height: s3 }), i3[o3] = { data: p2, pixelRatio: h3, sdf: c3, stretchX: u2, stretchY: _2, content: d2 };
                    }
                    o2(null, i3);
                  }
                }
                return { cancel() {
                  l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
                } };
              }(t2, this.map._requestManager, (t3, i2) => {
                if (this._spriteRequest = null, t3)
                  this.fire(new e.ErrorEvent(t3));
                else if (i2)
                  for (const e2 in i2)
                    this.imageManager.addImage(e2, i2[e2]);
                this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", true), this.fire(new e.Event("data", { dataType: "style" }));
              });
            }
            _validateLayer(t2) {
              const i2 = this.getSource(t2.source);
              if (!i2)
                return;
              const o2 = t2.sourceLayer;
              o2 && ("geojson" === i2.type || i2.vectorLayerIds && -1 === i2.vectorLayerIds.indexOf(o2)) && this.fire(new e.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${t2.id}"`)));
            }
            loaded() {
              if (!this._loaded)
                return false;
              if (Object.keys(this._updatedSources).length)
                return false;
              for (const e2 in this._sourceCaches)
                if (!this._sourceCaches[e2].loaded())
                  return false;
              return !!this.imageManager.isLoaded();
            }
            _serializeLayers(e2) {
              const t2 = [];
              for (const i2 of e2) {
                const e3 = this._layers[i2];
                "custom" !== e3.type && t2.push(e3.serialize());
              }
              return t2;
            }
            hasTransitions() {
              if (this.light && this.light.hasTransition())
                return true;
              if (this.fog && this.fog.hasTransition())
                return true;
              for (const e2 in this._sourceCaches)
                if (this._sourceCaches[e2].hasTransition())
                  return true;
              for (const e2 in this._layers)
                if (this._layers[e2].hasTransition())
                  return true;
              return false;
            }
            get order() {
              return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
            }
            isLayerDraped(e2) {
              return !!this.terrain && ("function" == typeof e2.isLayerDraped ? e2.isLayerDraped() : Jt[e2.type]);
            }
            _checkLoaded() {
              if (!this._loaded)
                throw new Error("Style is not done loading");
            }
            update(t2) {
              if (!this._loaded)
                return;
              const i2 = this._changed;
              if (this._changed) {
                const e2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
                (e2.length || i3.length) && this._updateWorkerLayers(e2, i3);
                for (const e3 in this._updatedSources) {
                  const t3 = this._updatedSources[e3];
                  "reload" === t3 ? this._reloadSource(e3) : "clear" === t3 && this._clearSource(e3);
                }
                this._updateTilesForChangedImages();
                for (const e3 in this._updatedPaintProps)
                  this._layers[e3].updateTransitions(t2);
                this.light.updateTransitions(t2), this.fog && this.fog.updateTransitions(t2), this._resetUpdates();
              }
              const o2 = {};
              for (const e2 in this._sourceCaches) {
                const t3 = this._sourceCaches[e2];
                o2[e2] = t3.used, t3.used = false;
              }
              for (const e2 of this._order) {
                const i3 = this._layers[e2];
                if (i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom)) {
                  const e3 = this._getLayerSourceCache(i3);
                  e3 && (e3.used = true);
                }
                const o3 = this.map.painter;
                if (o3) {
                  const e3 = i3.getProgramIds();
                  if (!e3)
                    continue;
                  const r2 = i3.getProgramConfiguration(t2.zoom);
                  for (const t3 of e3)
                    o3.useProgram(t3, r2);
                }
              }
              for (const t3 in o2) {
                const i3 = this._sourceCaches[t3];
                o2[t3] !== i3.used && i3.getSource().fire(new e.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
              }
              this.light.recalculate(t2), this.terrain && this.terrain.recalculate(t2), this.fog && this.fog.recalculate(t2), this.z = t2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), i2 && this.fire(new e.Event("data", { dataType: "style" }));
            }
            _updateTilesForChangedImages() {
              const e2 = Object.keys(this._changedImages);
              if (e2.length) {
                for (const t2 in this._sourceCaches)
                  this._sourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
                this._changedImages = {};
              }
            }
            _updateWorkerLayers(e2, t2) {
              this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e2), removedIds: t2 });
            }
            _resetUpdates() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
            }
            setState(i2) {
              if (this._checkLoaded(), $t(this, e.validateStyle(i2)))
                return false;
              (i2 = e.clone$1(i2)).layers = Ve(i2.layers);
              const o2 = function(e2, i3) {
                if (!e2)
                  return [{ command: We.setStyle, args: [i3] }];
                let o3 = [];
                try {
                  if (!t(e2.version, i3.version))
                    return [{ command: We.setStyle, args: [i3] }];
                  t(e2.center, i3.center) || o3.push({ command: We.setCenter, args: [i3.center] }), t(e2.zoom, i3.zoom) || o3.push({ command: We.setZoom, args: [i3.zoom] }), t(e2.bearing, i3.bearing) || o3.push({ command: We.setBearing, args: [i3.bearing] }), t(e2.pitch, i3.pitch) || o3.push({ command: We.setPitch, args: [i3.pitch] }), t(e2.sprite, i3.sprite) || o3.push({ command: We.setSprite, args: [i3.sprite] }), t(e2.glyphs, i3.glyphs) || o3.push({ command: We.setGlyphs, args: [i3.glyphs] }), t(e2.transition, i3.transition) || o3.push({ command: We.setTransition, args: [i3.transition] }), t(e2.light, i3.light) || o3.push({ command: We.setLight, args: [i3.light] }), t(e2.fog, i3.fog) || o3.push({ command: We.setFog, args: [i3.fog] }), t(e2.projection, i3.projection) || o3.push({ command: We.setProjection, args: [i3.projection] });
                  const r3 = {}, n2 = [];
                  !function(e3, i4, o4, r4) {
                    let n3;
                    for (n3 in i4 = i4 || {}, e3 = e3 || {})
                      e3.hasOwnProperty(n3) && (i4.hasOwnProperty(n3) || qe(n3, o4, r4));
                    for (n3 in i4) {
                      if (!i4.hasOwnProperty(n3))
                        continue;
                      const s3 = i4[n3];
                      e3.hasOwnProperty(n3) ? t(e3[n3], s3) || ("geojson" === e3[n3].type && "geojson" === s3.type && He(e3, i4, n3) ? o4.push({ command: We.setGeoJSONSourceData, args: [n3, s3.data] }) : $e(n3, i4, o4, r4)) : Xe(n3, i4, o4);
                    }
                  }(e2.sources, i3.sources, n2, r3);
                  const s2 = [];
                  e2.layers && e2.layers.forEach((e3) => {
                    e3.source && r3[e3.source] ? o3.push({ command: We.removeLayer, args: [e3.id] }) : s2.push(e3);
                  });
                  let a2 = e2.terrain;
                  a2 && r3[a2.source] && (o3.push({ command: We.setTerrain, args: [void 0] }), a2 = void 0), o3 = o3.concat(n2), t(a2, i3.terrain) || o3.push({ command: We.setTerrain, args: [i3.terrain] }), function(e3, i4, o4) {
                    i4 = i4 || [];
                    const r4 = (e3 = e3 || []).map(Ke), n3 = i4.map(Ke), s3 = e3.reduce(Je, {}), a3 = i4.reduce(Je, {}), l2 = r4.slice(), c2 = /* @__PURE__ */ Object.create(null);
                    let h2, u2, _2, d2, p2, m2, f2;
                    for (h2 = 0, u2 = 0; h2 < r4.length; h2++)
                      _2 = r4[h2], a3.hasOwnProperty(_2) ? u2++ : (o4.push({ command: We.removeLayer, args: [_2] }), l2.splice(l2.indexOf(_2, u2), 1));
                    for (h2 = 0, u2 = 0; h2 < n3.length; h2++)
                      _2 = n3[n3.length - 1 - h2], l2[l2.length - 1 - h2] !== _2 && (s3.hasOwnProperty(_2) ? (o4.push({ command: We.removeLayer, args: [_2] }), l2.splice(l2.lastIndexOf(_2, l2.length - u2), 1)) : u2++, m2 = l2[l2.length - h2], o4.push({ command: We.addLayer, args: [a3[_2], m2] }), l2.splice(l2.length - h2, 0, _2), c2[_2] = true);
                    for (h2 = 0; h2 < n3.length; h2++)
                      if (_2 = n3[h2], d2 = s3[_2], p2 = a3[_2], !c2[_2] && !t(d2, p2))
                        if (t(d2.source, p2.source) && t(d2["source-layer"], p2["source-layer"]) && t(d2.type, p2.type)) {
                          for (f2 in Ye(d2.layout, p2.layout, o4, _2, null, We.setLayoutProperty), Ye(d2.paint, p2.paint, o4, _2, null, We.setPaintProperty), t(d2.filter, p2.filter) || o4.push({ command: We.setFilter, args: [_2, p2.filter] }), t(d2.minzoom, p2.minzoom) && t(d2.maxzoom, p2.maxzoom) || o4.push({ command: We.setLayerZoomRange, args: [_2, p2.minzoom, p2.maxzoom] }), d2)
                            d2.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Ye(d2[f2], p2[f2], o4, _2, f2.slice(6), We.setPaintProperty) : t(d2[f2], p2[f2]) || o4.push({ command: We.setLayerProperty, args: [_2, f2, p2[f2]] }));
                          for (f2 in p2)
                            p2.hasOwnProperty(f2) && !d2.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Ye(d2[f2], p2[f2], o4, _2, f2.slice(6), We.setPaintProperty) : t(d2[f2], p2[f2]) || o4.push({ command: We.setLayerProperty, args: [_2, f2, p2[f2]] }));
                        } else
                          o4.push({ command: We.removeLayer, args: [_2] }), m2 = l2[l2.lastIndexOf(_2) + 1], o4.push({ command: We.addLayer, args: [p2, m2] });
                  }(s2, i3.layers, o3);
                } catch (e3) {
                  console.warn("Unable to compute style diff:", e3), o3 = [{ command: We.setStyle, args: [i3] }];
                }
                return o3;
              }(this.serialize(), i2).filter((e2) => !(e2.command in Yt));
              if (0 === o2.length)
                return false;
              const r2 = o2.filter((e2) => !(e2.command in Ht));
              if (r2.length > 0)
                throw new Error(`Unimplemented: ${r2.map((e2) => e2.command).join(", ")}.`);
              return o2.forEach((e2) => {
                "setTransition" !== e2.command && "setProjection" !== e2.command && this[e2.command].apply(this, e2.args);
              }), this.stylesheet = i2, this._updateMapProjection(), true;
            }
            addImage(t2, i2) {
              return this.getImage(t2) ? this.fire(new e.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t2, i2), this._afterImageUpdated(t2), this);
            }
            updateImage(e2, t2) {
              this.imageManager.updateImage(e2, t2);
            }
            getImage(e2) {
              return this.imageManager.getImage(e2);
            }
            removeImage(t2) {
              return this.getImage(t2) ? (this.imageManager.removeImage(t2), this._afterImageUpdated(t2), this) : this.fire(new e.ErrorEvent(new Error("No image with this name exists.")));
            }
            _afterImageUpdated(t2) {
              this._availableImages = this.imageManager.listImages(), this._changedImages[t2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", { dataType: "style" }));
            }
            listImages() {
              return this._checkLoaded(), this._availableImages.slice();
            }
            addSource(t2, i2, o2 = {}) {
              if (this._checkLoaded(), void 0 !== this.getSource(t2))
                throw new Error("There is already a source with this ID");
              if (!i2.type)
                throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
              if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.validateSource, `sources.${t2}`, i2, null, o2))
                return;
              this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
              const r2 = Pe(t2, i2, this.dispatcher, this);
              r2.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(t2), source: r2.serialize(), sourceId: t2 }));
              const n2 = (i3) => {
                const o3 = (i3 ? "symbol:" : "other:") + t2, n3 = this._sourceCaches[o3] = new e.SourceCache(o3, r2, i3);
                (i3 ? this._symbolSourceCaches : this._otherSourceCaches)[t2] = n3, n3.style = this, n3.onAdd(this.map);
              };
              n2(false), "vector" !== i2.type && "geojson" !== i2.type || n2(true), r2.onAdd && r2.onAdd(this.map), this._changed = true;
            }
            removeSource(t2) {
              this._checkLoaded();
              const i2 = this.getSource(t2);
              if (!i2)
                throw new Error("There is no source with this ID");
              for (const i3 in this._layers)
                if (this._layers[i3].source === t2)
                  return this.fire(new e.ErrorEvent(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
              if (this.terrain && this.terrain.get().source === t2)
                return this.fire(new e.ErrorEvent(new Error(`Source "${t2}" cannot be removed while terrain is using it.`)));
              const o2 = this._getSourceCaches(t2);
              for (const t3 of o2)
                delete this._sourceCaches[t3.id], delete this._updatedSources[t3.id], t3.fire(new e.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
              return delete this._otherSourceCaches[t2], delete this._symbolSourceCaches[t2], i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changed = true, this;
            }
            setGeoJSONSourceData(e2, t2) {
              this._checkLoaded(), this.getSource(e2).setData(t2), this._changed = true;
            }
            getSource(e2) {
              const t2 = this._getSourceCache(e2);
              return t2 && t2.getSource();
            }
            _getSources() {
              const e2 = [];
              for (const t2 in this._otherSourceCaches) {
                const i2 = this._getSourceCache(t2);
                i2 && e2.push(i2.getSource());
              }
              return e2;
            }
            addLayer(t2, i2, o2 = {}) {
              this._checkLoaded();
              const r2 = t2.id;
              if (this.getLayer(r2))
                return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r2}" already exists on this map`)));
              let n2;
              if ("custom" === t2.type) {
                if ($t(this, e.validateCustomStyleLayer(t2)))
                  return;
                n2 = e.createStyleLayer(t2);
              } else {
                if ("object" == typeof t2.source && (this.addSource(r2, t2.source), t2 = e.clone$1(t2), t2 = e.extend(t2, { source: r2 })), this._validate(e.validateLayer, `layers.${r2}`, t2, { arrayIndex: -1 }, o2))
                  return;
                n2 = e.createStyleLayer(t2), this._validateLayer(n2), n2.setEventedParent(this, { layer: { id: r2 } }), this._serializedLayers[n2.id] = n2.serialize(), this._updateLayerCount(n2, true);
              }
              const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
              if (i2 && -1 === s2)
                return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`)));
              this._order.splice(s2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = n2;
              const a2 = this._getLayerSourceCache(n2);
              if (this._removedLayers[r2] && n2.source && a2 && "custom" !== n2.type) {
                const e2 = this._removedLayers[r2];
                delete this._removedLayers[r2], e2.type !== n2.type ? this._updatedSources[n2.source] = "clear" : (this._updatedSources[n2.source] = "reload", a2.pause());
              }
              this._updateLayer(n2), n2.onAdd && n2.onAdd(this.map), this._updateDrapeFirstLayers();
            }
            moveLayer(t2, i2) {
              if (this._checkLoaded(), this._changed = true, !this._layers[t2])
                return void this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be moved.`)));
              if (t2 === i2)
                return;
              const o2 = this._order.indexOf(t2);
              this._order.splice(o2, 1);
              const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
              i2 && -1 === r2 ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`))) : (this._order.splice(r2, 0, t2), this._layerOrderChanged = true, this._updateDrapeFirstLayers());
            }
            removeLayer(t2) {
              this._checkLoaded();
              const i2 = this._layers[t2];
              if (!i2)
                return void this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be removed.`)));
              i2.setEventedParent(null), this._updateLayerCount(i2, false);
              const o2 = this._order.indexOf(t2);
              this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t2] = i2, delete this._layers[t2], delete this._serializedLayers[t2], delete this._updatedLayers[t2], delete this._updatedPaintProps[t2], i2.onRemove && i2.onRemove(this.map), this._updateDrapeFirstLayers();
            }
            getLayer(e2) {
              return this._layers[e2];
            }
            hasLayer(e2) {
              return e2 in this._layers;
            }
            hasLayerType(e2) {
              for (const t2 in this._layers)
                if (this._layers[t2].type === e2)
                  return true;
              return false;
            }
            setLayerZoomRange(t2, i2, o2) {
              this._checkLoaded();
              const r2 = this.getLayer(t2);
              r2 ? r2.minzoom === i2 && r2.maxzoom === o2 || (null != i2 && (r2.minzoom = i2), null != o2 && (r2.maxzoom = o2), this._updateLayer(r2)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot have zoom extent.`)));
            }
            setFilter(i2, o2, r2 = {}) {
              this._checkLoaded();
              const n2 = this.getLayer(i2);
              if (n2) {
                if (!t(n2.filter, o2))
                  return null == o2 ? (n2.filter = void 0, void this._updateLayer(n2)) : void (this._validate(e.validateFilter, `layers.${n2.id}.filter`, o2, { layerType: n2.type }, r2) || (n2.filter = e.clone$1(o2), this._updateLayer(n2)));
              } else
                this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be filtered.`)));
            }
            getFilter(t2) {
              const i2 = this.getLayer(t2);
              return i2 && e.clone$1(i2.filter);
            }
            setLayoutProperty(i2, o2, r2, n2 = {}) {
              this._checkLoaded();
              const s2 = this.getLayer(i2);
              s2 ? t(s2.getLayoutProperty(o2), r2) || (s2.setLayoutProperty(o2, r2, n2), this._updateLayer(s2)) : this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be styled.`)));
            }
            getLayoutProperty(t2, i2) {
              const o2 = this.getLayer(t2);
              if (o2)
                return o2.getLayoutProperty(i2);
              this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style.`)));
            }
            setPaintProperty(i2, o2, r2, n2 = {}) {
              this._checkLoaded();
              const s2 = this.getLayer(i2);
              s2 ? t(s2.getPaintProperty(o2), r2) || (s2.setPaintProperty(o2, r2, n2) && this._updateLayer(s2), this._changed = true, this._updatedPaintProps[i2] = true) : this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be styled.`)));
            }
            getPaintProperty(e2, t2) {
              const i2 = this.getLayer(e2);
              return i2 && i2.getPaintProperty(t2);
            }
            setFeatureState(t2, i2) {
              this._checkLoaded();
              const o2 = t2.source, r2 = t2.sourceLayer, n2 = this.getSource(o2);
              if (!n2)
                return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
              const s2 = n2.type;
              if ("geojson" === s2 && r2)
                return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
              if ("vector" === s2 && !r2)
                return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              void 0 === t2.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));
              const a2 = this._getSourceCaches(o2);
              for (const e2 of a2)
                e2.setFeatureState(r2, t2.id, i2);
            }
            removeFeatureState(t2, i2) {
              this._checkLoaded();
              const o2 = t2.source, r2 = this.getSource(o2);
              if (!r2)
                return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
              const n2 = r2.type, s2 = "vector" === n2 ? t2.sourceLayer : void 0;
              if ("vector" === n2 && !s2)
                return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              if (i2 && "string" != typeof t2.id && "number" != typeof t2.id)
                return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
              const a2 = this._getSourceCaches(o2);
              for (const e2 of a2)
                e2.removeFeatureState(s2, t2.id, i2);
            }
            getFeatureState(t2) {
              this._checkLoaded();
              const i2 = t2.source, o2 = t2.sourceLayer, r2 = this.getSource(i2);
              if (r2) {
                if ("vector" !== r2.type || o2)
                  return void 0 === t2.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i2)[0].getFeatureState(o2, t2.id);
                this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              } else
                this.fire(new e.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
            }
            getTransition() {
              return e.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
              const t2 = {};
              for (const e2 in this._sourceCaches) {
                const i2 = this._sourceCaches[e2].getSource();
                t2[i2.id] || (t2[i2.id] = i2.serialize());
              }
              return e.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.getTerrain() || void 0, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: t2, layers: this._serializeLayers(this._order) }, (e2) => void 0 !== e2);
            }
            _updateLayer(e2) {
              this._updatedLayers[e2.id] = true;
              const t2 = this._getLayerSourceCache(e2);
              e2.source && !this._updatedSources[e2.source] && t2 && "raster" !== t2.getSource().type && (this._updatedSources[e2.source] = "reload", t2.pause()), this._changed = true, e2.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(e2) {
              const t2 = (e3) => "fill-extrusion" === this._layers[e3].type, i2 = {}, o2 = [];
              for (let r3 = this._order.length - 1; r3 >= 0; r3--) {
                const n2 = this._order[r3];
                if (t2(n2)) {
                  i2[n2] = r3;
                  for (const t3 of e2) {
                    const e3 = t3[n2];
                    if (e3)
                      for (const t4 of e3)
                        o2.push(t4);
                  }
                }
              }
              o2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
              const r2 = [];
              for (let n2 = this._order.length - 1; n2 >= 0; n2--) {
                const s2 = this._order[n2];
                if (t2(s2))
                  for (let e3 = o2.length - 1; e3 >= 0; e3--) {
                    const t3 = o2[e3].feature;
                    if (i2[t3.layer.id] < n2)
                      break;
                    r2.push(t3), o2.pop();
                  }
                else
                  for (const t3 of e2) {
                    const e3 = t3[s2];
                    if (e3)
                      for (const t4 of e3)
                        r2.push(t4.feature);
                  }
              }
              return r2;
            }
            queryRenderedFeatures(t2, i2, o2) {
              i2 && i2.filter && this._validate(e.validateFilter, "queryRenderedFeatures.filter", i2.filter, null, i2);
              const r2 = {};
              if (i2 && i2.layers) {
                if (!Array.isArray(i2.layers))
                  return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                for (const t3 of i2.layers) {
                  const i3 = this._layers[t3];
                  if (!i3)
                    return this.fire(new e.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
                  r2[i3.source] = true;
                }
              }
              const n2 = [];
              i2.availableImages = this._availableImages;
              const s2 = i2 && i2.layers ? i2.layers.some((e2) => {
                const t3 = this.getLayer(e2);
                return t3 && t3.is3D();
              }) : this.has3DLayers(), a2 = R.createFromScreenPoints(t2, o2);
              for (const e2 in this._sourceCaches) {
                const t3 = this._sourceCaches[e2].getSource().id;
                i2.layers && !r2[t3] || n2.push(Oe(this._sourceCaches[e2], this._layers, this._serializedLayers, a2, i2, o2, s2, !!this.map._showQueryGeometry));
              }
              return this.placement && n2.push(function(e2, t3, i3, o3, r3, n3, s3) {
                const a3 = {}, l2 = n3.queryRenderedSymbols(o3), c2 = [];
                for (const e3 of Object.keys(l2).map(Number))
                  c2.push(s3[e3]);
                c2.sort(ke);
                for (const i4 of c2) {
                  const o4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], t3, i4.bucketIndex, i4.sourceLayerIndex, r3.filter, r3.layers, r3.availableImages, e2);
                  for (const e3 in o4) {
                    const t4 = a3[e3] = a3[e3] || [], r4 = o4[e3];
                    r4.sort((e4, t5) => {
                      const o5 = i4.featureSortOrder;
                      if (o5) {
                        const i5 = o5.indexOf(e4.featureIndex);
                        return o5.indexOf(t5.featureIndex) - i5;
                      }
                      return t5.featureIndex - e4.featureIndex;
                    });
                    for (const e4 of r4)
                      t4.push(e4);
                  }
                }
                for (const t4 in a3)
                  a3[t4].forEach((o4) => {
                    const r4 = o4.feature, n4 = i3(e2[t4]);
                    if (!n4)
                      return;
                    const s4 = n4.getFeatureState(r4.layer["source-layer"], r4.id);
                    r4.source = r4.layer.source, r4.layer["source-layer"] && (r4.sourceLayer = r4.layer["source-layer"]), r4.state = s4;
                  });
                return a3;
              }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a2.screenGeometry, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n2);
            }
            querySourceFeatures(t2, i2) {
              i2 && i2.filter && this._validate(e.validateFilter, "querySourceFeatures.filter", i2.filter, null, i2);
              const o2 = this._getSourceCaches(t2);
              let r2 = [];
              for (const e2 of o2)
                r2 = r2.concat(Be(e2, i2));
              return r2;
            }
            addSourceType(e2, t2, i2) {
              return Qt.getSourceType(e2) ? i2(new Error(`A source type called "${e2}" already exists.`)) : (Qt.setSourceType(e2, t2), t2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e2, url: t2.workerSourceURL }, i2) : i2(null, null));
            }
            getLight() {
              return this.light.getLight();
            }
            setLight(e2, i2 = {}) {
              this._checkLoaded();
              const o2 = this.light.getLight();
              let r2 = false;
              for (const i3 in e2)
                if (!t(e2[i3], o2[i3])) {
                  r2 = true;
                  break;
                }
              if (!r2)
                return;
              const n2 = this._setTransitionParameters({ duration: 300, delay: 0 });
              this.light.setLight(e2, i2), this.light.updateTransitions(n2);
            }
            getTerrain() {
              return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }
            setTerrainForDraping() {
              this.setTerrain({ source: "", exaggeration: 0 }, 0);
            }
            setTerrain(i2, o2 = 1) {
              if (this._checkLoaded(), !i2)
                return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", false), this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
              let r2 = i2;
              if (1 === o2) {
                if ("object" == typeof r2.source) {
                  const t2 = "terrain-dem-src";
                  this.addSource(t2, r2.source), r2 = e.clone$1(r2), r2 = e.extend(r2, { source: t2 });
                }
                if (this._validate(e.validateTerrain, "terrain", r2))
                  return;
              }
              if (!this.terrain || this.terrain && o2 !== this.terrain.drapeRenderMode) {
                if (!r2)
                  return;
                this._createTerrain(r2, o2);
              } else {
                const i3 = this.terrain, o3 = i3.get();
                for (const t2 of Object.keys(e.spec.terrain))
                  !r2.hasOwnProperty(t2) && e.spec.terrain[t2].default && (r2[t2] = e.spec.terrain[t2].default);
                for (const e2 in r2)
                  if (!t(r2[e2], o3[e2])) {
                    i3.set(r2), this.stylesheet.terrain = r2;
                    const e3 = this._setTransitionParameters({ duration: 0 });
                    i3.updateTransitions(e3);
                    break;
                  }
              }
              this._updateDrapeFirstLayers(), this._markersNeedUpdate = true;
            }
            _createFog(e2) {
              const t2 = this.fog = new A(e2, this.map.transform);
              this.stylesheet.fog = e2;
              const i2 = this._setTransitionParameters({ duration: 0 });
              t2.updateTransitions(i2);
            }
            _updateMarkersOpacity() {
              0 !== this.map._markers.length && this.map._requestDomTask(() => {
                for (const e2 of this.map._markers)
                  e2._evaluateOpacity();
              });
            }
            getFog() {
              return this.fog ? this.fog.get() : null;
            }
            setFog(e2) {
              if (this._checkLoaded(), !e2)
                return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
              if (this.fog) {
                const i2 = this.fog, o2 = i2.get();
                0 === Object.keys(e2).length && i2.set(e2);
                for (const r2 in e2)
                  if (!t(e2[r2], o2[r2])) {
                    i2.set(e2), this.stylesheet.fog = e2;
                    const t2 = this._setTransitionParameters({ duration: 0 });
                    i2.updateTransitions(t2);
                    break;
                  }
              } else
                this._createFog(e2);
              this._markersNeedUpdate = true;
            }
            _setTransitionParameters(t2) {
              return { now: e.exported.now(), transition: e.extend(t2, this.stylesheet.transition) };
            }
            _updateDrapeFirstLayers() {
              if (!this.map._optimizeForTerrain || !this.terrain)
                return;
              const e2 = this._order.filter((e3) => this.isLayerDraped(this._layers[e3])), t2 = this._order.filter((e3) => !this.isLayerDraped(this._layers[e3]));
              this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e2), this._drapedFirstOrder.push(...t2);
            }
            _createTerrain(e2, t2) {
              const i2 = this.terrain = new M(e2, t2);
              this.stylesheet.terrain = e2, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
              const o2 = this._setTransitionParameters({ duration: 0 });
              i2.updateTransitions(o2);
            }
            _force3DLayerUpdate() {
              for (const e2 in this._layers) {
                const t2 = this._layers[e2];
                "fill-extrusion" === t2.type && this._updateLayer(t2);
              }
            }
            _forceSymbolLayerUpdate() {
              for (const e2 in this._layers) {
                const t2 = this._layers[e2];
                "symbol" === t2.type && this._updateLayer(t2);
              }
            }
            _validate(t2, i2, o2, r2, n2 = {}) {
              return (!n2 || false !== n2.validate) && $t(this, t2.call(e.validateStyle, e.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: e.spec }, r2)));
            }
            _remove() {
              this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback);
              for (const e2 in this._layers)
                this._layers[e2].setEventedParent(null);
              for (const e2 in this._sourceCaches)
                this._sourceCaches[e2].clearTiles(), this._sourceCaches[e2].setEventedParent(null);
              this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
            }
            _clearSource(e2) {
              const t2 = this._getSourceCaches(e2);
              for (const e3 of t2)
                e3.clearTiles();
            }
            _reloadSource(e2) {
              const t2 = this._getSourceCaches(e2);
              for (const e3 of t2)
                e3.resume(), e3.reload();
            }
            _reloadSources() {
              for (const e2 of this._getSources())
                e2.reload && e2.reload();
            }
            _updateSources(e2) {
              for (const t2 in this._sourceCaches)
                this._sourceCaches[t2].update(e2);
            }
            _generateCollisionBoxes() {
              for (const e2 in this._sourceCaches) {
                const t2 = this._sourceCaches[e2];
                t2.resume(), t2.reload();
              }
            }
            _updatePlacement(t2, i2, o2, r2, n2 = false) {
              let s2 = false, a2 = false;
              const l2 = {};
              for (const e2 of this._order) {
                const i3 = this._layers[e2];
                if ("symbol" !== i3.type)
                  continue;
                if (!l2[i3.source]) {
                  const e3 = this._getLayerSourceCache(i3);
                  if (!e3)
                    continue;
                  l2[i3.source] = e3.getRenderableIds(true).map((t3) => e3.getTileByID(t3)).sort((e4, t3) => t3.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t3.tileID) ? -1 : 1));
                }
                const o3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], t2.center.lng, t2.projection);
                s2 = s2 || o3;
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n2 = n2 || this._layerOrderChanged || 0 === o2, this._layerOrderChanged && this.fire(new e.Event("neworder")), (n2 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t2.zoom)) && (this.pauseablePlacement = new jt(t2, this._order, n2, i2, o2, r2, this.placement, this.fog && t2.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), a2 = true), s2 && this.pauseablePlacement.placement.setStale()), a2 || s2)
                for (const e2 of this._order) {
                  const t3 = this._layers[e2];
                  "symbol" === t3.type && this.placement.updateLayerOpacities(t3, l2[t3.source]);
                }
              return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());
            }
            _releaseSymbolFadeTiles() {
              for (const e2 in this._sourceCaches)
                this._sourceCaches[e2].releaseSymbolFadeTiles();
            }
            getImages(e2, t2, i2) {
              this.imageManager.getImages(t2.icons, i2), this._updateTilesForChangedImages();
              const o2 = (e3) => {
                e3 && e3.setDependencies(t2.tileID.key, t2.type, t2.icons);
              };
              o2(this._otherSourceCaches[t2.source]), o2(this._symbolSourceCaches[t2.source]);
            }
            getGlyphs(e2, t2, i2) {
              this.glyphManager.getGlyphs(t2.stacks, i2);
            }
            getResource(t2, i2, o2) {
              return e.makeRequest(i2, o2);
            }
            _getSourceCache(e2) {
              return this._otherSourceCaches[e2];
            }
            _getLayerSourceCache(e2) {
              return "symbol" === e2.type ? this._symbolSourceCaches[e2.source] : this._otherSourceCaches[e2.source];
            }
            _getSourceCaches(e2) {
              const t2 = [];
              return this._otherSourceCaches[e2] && t2.push(this._otherSourceCaches[e2]), this._symbolSourceCaches[e2] && t2.push(this._symbolSourceCaches[e2]), t2;
            }
            _isSourceCacheLoaded(t2) {
              const i2 = this._getSourceCaches(t2);
              return 0 === i2.length ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t2}'`))), false) : i2.every((e2) => e2.loaded());
            }
            has3DLayers() {
              return this._num3DLayers > 0;
            }
            hasSymbolLayers() {
              return this._numSymbolLayers > 0;
            }
            hasCircleLayers() {
              return this._numCircleLayers > 0;
            }
            _clearWorkerCaches() {
              this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
              this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
          }
          Qt.getSourceType = function(e2) {
            return ze[e2];
          }, Qt.setSourceType = function(e2, t2) {
            ze[e2] = t2;
          }, Qt.registerForPluginStateChange = e.registerForPluginStateChange;
          var ei = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0", ti = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ii = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", oi = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", ri = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
          let ni = {}, si = {};
          const ai = [];
          _i(ei, ai), _i(ii, ai), _i(oi, ai), _i(ri, ai), ni = di("", ii), si = di(ri, oi);
          const li = di("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), ci = ei, hi = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
          var ui = { background: di("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: di("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: di("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: di("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: di("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: di("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: di("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: di("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: di("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"), fill: di("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: di("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: di("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: di("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: di("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: di("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: di("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: di("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: di("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"), symbolSDF: di("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"), symbolTextAndIcon: di("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"), terrainRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"), terrainDepth: di("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: di("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti), skyboxGradient: di("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti), skyboxCapture: di("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"), globeAtmosphere: di("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}") };
          function _i(e2, t2) {
            const i2 = e2.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let e3 of i2)
              if (e3 = e3.trim(), "#" === e3[0] && e3.includes("if") && !e3.includes("endif")) {
                e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                const i3 = e3.split(" ");
                for (const e4 of i3)
                  t2.includes(e4) || t2.push(e4);
              }
          }
          function di(e2, t2) {
            const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = t2.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), r2 = {}, n2 = [...ai];
            return _i(e2, n2), _i(t2, n2), { fragmentSource: e2 = e2.replace(i2, (e3, t3, i3, o3, n3) => (r2[n3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${n3}
varying ${i3} ${o3} ${n3};
#else
uniform ${i3} ${o3} u_${n3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${n3}
    ${i3} ${o3} ${n3} = u_${n3};
#endif
`)), vertexSource: t2 = t2.replace(i2, (e3, t3, i3, o3, n3) => {
              const s2 = "float" === o3 ? "vec2" : "vec4", a2 = n3.match(/color/) ? "color" : s2;
              return r2[n3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${n3}
uniform lowp float u_${n3}_t;
attribute ${i3} ${s2} a_${n3};
varying ${i3} ${o3} ${n3};
#else
uniform ${i3} ${o3} u_${n3};
#endif
` : "vec4" === a2 ? `
#ifndef HAS_UNIFORM_u_${n3}
    ${n3} = a_${n3};
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n3}
    ${n3} = unpack_mix_${a2}(a_${n3}, u_${n3}_t);
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
` : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${n3}
uniform lowp float u_${n3}_t;
attribute ${i3} ${s2} a_${n3};
#else
uniform ${i3} ${o3} u_${n3};
#endif
` : "vec4" === a2 ? `
#ifndef HAS_UNIFORM_u_${n3}
    ${i3} ${o3} ${n3} = a_${n3};
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n3}
    ${i3} ${o3} ${n3} = unpack_mix_${a2}(a_${n3}, u_${n3}_t);
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
`;
            }), staticAttributes: o2, usedDefines: n2 };
          }
          class pi {
            constructor() {
              this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }
            bind(e2, t2, i2, o2, r2, n2, s2) {
              this.context = e2;
              let a2 = this.boundPaintVertexBuffers.length !== o2.length;
              for (let e3 = 0; !a2 && e3 < o2.length; e3++)
                this.boundPaintVertexBuffers[e3] !== o2[e3] && (a2 = true);
              let l2 = this.boundDynamicVertexBuffers.length !== s2.length;
              for (let e3 = 0; !l2 && e3 < s2.length; e3++)
                this.boundDynamicVertexBuffers[e3] !== s2[e3] && (l2 = true);
              if (!e2.extVertexArrayObject || !this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || a2 || l2 || this.boundIndexBuffer !== r2 || this.boundVertexOffset !== n2)
                this.freshBind(t2, i2, o2, r2, n2, s2);
              else {
                e2.bindVertexArrayOES.set(this.vao);
                for (const e3 of s2)
                  e3 && e3.bind();
                r2 && r2.dynamicDraw && r2.bind();
              }
            }
            freshBind(e2, t2, i2, o2, r2, n2) {
              let s2;
              const a2 = e2.numAttributes, l2 = this.context, c2 = l2.gl;
              if (l2.extVertexArrayObject)
                this.vao && this.destroy(), this.vao = l2.extVertexArrayObject.createVertexArrayOES(), l2.bindVertexArrayOES.set(this.vao), s2 = 0, this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffers = n2;
              else {
                s2 = l2.currentNumAttributes || 0;
                for (let e3 = a2; e3 < s2; e3++)
                  c2.disableVertexAttribArray(e3);
              }
              t2.enableAttributes(c2, e2), t2.bind(), t2.setVertexAttribPointers(c2, e2, r2);
              for (const t3 of i2)
                t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, r2);
              for (const t3 of n2)
                t3 && (t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, r2));
              o2 && o2.bind(), l2.currentNumAttributes = a2;
            }
            destroy() {
              this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
            }
          }
          function mi(t2, i2) {
            const o2 = Math.pow(2, i2.canonical.z), r2 = i2.canonical.y;
            return [new e.MercatorCoordinate(0, r2 / o2).toLngLat().lat, new e.MercatorCoordinate(0, (r2 + 1) / o2).toLngLat().lat];
          }
          function fi(t2, i2, o2, r2, n2, s2, a2) {
            const l2 = t2.context, c2 = l2.gl, h2 = o2.fbo;
            if (!h2)
              return;
            t2.prepareDrawTile();
            const u2 = t2.useProgram("hillshade");
            l2.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h2.colorAttachment.get());
            const _2 = ((e2, t3, i3, o3) => {
              const r3 = i3.paint.get("hillshade-shadow-color"), n3 = i3.paint.get("hillshade-highlight-color"), s3 = i3.paint.get("hillshade-accent-color");
              let a3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
              "viewport" === i3.paint.get("hillshade-illumination-anchor") && (a3 -= e2.transform.angle);
              const l3 = !e2.options.moving;
              return { u_matrix: o3 || e2.transform.calculateProjMatrix(t3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: mi(0, t3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), a3], u_shadow: r3, u_highlight: n3, u_accent: s3 };
            })(t2, o2, r2, t2.terrain ? i2.projMatrix : null);
            t2.prepareDrawProgram(l2, u2, i2.toUnwrapped());
            const { tileBoundsBuffer: d2, tileBoundsIndexBuffer: p2, tileBoundsSegments: m2 } = t2.getTileBoundsBuffers(o2);
            u2.draw(l2, c2.TRIANGLES, n2, s2, a2, e.CullFaceMode.disabled, _2, r2.id, d2, p2, m2);
          }
          function gi(t2, i2, o2) {
            if (!i2.needsDEMTextureUpload)
              return;
            const r2 = t2.context, n2 = r2.gl;
            r2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(o2.stride);
            const s2 = o2.getPixels();
            i2.demTexture ? i2.demTexture.update(s2, { premultiply: false }) : i2.demTexture = new e.Texture(r2, s2, n2.RGBA, { premultiply: false }), i2.needsDEMTextureUpload = false;
          }
          function vi(t2, i2, o2, r2, n2, s2) {
            const a2 = t2.context, l2 = a2.gl;
            if (!i2.dem)
              return;
            const c2 = i2.dem;
            if (a2.activeTexture.set(l2.TEXTURE1), gi(t2, i2, c2), !i2.demTexture)
              return;
            i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
            const h2 = c2.dim;
            a2.activeTexture.set(l2.TEXTURE0);
            let u2 = i2.fbo;
            if (!u2) {
              const t3 = new e.Texture(a2, { width: h2, height: h2, data: null }, l2.RGBA);
              t3.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), u2 = i2.fbo = a2.createFramebuffer(h2, h2, true), u2.colorAttachment.set(t3.texture);
            }
            a2.bindFramebuffer.set(u2.framebuffer), a2.viewport.set([0, 0, h2, h2]);
            const { tileBoundsBuffer: _2, tileBoundsIndexBuffer: d2, tileBoundsSegments: p2 } = t2.getMercatorTileBoundsBuffers();
            t2.useProgram("hillshadePrepare").draw(a2, l2.TRIANGLES, r2, n2, s2, e.CullFaceMode.disabled, ((t3, i3) => {
              const o3 = i3.stride, r3 = e.create();
              return e.ortho(r3, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r3, r3, [0, -e.EXTENT, 0]), { u_matrix: r3, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ, u_unpack: i3.unpackVector };
            })(i2.tileID, c2), o2.id, _2, d2, p2), i2.needsHillshadePrepare = false;
          }
          const xi = (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image0: new e.Uniform1i(t2), u_skirt_height: new e.Uniform1f(t2) }), yi = (e2, t2) => ({ u_matrix: e2, u_image0: 0, u_skirt_height: t2 }), bi = (e2, t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2) => ({ u_proj_matrix: Float32Array.from(e2), u_globe_matrix: t2, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i2, u_zoom_transition: r2, u_merc_center: n2, u_image0: 0, u_frustum_tl: s2, u_frustum_tr: a2, u_frustum_br: l2, u_frustum_bl: c2, u_globe_pos: h2, u_globe_radius: u2, u_viewport: _2, u_grid_matrix: p2 ? Float32Array.from(p2) : new Float32Array(9), u_skirt_height: d2 });
          function wi(e2, t2) {
            return null != e2 && null != t2 && !(!e2.hasData() || !t2.hasData()) && null != e2.demTexture && null != t2.demTexture && e2.tileID.key !== t2.tileID.key;
          }
          const Ti = new class {
            constructor() {
              this.operations = {};
            }
            newMorphing(e2, t2, i2, o2, r2) {
              if (e2 in this.operations) {
                const t3 = this.operations[e2];
                t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
              } else
                this.operations[e2] = { startTime: o2, phase: 0, duration: r2, from: t2, to: i2, queued: null };
            }
            getMorphValuesForProxy(e2) {
              if (!(e2 in this.operations))
                return null;
              const t2 = this.operations[e2];
              return { from: t2.from, to: t2.to, phase: t2.phase };
            }
            update(e2) {
              for (const t2 in this.operations) {
                const i2 = this.operations[t2];
                for (i2.phase = (e2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); )
                  if (!this._nextOp(i2, e2)) {
                    delete this.operations[t2];
                    break;
                  }
              }
            }
            _nextOp(e2, t2) {
              return !!e2.queued && (e2.from = e2.to, e2.to = e2.queued, e2.queued = null, e2.phase = 0, e2.startTime = t2, true);
            }
            _validOp(e2) {
              return e2.from.hasData() && e2.to.hasData();
            }
          }(), Ei = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
          function Ci(e2) {
            return 6 * Math.pow(1.5, 22 - e2);
          }
          function Mi(e2, t2) {
            const i2 = 1 << e2.z;
            return !t2 && (0 === e2.x || e2.x === i2 - 1) || 0 === e2.y || e2.y === i2 - 1;
          }
          const Ii = (e2) => ({ u_matrix: e2 });
          function Si(t2, i2, o2, r2, n2) {
            if (n2 > 0) {
              const s2 = e.exported.now(), a2 = (s2 - t2.timeAdded) / n2, l2 = i2 ? (s2 - i2.timeAdded) / n2 : -1, c2 = o2.getSource(), h2 = r2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(t2.tileID.overscaledZ - h2), _2 = u2 && t2.refreshedUponExpiration ? 1 : e.clamp(u2 ? a2 : 1 - l2, 0, 1);
              return t2.refreshedUponExpiration && a2 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          class Di extends e.SourceCache {
            constructor(e2) {
              const t2 = { type: "raster-dem", maxzoom: e2.transform.maxZoom }, i2 = new z(je(), null), o2 = Pe("mock-dem", t2, i2, e2.style);
              super("mock-dem", o2, false), o2.setEventedParent(this), this._sourceLoaded = true;
            }
            _loadTile(e2, t2) {
              e2.state = "loaded", t2(null);
            }
          }
          class Li extends e.SourceCache {
            constructor(e2) {
              const t2 = Pe("proxy", { type: "geojson", maxzoom: e2.transform.maxZoom }, new z(je(), null), e2.style);
              super("proxy", t2, false), t2.setEventedParent(this), this.map = this.getSource().map = e2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
            update(t2, i2, o2) {
              if (t2.freezeTileCoverage)
                return;
              this.transform = t2;
              const r2 = t2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i3, o3) => {
                if (i3[o3.key] = "", !this._tiles[o3.key]) {
                  const i4 = new e.Tile(o3, this._source.tileSize * o3.overscaleFactor(), t2.tileZoom);
                  i4.state = "loaded", this._tiles[o3.key] = i4;
                }
                return i3;
              }, {});
              for (const e2 in this._tiles)
                e2 in r2 || (this.freeFBO(e2), this._tiles[e2].unloadVectorData(), delete this._tiles[e2]);
            }
            freeFBO(e2) {
              const t2 = this.proxyCachedFBO[e2];
              if (void 0 !== t2) {
                const i2 = Object.values(t2);
                this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e2];
              }
            }
            deallocRenderCache() {
              this.renderCache.forEach((e2) => e2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
          }
          class Ai extends e.OverscaledTileID {
            constructor(e2, t2, i2) {
              super(e2.overscaledZ, e2.wrap, e2.canonical.z, e2.canonical.x, e2.canonical.y), this.proxyTileKey = t2, this.projMatrix = i2;
            }
          }
          class zi extends e.Elevation {
            constructor(t2, i2) {
              super(), this.painter = t2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
              const [o2, r2, n2] = function(t3) {
                const i3 = new e.StructArrayLayout2i4(), o3 = new e.StructArrayLayout3ui6(), r3 = 131;
                i3.reserve(17161), o3.reserve(33800);
                const n3 = e.EXTENT / 128, s3 = e.EXTENT + n3 / 2, a3 = s3 + n3;
                for (let t4 = -n3; t4 < a3; t4 += n3)
                  for (let o4 = -n3; o4 < a3; o4 += n3) {
                    const r4 = o4 < 0 || o4 > s3 || t4 < 0 || t4 > s3 ? 24575 : 0, n4 = e.clamp(Math.round(o4), 0, e.EXTENT), a4 = e.clamp(Math.round(t4), 0, e.EXTENT);
                    i3.emplaceBack(n4 + r4, a4);
                  }
                const l2 = (e2, t4) => {
                  const i4 = t4 * r3 + e2;
                  o3.emplaceBack(i4 + 1, i4, i4 + r3), o3.emplaceBack(i4 + r3, i4 + r3 + 1, i4 + 1);
                };
                for (let e2 = 1; e2 < 129; e2++)
                  for (let t4 = 1; t4 < 129; t4++)
                    l2(t4, e2);
                return [0, 129].forEach((e2) => {
                  for (let t4 = 0; t4 < 130; t4++)
                    l2(t4, e2), l2(e2, t4);
                }), [i3, o3, 32768];
              }(), s2 = t2.context;
              this.gridBuffer = s2.createVertexBuffer(o2, e.posAttributes.members), this.gridIndexBuffer = s2.createIndexBuffer(r2), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, r2.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, n2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Li(i2.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e.EXTENT, 0, e.EXTENT, 0, 1);
              const a2 = s2.gl;
              this._overlapStencilMode = new e.StencilMode({ func: a2.GEQUAL, mask: 255 }, 0, 255, a2.KEEP, a2.KEEP, a2.REPLACE), this._previousZoom = t2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new Di(i2.map);
            }
            set style(e2) {
              e2.on("data", this._onStyleDataEvent.bind(this)), e2.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e2, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", () => {
                this._clearLineLayersFromRenderCache();
              });
            }
            update(t2, i2, o2) {
              if (t2 && t2.terrain) {
                this._style !== t2 && (this.style = t2), this.enabled = true;
                const r2 = t2.terrain.properties;
                this.sourceCache = 0 === t2.terrain.drapeRenderMode ? this._mockSourceCache : t2._getSourceCache(r2.get("source")), this._exaggeration = r2.get("exaggeration");
                const n2 = () => {
                  this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                  const t3 = this.getScaledDemTileSize();
                  this.sourceCache.update(i2, t3, true), this.resetTileLookupCache(this.sourceCache.id);
                };
                this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, n2(), this._initializing = true), n2(), i2.updateElevation(true, o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true;
              } else
                this._disable();
            }
            resetTileLookupCache(e2) {
              this._findCoveringTileCache[e2] = {};
            }
            getScaledDemTileSize() {
              return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }
            _checkRenderCacheEfficiency() {
              const t2 = this.renderCacheEfficiency(this._style);
              this._style.map._optimizeForTerrain || 100 !== t2.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t2.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${t2.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
            }
            _onStyleDataEvent(e2) {
              e2.coord && "source" === e2.dataType ? this._clearRenderCacheForTile(e2.sourceCacheId, e2.coord) : "style" === e2.dataType && (this._invalidateRenderCache = true);
            }
            _disable() {
              if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
                for (const e2 in this._style._sourceCaches)
                  this._style._sourceCaches[e2].usedForTerrain = false;
            }
            destroy() {
              this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e2) => e2.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
            }
            _source() {
              return this.enabled ? this.sourceCache : null;
            }
            isUsingMockSource() {
              return this.sourceCache === this._mockSourceCache;
            }
            exaggeration() {
              return this._exaggeration;
            }
            get visibleDemTiles() {
              return this._visibleDemTiles;
            }
            get drapeBufferSize() {
              const e2 = 2 * this.proxySourceCache.getSource().tileSize;
              return [e2, e2];
            }
            set useVertexMorphing(e2) {
              this._useVertexMorphing = e2;
            }
            updateTileBinding(t2) {
              if (!this.enabled)
                return;
              this.prevTerrainTileForTile = this.terrainTileForTile;
              const i2 = this.proxySourceCache, o2 = this.painter.transform;
              this._initializing && (this._initializing = 0 === o2._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
              const r2 = this.proxyCoords = i2.getIds().map((e2) => {
                const t3 = i2.getTileByID(e2).tileID;
                return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
              });
              !function(t3, i3) {
                const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), r3 = new e.pointGeometry(o3.x, o3.y);
                t3.sort((t4, i4) => {
                  if (i4.overscaledZ - t4.overscaledZ)
                    return i4.overscaledZ - t4.overscaledZ;
                  const o4 = new e.pointGeometry(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), n3 = new e.pointGeometry(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), s3 = r3.mult(1 << t4.canonical.z);
                  return s3.x -= 0.5, s3.y -= 0.5, s3.distSqr(o4) - s3.distSqr(n3);
                });
              }(r2, this.painter), this._previousZoom = o2.zoom;
              const n2 = this.proxyToSource || {};
              this.proxyToSource = {}, r2.forEach((e2) => {
                this.proxyToSource[e2.key] = {};
              }), this.terrainTileForTile = {};
              const s2 = this._style._sourceCaches;
              for (const e2 in s2) {
                const i3 = s2[e2];
                if (!i3.used)
                  continue;
                if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t2[e2], n2), i3.usedForTerrain)
                  continue;
                const o3 = t2[e2];
                i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
              }
              this.proxiedCoords[i2.id] = r2.map((e2) => new Ai(e2, e2.key, this.orthoMatrix)), this._assignTerrainTiles(r2), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n2), this.renderingToTexture = false, this._updateTimestamp = e.exported.now();
              const a2 = {};
              this._visibleDemTiles = [];
              for (const e2 of this.proxyCoords) {
                const t3 = this.terrainTileForTile[e2.key];
                if (!t3)
                  continue;
                const i3 = t3.tileID.key;
                i3 in a2 || (this._visibleDemTiles.push(t3), a2[i3] = i3);
              }
            }
            _assignTerrainTiles(e2) {
              this._initializing || e2.forEach((e3) => {
                if (this.terrainTileForTile[e3.key])
                  return;
                const t2 = this._findTileCoveringTileID(e3, this.sourceCache);
                t2 && (this.terrainTileForTile[e3.key] = t2);
              });
            }
            _prepareDEMTextures() {
              const e2 = this.painter.context, t2 = e2.gl;
              for (const i2 in this.terrainTileForTile) {
                const o2 = this.terrainTileForTile[i2], r2 = o2.dem;
                !r2 || o2.demTexture && !o2.needsDEMTextureUpload || (e2.activeTexture.set(t2.TEXTURE1), gi(this.painter, o2, r2));
              }
            }
            _prepareDemTileUniforms(e2, t2, i2, o2) {
              if (!t2 || null == t2.demTexture)
                return false;
              const r2 = e2.tileID.canonical, n2 = Math.pow(2, t2.tileID.canonical.z - r2.z), s2 = o2 || "";
              return i2[`u_dem_tl${s2}`] = [r2.x * n2 % 1, r2.y * n2 % 1], i2[`u_dem_scale${s2}`] = n2, true;
            }
            get emptyDEMTexture() {
              return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            get emptyDepthBufferTexture() {
              const t2 = this.painter.context, i2 = t2.gl;
              if (!this._emptyDepthBufferTexture) {
                const o2 = new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
                this._emptyDepthBufferTexture = new e.Texture(t2, o2, i2.RGBA, { premultiply: false });
              }
              return this._emptyDepthBufferTexture;
            }
            _getLoadedAreaMinimum() {
              let e2 = 0;
              const t2 = this._visibleDemTiles.reduce((t3, i2) => {
                if (!i2.dem)
                  return t3;
                const o2 = i2.dem.tree.minimums[0];
                return o2 > 0 && e2++, t3 + o2;
              }, 0);
              return e2 ? t2 / e2 : 0;
            }
            _updateEmptyDEMTexture() {
              const t2 = this.painter.context, i2 = t2.gl;
              t2.activeTexture.set(i2.TEXTURE2);
              const o2 = this._getLoadedAreaMinimum(), r2 = new e.RGBAImage({ width: 1, height: 1 }, new Uint8Array(e.DEMData.pack(o2, this.sourceCache.getSource().encoding)));
              this._emptyDEMTextureDirty = false;
              let n2 = this._emptyDEMTexture;
              return n2 ? n2.update(r2, { premultiply: false }) : n2 = this._emptyDEMTexture = new e.Texture(t2, r2, i2.RGBA, { premultiply: false }), n2;
            }
            setupElevationDraw(t2, i2, o2) {
              const r2 = this.painter.context, n2 = r2.gl, s2 = (a2 = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: e.DEMData.getUnpackVector(a2), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 });
              var a2;
              s2.u_dem_size = this.sourceCache.getSource().tileSize, s2.u_exaggeration = this.exaggeration();
              let l2 = null, c2 = null, h2 = 1;
              if (o2 && o2.morphing && this._useVertexMorphing) {
                const e2 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
                h2 = o2.morphing.phase, e2 && i3 && (this._prepareDemTileUniforms(t2, e2, s2, "_prev") && (c2 = e2), this._prepareDemTileUniforms(t2, i3, s2) && (l2 = i3));
              }
              if (c2 && l2 ? (r2.activeTexture.set(n2.TEXTURE2), l2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), r2.activeTexture.set(n2.TEXTURE4), c2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), s2.u_dem_lerp = h2) : (l2 = this.terrainTileForTile[t2.tileID.key], r2.activeTexture.set(n2.TEXTURE2), (this._prepareDemTileUniforms(t2, l2, s2) ? l2.demTexture : this.emptyDEMTexture).bind(n2.NEAREST, n2.CLAMP_TO_EDGE)), r2.activeTexture.set(n2.TEXTURE3), o2 && o2.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE), this._depthFBO && (s2.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE), s2.u_depth_size_inv = [1, 1]), o2 && o2.useMeterToDem && l2) {
                const t3 = (1 << l2.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                s2.u_meter_to_dem = t3;
              }
              if (o2 && o2.labelPlaneMatrixInv && (s2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(r2, s2), "globe" === this.painter.transform.projection.name) {
                const e2 = this.globeUniformValues(this.painter.transform, t2.tileID.canonical, o2 && o2.useDenormalizedUpVectorScale);
                i2.setGlobeUniformValues(r2, e2);
              }
            }
            globeUniformValues(t2, i2, o2) {
              const r2 = t2.projection;
              return { u_tile_tl_up: r2.upVector(i2, 0, 0), u_tile_tr_up: r2.upVector(i2, e.EXTENT, 0), u_tile_br_up: r2.upVector(i2, e.EXTENT, e.EXTENT), u_tile_bl_up: r2.upVector(i2, 0, e.EXTENT), u_tile_up_scale: o2 ? e.globeMetersToEcef(1) : r2.upVectorScale(i2, t2.center.lat, t2.worldSize).metersToTile };
            }
            renderToBackBuffer(t2) {
              const i2 = this.painter, o2 = this.painter.context;
              0 !== t2.length && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), i2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t3, i3, o3, r2, n2) {
                if ("globe" === t3.transform.projection.name)
                  !function(t4, i4, o4, r3, n3) {
                    const s2 = t4.context, a2 = s2.gl;
                    let l2, c2;
                    const h2 = t4.options.showTerrainWireframe ? 2 : 0, u2 = t4.transform, _2 = e.globeUseCustomAntiAliasing(t4, s2, u2), d2 = (e2, i5) => {
                      if (c2 === e2)
                        return;
                      const o5 = [Ei[e2], "PROJECTION_GLOBE_VIEW"];
                      _2 && o5.push("CUSTOM_ANTIALIASING"), i5 && o5.push(Ei[h2]), l2 = t4.useProgram("globeRaster", null, o5), c2 = e2;
                    }, p2 = t4.colorModeForRenderPass(), m2 = new e.DepthMode(a2.LEQUAL, e.DepthMode.ReadWrite, t4.depthRangeFor3D);
                    Ti.update(n3);
                    const f2 = e.calculateGlobeMercatorMatrix(u2), g2 = [e.mercatorXfromLng(u2.center.lng), e.mercatorYfromLat(u2.center.lat)], v2 = h2 ? [false, true] : [false], x2 = t4.globeSharedBuffers, y2 = [u2.width * e.exported.devicePixelRatio, u2.height * e.exported.devicePixelRatio], b2 = Float32Array.from(u2.globeMatrix), w2 = { useDenormalizedUpVectorScale: true };
                    if (v2.forEach((h3) => {
                      const u3 = t4.transform, _3 = Ci(u3.zoom) * i4.exaggeration();
                      c2 = -1;
                      const v3 = h3 ? a2.LINES : a2.TRIANGLES;
                      for (const c3 of r3) {
                        const r4 = o4.getTile(c3), T2 = e.StencilMode.disabled, E2 = i4.prevTerrainTileForTile[c3.key], C2 = i4.terrainTileForTile[c3.key];
                        wi(E2, C2) && Ti.newMorphing(c3.key, E2, C2, n3, 250), s2.activeTexture.set(a2.TEXTURE0), r4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                        const M2 = Ti.getMorphValuesForProxy(c3.key), I2 = M2 ? 1 : 0;
                        M2 && e.extend$1(w2, { morphing: { srcDemTile: M2.from, dstDemTile: M2.to, phase: e.easeCubicInOut(M2.phase) } });
                        const S2 = e.tileCornersToBounds(c3.canonical), D2 = e.getLatitudinalLod(S2.getCenter().lat), L2 = e.getGridMatrix(c3.canonical, S2, D2, u3.worldSize / u3._pixelsPerMercatorPixel), A2 = e.globeNormalizeECEF(e.globeTileBounds(c3.canonical)), z2 = bi(u3.projMatrix, b2, f2, A2, e.globeToMercatorTransition(u3.zoom), g2, u3.frustumCorners.TL, u3.frustumCorners.TR, u3.frustumCorners.BR, u3.frustumCorners.BL, u3.globeCenterInViewSpace, u3.globeRadius, y2, _3, L2);
                        if (d2(I2, h3), i4.setupElevationDraw(r4, l2, w2), t4.prepareDrawProgram(s2, l2, c3.toUnwrapped()), x2) {
                          const [i5, o5, r5] = h3 ? x2.getWirefameBuffers(t4.context, D2) : x2.getGridBuffers(D2, 0 !== _3);
                          l2.draw(s2, v3, m2, T2, p2, e.CullFaceMode.backCCW, z2, "globe_raster", i5, o5, r5);
                        }
                      }
                    }), x2) {
                      const n4 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                      _2 && n4.push("CUSTOM_ANTIALIASING"), l2 = t4.useProgram("globeRaster", null, n4);
                      for (const n5 of r3) {
                        const { x: r4, y: c3, z: h3 } = n5.canonical, _3 = 0 === c3, d3 = c3 === (1 << h3) - 1, [f3, v3, b3, T2] = x2.getPoleBuffers(h3);
                        if (T2 && (_3 || d3)) {
                          const c4 = o4.getTile(n5);
                          s2.activeTexture.set(a2.TEXTURE0), c4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                          let x3 = e.globePoleMatrixForTile(h3, r4, u2);
                          const E2 = e.globeNormalizeECEF(e.globeTileBounds(n5.canonical)), C2 = (t5, i5) => t5.draw(s2, a2.TRIANGLES, m2, e.StencilMode.disabled, p2, e.CullFaceMode.disabled, bi(u2.projMatrix, x3, x3, E2, 0, g2, u2.frustumCorners.TL, u2.frustumCorners.TR, u2.frustumCorners.BR, u2.frustumCorners.BL, u2.globeCenterInViewSpace, u2.globeRadius, y2, 0), "globe_pole_raster", i5, b3, T2);
                          i4.setupElevationDraw(c4, l2, w2), t4.prepareDrawProgram(s2, l2, n5.toUnwrapped()), _3 && C2(l2, f3), d3 && (x3 = e.scale(e.create(), x3, [1, -1, 1]), C2(l2, v3));
                        }
                      }
                    }
                  }(t3, i3, o3, r2, n2);
                else {
                  const s2 = t3.context, a2 = s2.gl;
                  let l2, c2;
                  const h2 = t3.options.showTerrainWireframe ? 2 : 0, u2 = (e2, i4) => {
                    if (c2 === e2)
                      return;
                    const o4 = [Ei[e2]];
                    i4 && o4.push(Ei[h2]), l2 = t3.useProgram("terrainRaster", null, o4), c2 = e2;
                  }, _2 = t3.colorModeForRenderPass(), d2 = new e.DepthMode(a2.LEQUAL, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
                  Ti.update(n2);
                  const p2 = t3.transform, m2 = Ci(p2.zoom) * i3.exaggeration();
                  (h2 ? [false, true] : [false]).forEach((h3) => {
                    c2 = -1;
                    const f2 = h3 ? a2.LINES : a2.TRIANGLES, [g2, v2] = h3 ? i3.getWirefameBuffer() : [i3.gridIndexBuffer, i3.gridSegments];
                    for (const c3 of r2) {
                      const r3 = o3.getTile(c3), x2 = e.StencilMode.disabled, y2 = i3.prevTerrainTileForTile[c3.key], b2 = i3.terrainTileForTile[c3.key];
                      wi(y2, b2) && Ti.newMorphing(c3.key, y2, b2, n2, 250), s2.activeTexture.set(a2.TEXTURE0), r3.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST);
                      const w2 = Ti.getMorphValuesForProxy(c3.key), T2 = w2 ? 1 : 0;
                      let E2;
                      w2 && (E2 = { morphing: { srcDemTile: w2.from, dstDemTile: w2.to, phase: e.easeCubicInOut(w2.phase) } });
                      const C2 = yi(c3.projMatrix, Mi(c3.canonical, p2.renderWorldCopies) ? m2 / 10 : m2);
                      u2(T2, h3), i3.setupElevationDraw(r3, l2, E2), t3.prepareDrawProgram(s2, l2, c3.toUnwrapped()), l2.draw(s2, f2, d2, x2, _2, e.CullFaceMode.backCCW, C2, "terrain_raster", i3.gridBuffer, g2, v2);
                    }
                  });
                }
              }(i2, this, this.proxySourceCache, t2, this._updateTimestamp), this.renderingToTexture = true, i2.gpuTimingDeferredRenderEnd(), t2.splice(0, t2.length));
            }
            renderBatch(t2) {
              if (0 === this._drapedRenderBatches.length)
                return t2 + 1;
              this.renderingToTexture = true;
              const i2 = this.painter, o2 = this.painter.context, r2 = this.proxySourceCache, n2 = this.proxiedCoords[r2.id], s2 = this._drapedRenderBatches.shift(), a2 = [], l2 = i2.style.order;
              let c2 = 0;
              for (const h2 of n2) {
                const n3 = r2.getTileByID(h2.proxyTileKey), u2 = r2.proxyCachedFBO[h2.key] ? r2.proxyCachedFBO[h2.key][t2] : void 0, _2 = void 0 !== u2 ? r2.renderCache[u2] : this.pool[c2++], d2 = void 0 !== u2;
                if (n3.texture = _2.tex, d2 && !_2.dirty) {
                  a2.push(n3.tileID);
                  continue;
                }
                let p2;
                o2.bindFramebuffer.set(_2.fb.framebuffer), this.renderedToTile = false, _2.dirty && (o2.clear({ color: e.Color.transparent, stencil: 0 }), _2.dirty = false);
                for (let e2 = s2.start; e2 <= s2.end; ++e2) {
                  const t3 = i2.style._layers[l2[e2]];
                  if (t3.isHidden(i2.transform.zoom))
                    continue;
                  const r3 = i2.style._getLayerSourceCache(t3), n4 = r3 ? this.proxyToSource[h2.key][r3.id] : [h2];
                  if (!n4)
                    continue;
                  const s3 = n4;
                  o2.viewport.set([0, 0, _2.fb.width, _2.fb.height]), p2 !== (r3 ? r3.id : null) && (this._setupStencil(_2, n4, t3, r3), p2 = r3 ? r3.id : null), i2.renderLayer(i2, r3, t3, s3);
                }
                this.renderedToTile ? (_2.dirty = true, a2.push(n3.tileID)) : d2 || --c2, 5 === c2 && (c2 = 0, this.renderToBackBuffer(a2));
              }
              return this.renderToBackBuffer(a2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), s2.end + 1;
            }
            postRender() {
            }
            renderCacheEfficiency(e2) {
              const t2 = e2.order.length;
              if (0 === t2)
                return { efficiency: 100 };
              let i2, o2 = 0, r2 = 0, n2 = false;
              for (let s2 = 0; s2 < t2; ++s2) {
                const t3 = e2._layers[e2.order[s2]];
                this._style.isLayerDraped(t3) ? (n2 && ++o2, ++r2) : n2 || (n2 = true, i2 = t3.id);
              }
              return 0 === r2 ? { efficiency: 100 } : { efficiency: 100 * (1 - o2 / r2), firstUndrapedLayer: i2 };
            }
            getMinElevationBelowMSL() {
              let e2 = 0;
              return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t2) => {
                e2 = Math.min(e2, t2.dem.tree.minimums[0]);
              }), 0 === e2 ? e2 : (e2 - 30) * this._exaggeration;
            }
            raycast(e2, t2, i2) {
              if (!this._visibleDemTiles)
                return null;
              const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
                const r2 = o3.tileID, n2 = 1 << r2.overscaledZ, { x: s2, y: a2 } = r2.canonical, l2 = s2 / n2, c2 = (s2 + 1) / n2, h2 = a2 / n2, u2 = (a2 + 1) / n2;
                return { minx: l2, miny: h2, maxx: c2, maxy: u2, t: o3.dem.tree.raycastRoot(l2, h2, c2, u2, e2, t2, i2), tile: o3 };
              });
              o2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
              for (const r2 of o2) {
                if (null == r2.t)
                  return null;
                const o3 = r2.tile.dem.tree.raycast(r2.minx, r2.miny, r2.maxx, r2.maxy, e2, t2, i2);
                if (null != o3)
                  return o3;
              }
              return null;
            }
            _createFBO() {
              const t2 = this.painter.context, i2 = t2.gl, o2 = this.drapeBufferSize;
              t2.activeTexture.set(i2.TEXTURE0);
              const r2 = new e.Texture(t2, { width: o2[0], height: o2[1], data: null }, i2.RGBA);
              r2.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
              const n2 = t2.createFramebuffer(o2[0], o2[1], false);
              return n2.colorAttachment.set(r2.texture), n2.depthAttachment = new Ee(t2, n2.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t2.createRenderbuffer(t2.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, n2.depthAttachment.set(this._sharedDepthStencil), t2.clear({ stencil: 0 })) : n2.depthAttachment.set(this._sharedDepthStencil), t2.extTextureFilterAnisotropic && !t2.extTextureFilterAnisotropicForceOff && i2.texParameterf(i2.TEXTURE_2D, t2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t2.extTextureFilterAnisotropicMax), { fb: n2, tex: r2, dirty: false };
            }
            _initFBOPool() {
              for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
                this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
              if (this._style.light && this._style.light.hasTransition())
                return true;
              for (const e2 in this._style._sourceCaches)
                if (this._style._sourceCaches[e2].hasTransition())
                  return true;
              return this._style.order.some((e2) => {
                const t2 = this._style._layers[e2], i2 = t2.isHidden(this.painter.transform.zoom);
                return "custom" === t2.type ? !i2 && t2.shouldRedrape() : !i2 && t2.hasTransition();
              });
            }
            _clearLineLayersFromRenderCache() {
              let t2 = false;
              for (const e2 of this._style._getSources())
                if (e2 instanceof Ie) {
                  t2 = true;
                  break;
                }
              if (!t2)
                return;
              const i2 = {};
              for (let t3 = 0; t3 < this._style.order.length; ++t3) {
                const o2 = this._style._layers[this._style.order[t3]], r2 = this._style._getLayerSourceCache(o2);
                if (r2 && !i2[r2.id] && !o2.isHidden(this.painter.transform.zoom) && "line" === o2.type && o2.widthExpression() instanceof e.ZoomDependentExpression) {
                  i2[r2.id] = true;
                  for (const e2 of this.proxyCoords) {
                    const t4 = this.proxyToSource[e2.key][r2.id];
                    if (t4)
                      for (const e3 of t4)
                        this._clearRenderCacheForTile(r2.id, e3);
                  }
                }
              }
            }
            _clearRasterLayersFromRenderCache() {
              let e2 = false;
              for (const t3 in this._style._sourceCaches)
                if (this._style._sourceCaches[t3]._source instanceof Se) {
                  e2 = true;
                  break;
                }
              if (!e2)
                return;
              const t2 = {};
              for (let e3 = 0; e3 < this._style.order.length; ++e3) {
                const i2 = this._style._layers[this._style.order[e3]], o2 = this._style._getLayerSourceCache(i2);
                if (!o2 || t2[o2.id])
                  continue;
                if (i2.isHidden(this.painter.transform.zoom) || "raster" !== i2.type)
                  continue;
                const r2 = i2.paint.get("raster-fade-duration");
                for (const e4 of this.proxyCoords) {
                  const t3 = this.proxyToSource[e4.key][o2.id];
                  if (t3)
                    for (const e5 of t3) {
                      const t4 = Si(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, r2);
                      (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(o2.id, e5);
                    }
                }
              }
            }
            _setupDrapedRenderBatches() {
              const e2 = this._style.order, t2 = e2.length;
              if (0 === t2)
                return;
              const i2 = [];
              let o2, r2 = 0, n2 = this._style._layers[e2[r2]];
              for (; !this._style.isLayerDraped(n2) && n2.isHidden(this.painter.transform.zoom) && ++r2 < t2; )
                n2 = this._style._layers[e2[r2]];
              for (; r2 < t2; ++r2) {
                const t3 = this._style._layers[e2[r2]];
                t3.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t3) ? void 0 === o2 && (o2 = r2) : void 0 !== o2 && (i2.push({ start: o2, end: r2 - 1 }), o2 = void 0));
              }
              void 0 !== o2 && i2.push({ start: o2, end: r2 - 1 }), this._drapedRenderBatches = i2;
            }
            _setupRenderCache(e2) {
              const t2 = this.proxySourceCache;
              if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                if (this._invalidateRenderCache = false, t2.renderCache.length > t2.renderCachePool.length) {
                  const e3 = Object.values(t2.proxyCachedFBO);
                  t2.proxyCachedFBO = {};
                  for (let i3 = 0; i3 < e3.length; ++i3) {
                    const o3 = Object.values(e3[i3]);
                    t2.renderCachePool.push(...o3);
                  }
                }
                return;
              }
              this._clearRasterLayersFromRenderCache();
              const i2 = this.proxyCoords, o2 = this._tilesDirty;
              for (let r3 = i2.length - 1; r3 >= 0; r3--) {
                const n2 = i2[r3];
                if (t2.getTileByID(n2.key), void 0 !== t2.proxyCachedFBO[n2.key]) {
                  const i3 = e2[n2.key], r4 = this.proxyToSource[n2.key];
                  let s2 = 0;
                  for (const e3 in r4) {
                    const t3 = r4[e3], n3 = i3[e3];
                    if (!n3 || n3.length !== t3.length || t3.some((t4, i4) => t4 !== n3[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                      s2 = -1;
                      break;
                    }
                    ++s2;
                  }
                  for (const e3 in t2.proxyCachedFBO[n2.key])
                    t2.renderCache[t2.proxyCachedFBO[n2.key][e3]].dirty = s2 < 0 || s2 !== Object.values(i3).length;
                }
              }
              const r2 = [...this._drapedRenderBatches];
              r2.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
              for (const e3 of r2)
                for (const o3 of i2) {
                  if (t2.proxyCachedFBO[o3.key])
                    continue;
                  let i3 = t2.renderCachePool.pop();
                  void 0 === i3 && t2.renderCache.length < 50 && (i3 = t2.renderCache.length, t2.renderCache.push(this._createFBO())), void 0 !== i3 && (t2.proxyCachedFBO[o3.key] = {}, t2.proxyCachedFBO[o3.key][e3.start] = i3, t2.renderCache[i3].dirty = true);
                }
              this._tilesDirty = {};
            }
            _setupStencil(e2, t2, i2, o2) {
              if (!o2 || !this._sourceTilesOverlap[o2.id])
                return void (this._overlapStencilType && (this._overlapStencilType = false));
              const r2 = this.painter.context, n2 = r2.gl;
              if (t2.length <= 1)
                return void (this._overlapStencilType = false);
              let s2;
              if (i2.isTileClipped())
                s2 = t2.length, this._overlapStencilMode.test = { func: n2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
              else {
                if (!(t2[0].overscaledZ > t2[t2.length - 1].overscaledZ))
                  return void (this._overlapStencilType = false);
                s2 = 1, this._overlapStencilMode.test = { func: n2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
              }
              this._stencilRef + s2 > 255 && (r2.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += s2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t2, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
              return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }
            stencilModeForRTTOverlap(t2) {
              return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t2.key]), this._overlapStencilMode) : e.StencilMode.disabled;
            }
            _renderTileClippingMasks(t2, i2) {
              const o2 = this.painter, r2 = this.painter.context, n2 = r2.gl;
              o2._tileClippingMaskIDs = {}, r2.setColorMode(e.ColorMode.disabled), r2.setDepthMode(e.DepthMode.disabled);
              const s2 = o2.useProgram("clippingMask");
              for (const a2 of t2) {
                const t3 = o2._tileClippingMaskIDs[a2.key] = --i2;
                s2.draw(r2, n2.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n2.ALWAYS, mask: 0 }, t3, 255, n2.KEEP, n2.KEEP, n2.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(a2.projMatrix), "$clipping", o2.tileExtentBuffer, o2.quadTriangleIndexBuffer, o2.tileExtentSegments);
              }
            }
            pointCoordinate(t2) {
              const i2 = this.painter.transform;
              if (t2.x < 0 || t2.x > i2.width || t2.y < 0 || t2.y > i2.height)
                return null;
              const o2 = [t2.x, t2.y, 1, 1];
              e.transformMat4$1(o2, o2, i2.pixelMatrixInverse), e.scale$1(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
              const r2 = i2._camera.position, n2 = e.mercatorZfromAltitude(1, i2.center.lat), s2 = [r2[0], r2[1], r2[2] / n2, 0], a2 = e.subtract([], o2.slice(0, 3), s2);
              e.normalize(a2, a2);
              const l2 = this.raycast(s2, a2, this._exaggeration);
              return null !== l2 && l2 ? (e.scaleAndAdd(s2, s2, a2, l2), s2[3] = s2[2], s2[2] *= n2, s2) : null;
            }
            drawDepth() {
              const t2 = this.painter, i2 = t2.context, o2 = this.proxySourceCache, r2 = Math.ceil(t2.width), n2 = Math.ceil(t2.height);
              if (!this._depthFBO || this._depthFBO.width === r2 && this._depthFBO.height === n2 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
                const t3 = i2.gl, o3 = i2.createFramebuffer(r2, n2, true);
                i2.activeTexture.set(t3.TEXTURE0);
                const s2 = new e.Texture(i2, { width: r2, height: n2, data: null }, t3.RGBA);
                s2.bind(t3.NEAREST, t3.CLAMP_TO_EDGE), o3.colorAttachment.set(s2.texture);
                const a2 = i2.createRenderbuffer(i2.gl.DEPTH_COMPONENT16, r2, n2);
                o3.depthAttachment.set(a2), this._depthFBO = o3, this._depthTexture = s2;
              }
              i2.bindFramebuffer.set(this._depthFBO.framebuffer), i2.viewport.set([0, 0, r2, n2]), function(t3, i3, o3, r3) {
                if ("globe" === t3.transform.projection.name)
                  return;
                const n3 = t3.context, s2 = n3.gl;
                n3.clear({ depth: 1 });
                const a2 = t3.useProgram("terrainDepth"), l2 = new e.DepthMode(s2.LESS, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
                for (const t4 of r3) {
                  const r4 = o3.getTile(t4), c2 = yi(t4.projMatrix, 0);
                  i3.setupElevationDraw(r4, a2), a2.draw(n3, s2.TRIANGLES, l2, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c2, "terrain_depth", i3.gridBuffer, i3.gridIndexBuffer, i3.gridNoSkirtSegments);
                }
              }(t2, this, o2, this.proxyCoords);
            }
            _setupProxiedCoordsForOrtho(e2, t2, i2) {
              if (e2.getSource() instanceof Ae)
                return this._setupProxiedCoordsForImageSource(e2, t2, i2);
              this._findCoveringTileCache[e2.id] = this._findCoveringTileCache[e2.id] || {};
              const o2 = this.proxiedCoords[e2.id] = [], r2 = this.proxyCoords;
              for (let t3 = 0; t3 < r2.length; t3++) {
                const n3 = r2[t3], s2 = this._findTileCoveringTileID(n3, e2);
                if (s2) {
                  const t4 = this._createProxiedId(n3, s2, i2[n3.key] && i2[n3.key][e2.id]);
                  o2.push(t4), this.proxyToSource[n3.key][e2.id] = [t4];
                }
              }
              let n2 = false;
              for (let r3 = 0; r3 < t2.length; r3++) {
                const s2 = e2.getTile(t2[r3]);
                if (!s2 || !s2.hasData())
                  continue;
                const a2 = this._findTileCoveringTileID(s2.tileID, this.proxySourceCache);
                if (a2 && a2.tileID.canonical.z !== s2.tileID.canonical.z) {
                  const t3 = this.proxyToSource[a2.tileID.key][e2.id], r4 = this._createProxiedId(a2.tileID, s2, i2[a2.tileID.key] && i2[a2.tileID.key][e2.id]);
                  t3 ? t3.splice(t3.length - 1, 0, r4) : this.proxyToSource[a2.tileID.key][e2.id] = [r4], o2.push(r4), n2 = true;
                }
              }
              this._sourceTilesOverlap[e2.id] = n2;
            }
            _setupProxiedCoordsForImageSource(t2, i2, o2) {
              if (!t2.getSource().loaded())
                return;
              const r2 = this.proxiedCoords[t2.id] = [], n2 = this.proxyCoords, s2 = t2.getSource(), a2 = new e.pointGeometry(s2.tileID.x, s2.tileID.y)._div(1 << s2.tileID.z), l2 = s2.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e2, t3) => (e2.min.x = Math.min(e2.min.x, t3.x - a2.x), e2.min.y = Math.min(e2.min.y, t3.y - a2.y), e2.max.x = Math.max(e2.max.x, t3.x - a2.x), e2.max.y = Math.max(e2.max.y, t3.y - a2.y), e2), { min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE) }), c2 = (t3, i3) => {
                const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), r3 = t3.canonical.y / (1 << t3.canonical.z), n3 = e.EXTENT / (1 << t3.canonical.z), s3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), a3 = i3.canonical.y / (1 << i3.canonical.z);
                return o3 + n3 < s3 + l2.min.x || o3 > s3 + l2.max.x || r3 + n3 < a3 + l2.min.y || r3 > a3 + l2.max.y;
              };
              for (let e2 = 0; e2 < n2.length; e2++) {
                const s3 = n2[e2];
                for (let e3 = 0; e3 < i2.length; e3++) {
                  const n3 = t2.getTile(i2[e3]);
                  if (!n3 || !n3.hasData())
                    continue;
                  if (c2(s3, n3.tileID))
                    continue;
                  const a3 = this._createProxiedId(s3, n3, o2[s3.key] && o2[s3.key][t2.id]), l3 = this.proxyToSource[s3.key][t2.id];
                  l3 ? l3.push(a3) : this.proxyToSource[s3.key][t2.id] = [a3], r2.push(a3);
                }
              }
            }
            _createProxiedId(t2, i2, o2) {
              let r2 = this.orthoMatrix;
              if (o2) {
                const e2 = o2.find((e3) => e3.key === i2.tileID.key);
                if (e2)
                  return e2;
              }
              if (i2.tileID.key !== t2.key) {
                const o3 = t2.canonical.z - i2.tileID.canonical.z;
                let n2, s2, a2;
                r2 = e.create();
                const l2 = i2.tileID.wrap - t2.wrap << t2.overscaledZ;
                o3 > 0 ? (n2 = e.EXTENT >> o3, s2 = n2 * ((i2.tileID.canonical.x << o3) - t2.canonical.x + l2), a2 = n2 * ((i2.tileID.canonical.y << o3) - t2.canonical.y)) : (n2 = e.EXTENT << -o3, s2 = e.EXTENT * (i2.tileID.canonical.x - (t2.canonical.x + l2 << -o3)), a2 = e.EXTENT * (i2.tileID.canonical.y - (t2.canonical.y << -o3))), e.ortho(r2, 0, n2, 0, n2, 0, 1), e.translate(r2, r2, [s2, a2, 0]);
              }
              return new Ai(i2.tileID, t2.key, r2);
            }
            _findTileCoveringTileID(t2, i2) {
              let o2 = i2.getTile(t2);
              if (o2 && o2.hasData())
                return o2;
              const r2 = this._findCoveringTileCache[i2.id], n2 = r2[t2.key];
              if (o2 = n2 ? i2.getTileByID(n2) : null, o2 && o2.hasData() || null === n2)
                return o2;
              let s2 = o2 ? o2.tileID : t2, a2 = s2.overscaledZ;
              const l2 = i2.getSource().minzoom, c2 = [];
              if (!n2) {
                const r3 = i2.getSource().maxzoom;
                if (t2.canonical.z >= r3) {
                  const o3 = t2.canonical.z - r3;
                  i2.getSource().reparseOverscaled ? (a2 = Math.max(t2.canonical.z + 2, i2.transform.tileZoom), s2 = new e.OverscaledTileID(a2, t2.wrap, r3, t2.canonical.x >> o3, t2.canonical.y >> o3)) : 0 !== o3 && (a2 = r3, s2 = new e.OverscaledTileID(a2, t2.wrap, r3, t2.canonical.x >> o3, t2.canonical.y >> o3));
                }
                s2.key !== t2.key && (c2.push(s2.key), o2 = i2.getTile(s2));
              }
              const h2 = (e2) => {
                c2.forEach((t3) => {
                  r2[t3] = e2;
                }), c2.length = 0;
              };
              for (a2 -= 1; a2 >= l2 && (!o2 || !o2.hasData()); a2--) {
                o2 && h2(o2.tileID.key);
                const e2 = s2.calculateScaledKey(a2);
                if (o2 = i2.getTileByID(e2), o2 && o2.hasData())
                  break;
                const t3 = r2[e2];
                if (null === t3)
                  break;
                void 0 === t3 ? c2.push(e2) : o2 = i2.getTileByID(t3);
              }
              return h2(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
            }
            findDEMTileFor(e2) {
              return this.enabled ? this._findTileCoveringTileID(e2, this.sourceCache) : null;
            }
            prepareDrawTile() {
              this.renderedToTile = true;
            }
            _clearRenderCacheForTile(e2, t2) {
              let i2 = this._tilesDirty[e2];
              i2 || (i2 = this._tilesDirty[e2] = {}), i2[t2.key] = true;
            }
            getWirefameBuffer() {
              if (!this.wireframeSegments) {
                const t2 = function(t3) {
                  let i2 = 0;
                  const o2 = new e.StructArrayLayout2ui4(), r2 = 131;
                  for (let e2 = 1; e2 < 129; e2++) {
                    for (let t4 = 1; t4 < 129; t4++)
                      i2 = e2 * r2 + t4, o2.emplaceBack(i2, i2 + 1), o2.emplaceBack(i2, i2 + r2), o2.emplaceBack(i2 + 1, i2 + r2), 128 === e2 && o2.emplaceBack(i2 + r2, i2 + r2 + 1);
                    o2.emplaceBack(i2 + 1, i2 + 1 + r2);
                  }
                  return o2;
                }();
                this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t2), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t2.length);
              }
              return [this.wireframeIndexBuffer, this.wireframeSegments];
            }
          }
          class Pi {
            static cacheKey(e2, t2, i2, o2) {
              let r2 = `${t2}${o2 ? o2.cacheKey : ""}`;
              for (const t3 of i2)
                e2.usedDefines.includes(t3) && (r2 += `/${t3}`);
              return r2;
            }
            constructor(t2, i2, o2, r2, n2, s2) {
              const a2 = t2.gl;
              this.program = a2.createProgram();
              const l2 = function(e2) {
                const t3 = [];
                for (let i3 = 0; i3 < e2.length; i3++) {
                  if (null === e2[i3])
                    continue;
                  const o3 = e2[i3].split(" ");
                  t3.push(o3.pop());
                }
                return t3;
              }(o2.staticAttributes), c2 = r2 ? r2.getBinderAttributes() : [], h2 = l2.concat(c2);
              let u2 = r2 ? r2.defines() : [];
              u2 = u2.concat(s2.map((e2) => `#define ${e2}`));
              const _2 = t2.isWebGL2 ? "#version 300 es\n" : "", d2 = _2 + u2.concat(t2.extStandardDerivatives && 0 === _2.length ? "#extension GL_OES_standard_derivatives : enable\n".concat(hi) : hi, hi, ci, li.fragmentSource, si.fragmentSource, o2.fragmentSource).join("\n"), p2 = _2 + u2.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ci, li.vertexSource, si.vertexSource, ni.vertexSource, o2.vertexSource).join("\n"), m2 = a2.createShader(a2.FRAGMENT_SHADER);
              if (a2.isContextLost())
                return void (this.failedToCreate = true);
              a2.shaderSource(m2, d2), a2.compileShader(m2), a2.attachShader(this.program, m2);
              const f2 = a2.createShader(a2.VERTEX_SHADER);
              if (a2.isContextLost())
                this.failedToCreate = true;
              else {
                a2.shaderSource(f2, p2), a2.compileShader(f2), a2.attachShader(this.program, f2), this.attributes = {}, this.numAttributes = h2.length;
                for (let e2 = 0; e2 < this.numAttributes; e2++)
                  h2[e2] && (a2.bindAttribLocation(this.program, e2, h2[e2]), this.attributes[h2[e2]] = e2);
                a2.linkProgram(this.program), a2.deleteShader(f2), a2.deleteShader(m2), this.fixedUniforms = n2(t2), this.binderUniforms = r2 ? r2.getUniforms(t2) : [], s2.includes("TERRAIN") && (this.terrainUniforms = ((t3) => ({ u_dem: new e.Uniform1i(t3), u_dem_prev: new e.Uniform1i(t3), u_dem_unpack: new e.Uniform4f(t3), u_dem_tl: new e.Uniform2f(t3), u_dem_scale: new e.Uniform1f(t3), u_dem_tl_prev: new e.Uniform2f(t3), u_dem_scale_prev: new e.Uniform1f(t3), u_dem_size: new e.Uniform1f(t3), u_dem_lerp: new e.Uniform1f(t3), u_exaggeration: new e.Uniform1f(t3), u_depth: new e.Uniform1i(t3), u_depth_size_inv: new e.Uniform2f(t3), u_meter_to_dem: new e.Uniform1f(t3), u_label_plane_matrix_inv: new e.UniformMatrix4f(t3) }))(t2)), s2.includes("GLOBE") && (this.globeUniforms = ((t3) => ({ u_tile_tl_up: new e.Uniform3f(t3), u_tile_tr_up: new e.Uniform3f(t3), u_tile_br_up: new e.Uniform3f(t3), u_tile_bl_up: new e.Uniform3f(t3), u_tile_up_scale: new e.Uniform1f(t3) }))(t2)), s2.includes("FOG") && (this.fogUniforms = ((t3) => ({ u_fog_matrix: new e.UniformMatrix4f(t3), u_fog_range: new e.Uniform2f(t3), u_fog_color: new e.Uniform4f(t3), u_fog_horizon_blend: new e.Uniform1f(t3), u_fog_temporal_offset: new e.Uniform1f(t3), u_frustum_tl: new e.Uniform3f(t3), u_frustum_tr: new e.Uniform3f(t3), u_frustum_br: new e.Uniform3f(t3), u_frustum_bl: new e.Uniform3f(t3), u_globe_pos: new e.Uniform3f(t3), u_globe_radius: new e.Uniform1f(t3), u_globe_transition: new e.Uniform1f(t3), u_is_globe: new e.Uniform1i(t3), u_viewport: new e.Uniform2f(t3) }))(t2));
              }
            }
            setTerrainUniformValues(e2, t2) {
              if (!this.terrainUniforms)
                return;
              const i2 = this.terrainUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2)
                  i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setGlobeUniformValues(e2, t2) {
              if (!this.globeUniforms)
                return;
              const i2 = this.globeUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2)
                  i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setFogUniformValues(e2, t2) {
              if (!this.fogUniforms)
                return;
              const i2 = this.fogUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2)
                  i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            draw(e2, t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2) {
              const m2 = e2.gl;
              if (this.failedToCreate)
                return;
              e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(o2), e2.setColorMode(r2), e2.setCullFace(n2);
              for (const e3 of Object.keys(this.fixedUniforms))
                this.fixedUniforms[e3].set(this.program, e3, s2[e3]);
              d2 && d2.setUniforms(this.program, e2, this.binderUniforms, u2, { zoom: _2 });
              const f2 = { [m2.LINES]: 2, [m2.TRIANGLES]: 3, [m2.LINE_STRIP]: 1 }[t2];
              for (const i3 of h2.get()) {
                const o3 = i3.vaos || (i3.vaos = {});
                (o3[a2] || (o3[a2] = new pi())).bind(e2, this, l2, d2 ? d2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, p2 || []), m2.drawElements(t2, i3.primitiveLength * f2, m2.UNSIGNED_SHORT, i3.primitiveOffset * f2 * 2);
              }
            }
          }
          function Ri(e2, t2) {
            const i2 = Math.pow(2, t2.tileID.overscaledZ), o2 = t2.tileSize * Math.pow(2, e2.transform.tileZoom) / i2, r2 = o2 * (t2.tileID.canonical.x + t2.tileID.wrap * i2), n2 = o2 * t2.tileID.canonical.y;
            return { u_image: 0, u_texsize: t2.imageAtlasTexture.size, u_tile_units_to_pixels: 1 / P(t2, 1, e2.transform.tileZoom), u_pixel_coord_upper: [r2 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & r2, 65535 & n2] };
          }
          const Oi = e.create(), Bi = (t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2) => {
            const _2 = i2.style.light, d2 = _2.properties.get("position"), p2 = [d2.x, d2.y, d2.z], m2 = e.create$1();
            "viewport" === _2.properties.get("anchor") && (e.fromRotation(m2, -i2.transform.angle), e.transformMat3(p2, p2, m2));
            const f2 = _2.properties.get("color"), g2 = i2.transform, v2 = { u_matrix: t2, u_lightpos: p2, u_lightintensity: _2.properties.get("intensity"), u_lightcolor: [f2.r, f2.g, f2.b], u_vertical_gradient: +o2, u_opacity: r2, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Oi, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: n2, u_edge_radius: s2 };
            return "globe" === g2.projection.name && (v2.u_tile_id = [a2.canonical.x, a2.canonical.y, 1 << a2.canonical.z], v2.u_zoom_transition = c2, v2.u_inv_rot_matrix = u2, v2.u_merc_center = h2, v2.u_up_dir = g2.projection.upVector(new e.CanonicalTileID(0, 0, 0), h2[0] * e.EXTENT, h2[1] * e.EXTENT), v2.u_height_lift = l2), v2;
          }, ki = (t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2) => {
            const d2 = Bi(t2, i2, o2, r2, n2, s2, a2, c2, h2, u2, _2), p2 = { u_height_factor: -Math.pow(2, a2.overscaledZ) / l2.tileSize / 8 };
            return e.extend(d2, Ri(i2, l2), p2);
          }, Fi = (e2) => ({ u_matrix: e2 }), Ui = (t2, i2, o2) => e.extend(Fi(t2), Ri(i2, o2)), Ni = (e2, t2) => ({ u_matrix: e2, u_world: t2 }), Gi = (t2, i2, o2, r2) => e.extend(Ui(t2, i2, o2), { u_world: r2 }), ji = e.create(), Zi = (t2, i2, o2, r2, n2, s2) => {
            const a2 = t2.transform, l2 = "globe" === a2.projection.name;
            let c2;
            if ("map" === s2.paint.get("circle-pitch-alignment"))
              if (l2) {
                const t3 = e.globePixelsToTileUnits(a2.zoom, i2.canonical) * a2._pixelsPerMercatorPixel;
                c2 = Float32Array.from([t3, 0, 0, t3]);
              } else
                c2 = a2.calculatePixelsToTileUnitsMatrix(o2);
            else
              c2 = new Float32Array([a2.pixelsToGLUnits[0], 0, 0, a2.pixelsToGLUnits[1]]);
            const h2 = { u_camera_to_center_distance: a2.cameraToCenterDistance, u_matrix: t2.translatePosMatrix(i2.projMatrix, o2, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: e.exported.devicePixelRatio, u_extrude_scale: c2, u_inv_rot_matrix: ji, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
            if (l2) {
              h2.u_inv_rot_matrix = r2, h2.u_merc_center = n2, h2.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], h2.u_zoom_transition = e.globeToMercatorTransition(a2.zoom);
              const t3 = n2[0] * e.EXTENT, o3 = n2[1] * e.EXTENT;
              h2.u_up_dir = a2.projection.upVector(new e.CanonicalTileID(0, 0, 0), t3, o3);
            }
            return h2;
          }, Vi = (e2) => {
            const t2 = [];
            return "map" === e2.paint.get("circle-pitch-alignment") && t2.push("PITCH_WITH_MAP"), "map" === e2.paint.get("circle-pitch-scale") && t2.push("SCALE_WITH_MAP"), t2;
          }, Wi = (t2, i2, o2, r2) => {
            const n2 = e.EXTENT / o2.tileSize;
            return { u_matrix: t2, u_camera_to_center_distance: i2.getCameraToCenterDistance(r2), u_extrude_scale: [i2.pixelsToGLUnits[0] / n2, i2.pixelsToGLUnits[1] / n2] };
          }, Xi = (e2, t2, i2 = 1) => ({ u_matrix: e2, u_color: t2, u_overlay: 0, u_overlay_scale: i2 }), qi = e.create(), $i = (t2, i2, o2, r2, n2, s2, a2) => {
            const l2 = t2.transform, c2 = "globe" === l2.projection.name, h2 = c2 ? e.globePixelsToTileUnits(l2.zoom, i2.canonical) * l2._pixelsPerMercatorPixel : P(o2, 1, s2), u2 = { u_matrix: i2.projMatrix, u_extrude_scale: h2, u_intensity: a2, u_inv_rot_matrix: qi, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
            if (c2) {
              u2.u_inv_rot_matrix = r2, u2.u_merc_center = n2, u2.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], u2.u_zoom_transition = e.globeToMercatorTransition(l2.zoom);
              const t3 = n2[0] * e.EXTENT, o3 = n2[1] * e.EXTENT;
              u2.u_up_dir = l2.projection.upVector(new e.CanonicalTileID(0, 0, 0), t3, o3);
            }
            return u2;
          }, Hi = (e2, t2, i2, o2, r2, n2, s2) => {
            const a2 = e2.transform, l2 = a2.calculatePixelsToTileUnitsMatrix(t2);
            return { u_matrix: Ji(e2, t2, i2, o2), u_pixels_to_tile_units: l2, u_device_pixel_ratio: n2, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: r2, u_texsize: Qi(i2) ? t2.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Ki(t2, e2.transform), u_alpha_discard_threshold: 0, u_trim_offset: s2 };
          }, Yi = (e2, t2, i2, o2, r2) => {
            const n2 = e2.transform;
            return { u_matrix: Ji(e2, t2, i2, o2), u_texsize: t2.imageAtlasTexture.size, u_pixels_to_tile_units: n2.calculatePixelsToTileUnitsMatrix(t2), u_device_pixel_ratio: r2, u_image: 0, u_tile_units_to_pixels: Ki(t2, n2), u_units_to_pixels: [1 / n2.pixelsToGLUnits[0], 1 / n2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
          };
          function Ki(e2, t2) {
            return 1 / P(e2, 1, t2.tileZoom);
          }
          function Ji(e2, t2, i2, o2) {
            return e2.translatePosMatrix(o2 || t2.tileID.projMatrix, t2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
          }
          function Qi(e2) {
            const t2 = e2.paint.get("line-dasharray").value;
            return t2.value || "constant" !== t2.kind;
          }
          const eo = (e2, t2, i2, o2, r2, n2) => {
            return { u_matrix: e2, u_tl_parent: t2, u_scale_parent: i2, u_fade_t: o2.mix, u_opacity: o2.opacity * r2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r2.paint.get("raster-brightness-min"), u_brightness_high: r2.paint.get("raster-brightness-max"), u_saturation_factor: (a2 = r2.paint.get("raster-saturation"), a2 > 0 ? 1 - 1 / (1.001 - a2) : -a2), u_contrast_factor: (s2 = r2.paint.get("raster-contrast"), s2 > 0 ? 1 / (1 - s2) : 1 + s2), u_spin_weights: to(r2.paint.get("raster-hue-rotate")), u_perspective_transform: n2 };
            var s2, a2;
          };
          function to(e2) {
            e2 *= Math.PI / 180;
            const t2 = Math.sin(e2), i2 = Math.cos(e2);
            return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
          }
          const io = e.create(), oo = (t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2) => {
            const g2 = n2.transform, v2 = { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: i2 ? i2.uSizeT : 0, u_size: i2 ? i2.uSize : 0, u_camera_to_center_distance: g2.cameraToCenterDistance, u_rotate_symbol: +o2, u_aspect_ratio: g2.width / g2.height, u_fade_change: n2.options.fadeDuration ? n2.symbolFadeChange : 1, u_matrix: s2, u_label_plane_matrix: a2, u_coord_matrix: l2, u_is_text: +c2, u_pitch_with_map: +r2, u_texsize: h2, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: io, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: io, u_up_vector: [0, -1, 0] };
            return "globe" === f2.name && (v2.u_tile_id = [u2.canonical.x, u2.canonical.y, 1 << u2.canonical.z], v2.u_zoom_transition = _2, v2.u_inv_rot_matrix = p2, v2.u_merc_center = d2, v2.u_camera_forward = g2._camera.forward(), v2.u_ecef_origin = e.globeECEFOrigin(g2.globeMatrix, u2.toUnwrapped()), v2.u_tile_matrix = Float32Array.from(g2.globeMatrix), v2.u_up_vector = m2), v2;
          }, ro = (t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2, g2) => e.extend(oo(t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, _2, d2, p2, m2, f2, g2), { u_gamma_scale: r2 ? n2.transform.cameraToCenterDistance * Math.cos(n2.terrain ? 0 : n2.transform._pitch) : 1, u_device_pixel_ratio: e.exported.devicePixelRatio, u_is_halo: +u2 }), no = (t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2) => e.extend(ro(t2, i2, o2, r2, n2, s2, a2, l2, true, c2, true, u2, _2, d2, p2, m2, f2), { u_texsize_icon: h2, u_texture_icon: 1 }), so = (e2, t2, i2) => ({ u_matrix: e2, u_opacity: t2, u_color: i2 }), ao = (t2, i2, o2, r2, n2) => e.extend(function(e2, t3, i3) {
            const o3 = t3.imageManager.getPattern(e2.toString()), { width: r3, height: n3 } = t3.imageManager.getPixelSize(), s2 = Math.pow(2, i3.tileID.overscaledZ), a2 = i3.tileSize * Math.pow(2, t3.transform.tileZoom) / s2, l2 = a2 * (i3.tileID.canonical.x + i3.tileID.wrap * s2), c2 = a2 * i3.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl: o3.tl, u_pattern_br: o3.br, u_texsize: [r3, n3], u_pattern_size: o3.displaySize, u_tile_units_to_pixels: 1 / P(i3, 1, t3.transform.tileZoom), u_pixel_coord_upper: [l2 >> 16, c2 >> 16], u_pixel_coord_lower: [65535 & l2, 65535 & c2] };
          }(r2, o2, n2), { u_matrix: t2, u_opacity: i2 }), lo = { fillExtrusion: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_lightpos: new e.Uniform3f(t2), u_lightintensity: new e.Uniform1f(t2), u_lightcolor: new e.Uniform3f(t2), u_vertical_gradient: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_edge_radius: new e.Uniform1f(t2), u_ao: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_up_dir: new e.Uniform3f(t2), u_height_lift: new e.Uniform1f(t2) }), fillExtrusionPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_lightpos: new e.Uniform3f(t2), u_lightintensity: new e.Uniform1f(t2), u_lightcolor: new e.Uniform3f(t2), u_vertical_gradient: new e.Uniform1f(t2), u_height_factor: new e.Uniform1f(t2), u_edge_radius: new e.Uniform1f(t2), u_ao: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_up_dir: new e.Uniform3f(t2), u_height_lift: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2) }), fill: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2) }), fillPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), fillOutline: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_world: new e.Uniform2f(t2) }), fillOutlinePattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_world: new e.Uniform2f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), circle: (t2) => ({ u_camera_to_center_distance: new e.Uniform1f(t2), u_extrude_scale: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_up_dir: new e.Uniform3f(t2) }), collisionBox: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_extrude_scale: new e.Uniform2f(t2) }), collisionCircle: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_inv_matrix: new e.UniformMatrix4f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_viewport_size: new e.Uniform2f(t2) }), debug: (t2) => ({ u_color: new e.UniformColor(t2), u_matrix: new e.UniformMatrix4f(t2), u_overlay: new e.Uniform1i(t2), u_overlay_scale: new e.Uniform1f(t2) }), clippingMask: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2) }), heatmap: (t2) => ({ u_extrude_scale: new e.Uniform1f(t2), u_intensity: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_up_dir: new e.Uniform3f(t2) }), heatmapTexture: (t2) => ({ u_image: new e.Uniform1i(t2), u_color_ramp: new e.Uniform1i(t2), u_opacity: new e.Uniform1f(t2) }), hillshade: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_latrange: new e.Uniform2f(t2), u_light: new e.Uniform2f(t2), u_shadow: new e.UniformColor(t2), u_highlight: new e.UniformColor(t2), u_accent: new e.UniformColor(t2) }), hillshadePrepare: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_dimension: new e.Uniform2f(t2), u_zoom: new e.Uniform1f(t2), u_unpack: new e.Uniform4f(t2) }), line: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_pixels_to_tile_units: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_units_to_pixels: new e.Uniform2f(t2), u_dash_image: new e.Uniform1i(t2), u_gradient_image: new e.Uniform1i(t2), u_image_height: new e.Uniform1f(t2), u_texsize: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_alpha_discard_threshold: new e.Uniform1f(t2), u_trim_offset: new e.Uniform2f(t2) }), linePattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_texsize: new e.Uniform2f(t2), u_pixels_to_tile_units: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_units_to_pixels: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_alpha_discard_threshold: new e.Uniform1f(t2) }), raster: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_tl_parent: new e.Uniform2f(t2), u_scale_parent: new e.Uniform1f(t2), u_fade_t: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_image0: new e.Uniform1i(t2), u_image1: new e.Uniform1i(t2), u_brightness_low: new e.Uniform1f(t2), u_brightness_high: new e.Uniform1f(t2), u_saturation_factor: new e.Uniform1f(t2), u_contrast_factor: new e.Uniform1f(t2), u_spin_weights: new e.Uniform3f(t2), u_perspective_transform: new e.Uniform2f(t2) }), symbolIcon: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_camera_forward: new e.Uniform3f(t2), u_tile_matrix: new e.UniformMatrix4f(t2), u_up_vector: new e.Uniform3f(t2), u_ecef_origin: new e.Uniform3f(t2), u_texture: new e.Uniform1i(t2) }), symbolSDF: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_texture: new e.Uniform1i(t2), u_gamma_scale: new e.Uniform1f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_camera_forward: new e.Uniform3f(t2), u_tile_matrix: new e.UniformMatrix4f(t2), u_up_vector: new e.Uniform3f(t2), u_ecef_origin: new e.Uniform3f(t2), u_is_halo: new e.Uniform1i(t2) }), symbolTextAndIcon: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_texsize_icon: new e.Uniform2f(t2), u_texture: new e.Uniform1i(t2), u_texture_icon: new e.Uniform1i(t2), u_gamma_scale: new e.Uniform1f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_is_halo: new e.Uniform1i(t2) }), background: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_opacity: new e.Uniform1f(t2), u_color: new e.UniformColor(t2) }), backgroundPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_opacity: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_pattern_tl: new e.Uniform2f(t2), u_pattern_br: new e.Uniform2f(t2), u_texsize: new e.Uniform2f(t2), u_pattern_size: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), terrainRaster: xi, terrainDepth: xi, skybox: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_sun_direction: new e.Uniform3f(t2), u_cubemap: new e.Uniform1i(t2), u_opacity: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2) }), skyboxGradient: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_color_ramp: new e.Uniform1i(t2), u_center_direction: new e.Uniform3f(t2), u_radius: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2) }), skyboxCapture: (t2) => ({ u_matrix_3f: new e.UniformMatrix3f(t2), u_sun_direction: new e.Uniform3f(t2), u_sun_intensity: new e.Uniform1f(t2), u_color_tint_r: new e.Uniform4f(t2), u_color_tint_m: new e.Uniform4f(t2), u_luminance: new e.Uniform1f(t2) }), globeRaster: (t2) => ({ u_proj_matrix: new e.UniformMatrix4f(t2), u_globe_matrix: new e.UniformMatrix4f(t2), u_normalize_matrix: new e.UniformMatrix4f(t2), u_merc_matrix: new e.UniformMatrix4f(t2), u_zoom_transition: new e.Uniform1f(t2), u_merc_center: new e.Uniform2f(t2), u_image0: new e.Uniform1i(t2), u_grid_matrix: new e.UniformMatrix3f(t2), u_skirt_height: new e.Uniform1f(t2), u_frustum_tl: new e.Uniform3f(t2), u_frustum_tr: new e.Uniform3f(t2), u_frustum_br: new e.Uniform3f(t2), u_frustum_bl: new e.Uniform3f(t2), u_globe_pos: new e.Uniform3f(t2), u_globe_radius: new e.Uniform1f(t2), u_viewport: new e.Uniform2f(t2) }), globeAtmosphere: (t2) => ({ u_frustum_tl: new e.Uniform3f(t2), u_frustum_tr: new e.Uniform3f(t2), u_frustum_br: new e.Uniform3f(t2), u_frustum_bl: new e.Uniform3f(t2), u_horizon: new e.Uniform1f(t2), u_transition: new e.Uniform1f(t2), u_fadeout_range: new e.Uniform1f(t2), u_color: new e.Uniform4f(t2), u_high_color: new e.Uniform4f(t2), u_space_color: new e.Uniform4f(t2), u_star_intensity: new e.Uniform1f(t2), u_star_density: new e.Uniform1f(t2), u_star_size: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2), u_horizon_angle: new e.Uniform1f(t2), u_rotation_matrix: new e.UniformMatrix4f(t2) }) };
          let co;
          function ho(t2, i2, o2, r2, n2, s2, a2) {
            const l2 = t2.context, c2 = l2.gl, h2 = t2.transform, u2 = t2.useProgram("collisionBox"), _2 = [];
            let d2 = 0, p2 = 0;
            for (let m3 = 0; m3 < r2.length; m3++) {
              const f3 = r2[m3], g3 = i2.getTile(f3), v3 = g3.getBucket(o2);
              if (!v3)
                continue;
              const x3 = yt(f3, v3, h2);
              let y3 = x3;
              0 === n2[0] && 0 === n2[1] || (y3 = t2.translatePosMatrix(x3, g3, n2, s2));
              const b2 = a2 ? v3.textCollisionBox : v3.iconCollisionBox, w2 = v3.collisionCircleArray;
              if (w2.length > 0) {
                const t3 = e.create(), i3 = y3;
                e.mul(t3, v3.placementInvProjMatrix, h2.glCoordMatrix), e.mul(t3, t3, v3.placementViewportMatrix), _2.push({ circleArray: w2, circleOffset: p2, transform: i3, invTransform: t3, projection: v3.getProjection() }), d2 += w2.length / 4, p2 = d2;
              }
              b2 && (t2.terrain && t2.terrain.setupElevationDraw(g3, u2), u2.draw(l2, c2.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t2.colorModeForRenderPass(), e.CullFaceMode.disabled, Wi(y3, h2, g3, v3.getProjection()), o2.id, b2.layoutVertexBuffer, b2.indexBuffer, b2.segments, null, h2.zoom, null, [b2.collisionVertexBuffer, b2.collisionVertexBufferExt]));
            }
            if (!a2 || !_2.length)
              return;
            const m2 = t2.useProgram("collisionCircle"), f2 = new e.StructArrayLayout2f1f2i16();
            f2.resize(4 * d2), f2._trim();
            let g2 = 0;
            for (const e2 of _2)
              for (let t3 = 0; t3 < e2.circleArray.length / 4; t3++) {
                const i3 = 4 * t3, o3 = e2.circleArray[i3 + 0], r3 = e2.circleArray[i3 + 1], n3 = e2.circleArray[i3 + 2], s3 = e2.circleArray[i3 + 3];
                f2.emplace(g2++, o3, r3, n3, s3, 0), f2.emplace(g2++, o3, r3, n3, s3, 1), f2.emplace(g2++, o3, r3, n3, s3, 2), f2.emplace(g2++, o3, r3, n3, s3, 3);
              }
            (!co || co.length < 2 * d2) && (co = function(t3) {
              const i3 = 2 * t3, o3 = new e.StructArrayLayout3ui6();
              o3.resize(i3), o3._trim();
              for (let e2 = 0; e2 < i3; e2++) {
                const t4 = 6 * e2;
                o3.uint16[t4 + 0] = 4 * e2 + 0, o3.uint16[t4 + 1] = 4 * e2 + 1, o3.uint16[t4 + 2] = 4 * e2 + 2, o3.uint16[t4 + 3] = 4 * e2 + 2, o3.uint16[t4 + 4] = 4 * e2 + 3, o3.uint16[t4 + 5] = 4 * e2 + 0;
              }
              return o3;
            }(d2));
            const v2 = l2.createIndexBuffer(co, true), x2 = l2.createVertexBuffer(f2, e.collisionCircleLayout.members, true);
            for (const i3 of _2) {
              const r3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (y2 = h2).getCameraToCenterDistance(i3.projection), u_viewport_size: [y2.width, y2.height] };
              m2.draw(l2, c2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t2.colorModeForRenderPass(), e.CullFaceMode.disabled, r3, o2.id, x2, v2, e.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h2.zoom);
            }
            var y2;
            x2.destroy(), v2.destroy();
          }
          const uo = e.create();
          function _o({ width: t2, height: i2, anchor: o2, textOffset: r2, textScale: n2 }, s2) {
            const { horizontalAlign: a2, verticalAlign: l2 } = e.getAnchorAlignment(o2), c2 = -(a2 - 0.5) * t2, h2 = -(l2 - 0.5) * i2, u2 = e.evaluateVariableOffset(o2, r2);
            return new e.pointGeometry((c2 / n2 + u2[0]) * s2, (h2 / n2 + u2[1]) * s2);
          }
          function po(t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2) {
            const _2 = t2.text.placedSymbolArray, d2 = t2.text.dynamicLayoutVertexArray, p2 = t2.icon.dynamicLayoutVertexArray, m2 = {}, f2 = t2.getProjection(), g2 = bt(l2, f2, s2), v2 = s2.elevation, x2 = f2.upVectorScale(l2.canonical, s2.center.lat, s2.worldSize).metersToTile;
            d2.clear();
            for (let p3 = 0; p3 < _2.length; p3++) {
              const y2 = _2.get(p3), { tileAnchorX: b2, tileAnchorY: w2, numGlyphs: T2 } = y2, E2 = t2.allowVerticalPlacement && !y2.placedOrientation, C2 = y2.hidden || !y2.crossTileID || E2 ? null : r2[y2.crossTileID];
              if (C2) {
                let r3 = 0, _3 = 0, p4 = 0;
                if (v2) {
                  const e2 = v2 ? v2.getAtTileOffset(l2, b2, w2) : 0, [t3, i3, o3] = f2.upVector(l2.canonical, b2, w2);
                  r3 = e2 * t3 * x2, _3 = e2 * i3 * x2, p4 = e2 * o3 * x2;
                }
                let [E3, M2, I2, S2] = nt(y2.projectedAnchorX + r3, y2.projectedAnchorY + _3, y2.projectedAnchorZ + p4, o2 ? g2 : a2);
                const D2 = st(s2.getCameraToCenterDistance(f2), S2);
                let L2 = n2.evaluateSizeForFeature(t2.textSizeData, h2, y2) * D2 / e.ONE_EM;
                o2 && (L2 *= t2.tilePixelRatio / c2);
                const A2 = _o(C2, L2);
                o2 ? ({ x: E3, y: M2, z: I2 } = f2.projectTilePoint(b2 + A2.x, w2 + A2.y, l2.canonical), [E3, M2, I2] = nt(E3 + r3, M2 + _3, I2 + p4, a2)) : (i2 && A2._rotate(-s2.angle), E3 += A2.x, M2 += A2.y, I2 = 0);
                const z2 = t2.allowVerticalPlacement && y2.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;
                for (let t3 = 0; t3 < T2; t3++)
                  e.addDynamicAttributes(d2, E3, M2, I2, z2);
                u2 && y2.associatedIconIndex >= 0 && (m2[y2.associatedIconIndex] = { x: E3, y: M2, z: I2, angle: z2 });
              } else
                mt(T2, d2);
            }
            if (u2) {
              p2.clear();
              const i3 = t2.icon.placedSymbolArray;
              for (let t3 = 0; t3 < i3.length; t3++) {
                const o3 = i3.get(t3), { numGlyphs: r3 } = o3, n3 = m2[t3];
                if (o3.hidden || !n3)
                  mt(r3, p2);
                else {
                  const { x: t4, y: i4, z: o4, angle: s3 } = n3;
                  for (let n4 = 0; n4 < r3; n4++)
                    e.addDynamicAttributes(p2, t4, i4, o4, s3);
                }
              }
              t2.icon.dynamicLayoutVertexBuffer.updateData(p2);
            }
            t2.text.dynamicLayoutVertexBuffer.updateData(d2);
          }
          function mo(e2, t2, i2) {
            return i2.iconsInText && t2 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
          }
          function fo(t2, i2, o2, r2, n2, s2, a2, l2, c2, h2, u2, _2) {
            const d2 = t2.context, p2 = d2.gl, m2 = t2.transform, f2 = "map" === l2, g2 = "map" === c2, v2 = f2 && "point" !== o2.layout.get("symbol-placement"), x2 = f2 && !g2 && !v2, y2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1);
            let b2 = false;
            const w2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), T2 = [e.mercatorXfromLng(m2.center.lng), e.mercatorYfromLat(m2.center.lat)], E2 = o2.layout.get("text-variable-anchor"), C2 = "globe" === m2.projection.name, M2 = [], I2 = [0, -1, 0];
            let S2 = I2;
            !C2 && !m2.mercatorFromTransition || f2 || (S2 = function(t3) {
              const i3 = t3._camera.getWorldToCamera(t3.worldSize, 1), o3 = e.multiply([], i3, t3.globeMatrix);
              e.invert(o3, o3);
              const r3 = [0, 0, 0], n3 = [0, 1, 0, 0];
              return e.transformMat4$1(n3, n3, o3), r3[0] = n3[0], r3[1] = n3[1], r3[2] = n3[2], e.normalize(r3, r3), r3;
            }(m2));
            for (const l3 of r2) {
              const r3 = i2.getTile(l3), c3 = r3.getBucket(o2);
              if (!c3)
                continue;
              if ("mercator" === c3.projection.name && C2)
                continue;
              const u3 = n2 ? c3.text : c3.icon;
              if (!u3 || c3.fullyClipped || !u3.segments.get().length)
                continue;
              const _3 = u3.programConfigurations.get(o2.id), d3 = n2 || c3.sdfIcons, w3 = n2 ? c3.textSizeData : c3.iconSizeData, D2 = g2 || 0 !== m2.pitch, L2 = e.evaluateSizeForZoom(w3, m2.zoom);
              let A2, z2, P2, R2, O2 = [0, 0], B2 = null;
              if (n2) {
                if (z2 = r3.glyphAtlasTexture, P2 = p2.LINEAR, A2 = r3.glyphAtlasTexture.size, c3.iconsInText) {
                  O2 = r3.imageAtlasTexture.size, B2 = r3.imageAtlasTexture;
                  const e2 = "composite" === w3.kind || "camera" === w3.kind;
                  R2 = D2 || t2.options.rotating || t2.options.zooming || e2 ? p2.LINEAR : p2.NEAREST;
                }
              } else {
                const e2 = 1 !== o2.layout.get("icon-size").constantOr(0) || c3.iconsNeedLinear;
                z2 = r3.imageAtlasTexture, P2 = d3 || t2.options.rotating || t2.options.zooming || e2 || D2 ? p2.LINEAR : p2.NEAREST, A2 = r3.imageAtlasTexture.size;
              }
              const k2 = "globe" === c3.projection.name, F2 = k2 ? S2 : I2, U2 = k2 ? e.globeToMercatorTransition(m2.zoom) : 0, N2 = bt(l3, c3.getProjection(), m2), G2 = m2.calculatePixelsToTileUnitsMatrix(r3), j2 = it(N2, r3.tileID.canonical, g2, f2, m2, c3.getProjection(), G2), Z2 = t2.terrain && g2 && v2 ? e.invert(e.create(), j2) : uo, V2 = rt(N2, r3.tileID.canonical, g2, f2, m2, c3.getProjection(), G2), W2 = E2 && c3.hasTextData(), X2 = "none" !== o2.layout.get("icon-text-fit") && W2 && c3.hasIconData();
              if (v2) {
                const e2 = m2.elevation, i3 = e2 ? e2.getAtTileOffsetFunc(l3, m2.center.lat, m2.worldSize, c3.getProjection()) : null, o3 = ot(N2, r3.tileID.canonical, g2, f2, m2, c3.getProjection(), G2);
                lt(c3, N2, t2, n2, o3, V2, g2, h2, i3, l3);
              }
              const q2 = v2 || n2 && E2 || X2, $2 = t2.translatePosMatrix(N2, r3, s2, a2), H2 = q2 ? uo : j2, Y2 = t2.translatePosMatrix(V2, r3, s2, a2, true), K2 = c3.getProjection().createInversionMatrix(m2, l3.canonical), J2 = [];
              t2.terrainRenderModeElevated() && g2 && J2.push("PITCH_WITH_MAP_TERRAIN"), k2 && J2.push("PROJECTION_GLOBE_VIEW"), q2 && J2.push("PROJECTED_POS_ON_VIEWPORT");
              const Q2 = d3 && 0 !== o2.paint.get(n2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
              let ee2;
              ee2 = d3 ? c3.iconsInText ? no(w3.kind, L2, x2, g2, t2, $2, H2, Y2, A2, O2, l3, U2, T2, K2, F2, c3.getProjection()) : ro(w3.kind, L2, x2, g2, t2, $2, H2, Y2, n2, A2, true, l3, U2, T2, K2, F2, c3.getProjection()) : oo(w3.kind, L2, x2, g2, t2, $2, H2, Y2, n2, A2, l3, U2, T2, K2, F2, c3.getProjection());
              const te2 = { program: t2.useProgram(mo(d3, n2, c3), _3, J2), buffers: u3, uniformValues: ee2, atlasTexture: z2, atlasTextureIcon: B2, atlasInterpolation: P2, atlasInterpolationIcon: R2, isSDF: d3, hasHalo: Q2, tile: r3, labelPlaneMatrixInv: Z2 };
              if (y2 && c3.canOverlap) {
                b2 = true;
                const t3 = u3.segments.get();
                for (const i3 of t3)
                  M2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: te2 });
              } else
                M2.push({ segments: u3.segments, sortKey: 0, state: te2 });
            }
            b2 && M2.sort((e2, t3) => e2.sortKey - t3.sortKey);
            for (const e2 of M2) {
              const i3 = e2.state;
              if (t2.terrain && t2.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: !C2, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }), d2.activeTexture.set(p2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (d2.activeTexture.set(p2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i3.isSDF) {
                const r3 = i3.uniformValues;
                i3.hasHalo && (r3.u_is_halo = 1, go(i3.buffers, e2.segments, o2, t2, i3.program, w2, u2, _2, r3)), r3.u_is_halo = 0;
              }
              go(i3.buffers, e2.segments, o2, t2, i3.program, w2, u2, _2, i3.uniformValues);
            }
          }
          function go(t2, i2, o2, r2, n2, s2, a2, l2, c2) {
            const h2 = r2.context, u2 = [t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer, t2.globeExtVertexBuffer];
            n2.draw(h2, h2.gl.TRIANGLES, s2, a2, l2, e.CullFaceMode.disabled, c2, o2.id, t2.layoutVertexBuffer, t2.indexBuffer, i2, o2.paint, r2.transform.zoom, t2.programConfigurations.get(o2.id), u2);
          }
          function vo(t2, i2, o2, r2, n2, s2, a2) {
            const l2 = t2.context.gl, c2 = o2.paint.get("fill-pattern"), h2 = c2 && c2.constantOr(1);
            let u2, _2, d2, p2, m2;
            a2 ? (_2 = h2 && !o2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u2 = l2.LINES) : (_2 = h2 ? "fillPattern" : "fill", u2 = l2.TRIANGLES);
            for (const f2 of r2) {
              const r3 = i2.getTile(f2);
              if (h2 && !r3.patternsLoaded())
                continue;
              const g2 = r3.getBucket(o2);
              if (!g2)
                continue;
              t2.prepareDrawTile();
              const v2 = g2.programConfigurations.get(o2.id), x2 = t2.useProgram(_2, v2);
              h2 && (t2.context.activeTexture.set(l2.TEXTURE0), r3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), v2.updatePaintBuffers());
              const y2 = c2.constantOr(null);
              if (y2 && r3.imageAtlas) {
                const e2 = r3.imageAtlas.patternPositions[y2.toString()];
                e2 && v2.setConstantPatternPositions(e2);
              }
              const b2 = t2.translatePosMatrix(f2.projMatrix, r3, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
              if (a2) {
                p2 = g2.indexBuffer2, m2 = g2.segments2;
                const e2 = t2.terrain && t2.terrain.renderingToTexture ? t2.terrain.drapeBufferSize : [l2.drawingBufferWidth, l2.drawingBufferHeight];
                d2 = "fillOutlinePattern" === _2 && h2 ? Gi(b2, t2, r3, e2) : Ni(b2, e2);
              } else
                p2 = g2.indexBuffer, m2 = g2.segments, d2 = h2 ? Ui(b2, t2, r3) : Fi(b2);
              t2.prepareDrawProgram(t2.context, x2, f2.toUnwrapped()), x2.draw(t2.context, u2, n2, t2.stencilModeForClipping(f2), s2, e.CullFaceMode.disabled, d2, o2.id, g2.layoutVertexBuffer, p2, m2, o2.paint, t2.transform.zoom, v2);
            }
          }
          function xo(t2, i2, o2, r2, n2, s2, a2) {
            const l2 = t2.context, c2 = l2.gl, h2 = t2.transform, u2 = o2.paint.get("fill-extrusion-pattern"), _2 = u2.constantOr(1), d2 = o2.paint.get("fill-extrusion-opacity"), p2 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), o2.paint.get("fill-extrusion-ambient-occlusion-radius")], m2 = o2.layout.get("fill-extrusion-edge-radius"), f2 = "globe" === h2.projection.name ? e.fillExtrusionHeightLift() : 0, g2 = "globe" === h2.projection.name, v2 = g2 ? e.globeToMercatorTransition(h2.zoom) : 0, x2 = [e.mercatorXfromLng(h2.center.lng), e.mercatorYfromLat(h2.center.lat)], y2 = [];
            g2 && y2.push("PROJECTION_GLOBE_VIEW"), p2[0] > 0 && y2.push("FAUX_AO");
            for (const b2 of r2) {
              const r3 = i2.getTile(b2), w2 = r3.getBucket(o2);
              if (!w2 || w2.projection.name !== h2.projection.name)
                continue;
              const T2 = w2.programConfigurations.get(o2.id), E2 = t2.useProgram(_2 ? "fillExtrusionPattern" : "fillExtrusion", T2, y2);
              if (t2.terrain) {
                const e2 = t2.terrain;
                if (t2.style.terrainSetForDrapingOnly())
                  e2.setupElevationDraw(r3, E2, { useMeterToDem: true });
                else {
                  if (!w2.enableTerrain)
                    continue;
                  if (e2.setupElevationDraw(r3, E2, { useMeterToDem: true }), yo(l2, i2, b2, w2, o2, e2), !w2.centroidVertexBuffer) {
                    const e3 = E2.attributes.a_centroid_pos;
                    void 0 !== e3 && c2.vertexAttrib2f(e3, 0, 0);
                  }
                }
              }
              _2 && (t2.context.activeTexture.set(c2.TEXTURE0), r3.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), T2.updatePaintBuffers());
              const C2 = u2.constantOr(null);
              if (C2 && r3.imageAtlas) {
                const e2 = r3.imageAtlas.patternPositions[C2.toString()];
                e2 && T2.setConstantPatternPositions(e2);
              }
              const M2 = t2.translatePosMatrix(b2.projMatrix, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), I2 = h2.projection.createInversionMatrix(h2, b2.canonical), S2 = o2.paint.get("fill-extrusion-vertical-gradient"), D2 = _2 ? ki(M2, t2, S2, d2, p2, m2, b2, r3, f2, v2, x2, I2) : Bi(M2, t2, S2, d2, p2, m2, b2, f2, v2, x2, I2);
              t2.prepareDrawProgram(l2, E2, b2.toUnwrapped());
              const L2 = [];
              t2.terrain && L2.push(w2.centroidVertexBuffer), g2 && L2.push(w2.layoutVertexExtBuffer), E2.draw(l2, l2.gl.TRIANGLES, n2, s2, a2, e.CullFaceMode.backCCW, D2, o2.id, w2.layoutVertexBuffer, w2.indexBuffer, w2.segments, o2.paint, t2.transform.zoom, T2, L2);
            }
          }
          function yo(t2, i2, o2, r2, n2, s2) {
            const a2 = [(t3) => {
              let i3 = t3.canonical.x - 1, o3 = t3.wrap;
              return i3 < 0 && (i3 = (1 << t3.canonical.z) - 1, o3--), new e.OverscaledTileID(t3.overscaledZ, o3, t3.canonical.z, i3, t3.canonical.y);
            }, (t3) => {
              let i3 = t3.canonical.x + 1, o3 = t3.wrap;
              return i3 === 1 << t3.canonical.z && (i3 = 0, o3++), new e.OverscaledTileID(t3.overscaledZ, o3, t3.canonical.z, i3, t3.canonical.y);
            }, (t3) => new e.OverscaledTileID(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, (0 === t3.canonical.y ? 1 << t3.canonical.z : t3.canonical.y) - 1), (t3) => new e.OverscaledTileID(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y === (1 << t3.canonical.z) - 1 ? 0 : t3.canonical.y + 1)], l2 = (e2) => {
              const t3 = i2.getSource().minzoom, o3 = (e3) => {
                const t4 = i2.getTileByID(e3);
                if (t4 && t4.hasData())
                  return t4.getBucket(n2);
              }, r3 = [0, -1, 1];
              for (const i3 of r3) {
                if (e2.overscaledZ + i3 < t3)
                  continue;
                const r4 = o3(e2.calculateScaledKey(e2.overscaledZ + i3));
                if (r4)
                  return r4;
              }
            }, c2 = [0, 0, 0], h2 = (t3, i3) => (c2[0] = Math.min(t3.min.y, i3.min.y), c2[1] = Math.max(t3.max.y, i3.max.y), c2[2] = e.EXTENT - i3.min.x > t3.max.x ? i3.min.x - e.EXTENT : t3.max.x, c2), u2 = (t3, i3) => (c2[0] = Math.min(t3.min.x, i3.min.x), c2[1] = Math.max(t3.max.x, i3.max.x), c2[2] = e.EXTENT - i3.min.y > t3.max.y ? i3.min.y - e.EXTENT : t3.max.y, c2), _2 = [(e2, t3) => h2(e2, t3), (e2, t3) => h2(t3, e2), (e2, t3) => u2(e2, t3), (e2, t3) => u2(t3, e2)], d2 = new e.pointGeometry(0, 0);
            let p2, m2, f2;
            const g2 = (t3, i3, r3, n3, a3) => {
              const l3 = [[n3 ? r3 : t3, n3 ? t3 : r3, 0], [n3 ? r3 : i3, n3 ? i3 : r3, 0]], c3 = a3 < 0 ? e.EXTENT + a3 : a3, h3 = [n3 ? c3 : (t3 + i3) / 2, n3 ? (t3 + i3) / 2 : c3, 0];
              return 0 === r3 && a3 < 0 || 0 !== r3 && a3 > 0 ? s2.getForTilePoints(f2, [h3], true, m2) : l3.push(h3), s2.getForTilePoints(o2, l3, true, p2), Math.max(l3[0][2], l3[1][2], h3[2]) / s2.exaggeration();
            };
            for (let t3 = 0; t3 < 4; t3++) {
              const i3 = (t3 < 2 ? 1 : 5) - t3, n3 = r2.borders[t3];
              if (0 === n3.length)
                continue;
              const c3 = f2 = a2[t3](o2), h3 = l2(c3);
              if (!(h3 && h3 instanceof e.FillExtrusionBucket && h3.enableTerrain))
                continue;
              if (r2.borderDoneWithNeighborZ[t3] === h3.canonical.z && h3.borderDoneWithNeighborZ[i3] === r2.canonical.z)
                continue;
              if (m2 = s2.findDEMTileFor(c3), !m2 || !m2.dem)
                continue;
              if (!p2) {
                const e2 = s2.findDEMTileFor(o2);
                if (!e2 || !e2.dem)
                  return;
                p2 = e2;
              }
              const u3 = h3.borders[i3];
              let v2 = 0;
              const x2 = h3.borderDoneWithNeighborZ[i3] !== r2.canonical.z;
              if (r2.canonical.z === h3.canonical.z) {
                for (let o3 = 0; o3 < n3.length; o3++) {
                  const s3 = r2.featuresOnBorder[n3[o3]], a3 = s3.borders[t3];
                  let l3;
                  for (; v2 < u3.length && (l3 = h3.featuresOnBorder[u3[v2]], !(l3.borders[i3][1] > a3[0] + 3)); )
                    x2 && h3.encodeCentroid(void 0, l3, false), v2++;
                  if (l3 && v2 < u3.length) {
                    const o4 = v2;
                    let n4 = 0;
                    for (; !(l3.borders[i3][0] > a3[1] - 3) && (n4++, ++v2 !== u3.length); )
                      l3 = h3.featuresOnBorder[u3[v2]];
                    if (l3 = h3.featuresOnBorder[u3[o4]], s3.intersectsCount() > 1 || l3.intersectsCount() > 1 || 1 !== n4) {
                      1 !== n4 && (v2 = o4), r2.encodeCentroid(void 0, s3, false), x2 && h3.encodeCentroid(void 0, l3, false);
                      continue;
                    }
                    const c4 = _2[t3](s3, l3), p3 = t3 % 2 ? e.EXTENT - 1 : 0;
                    d2.x = g2(c4[0], Math.min(e.EXTENT - 1, c4[1]), p3, t3 < 2, c4[2]), d2.y = 0, r2.encodeCentroid(d2, s3, false), x2 && h3.encodeCentroid(d2, l3, false);
                  } else
                    r2.encodeCentroid(void 0, s3, false);
                }
                r2.borderDoneWithNeighborZ[t3] = h3.canonical.z, r2.needsCentroidUpdate = true, x2 && (h3.borderDoneWithNeighborZ[i3] = r2.canonical.z, h3.needsCentroidUpdate = true);
              } else {
                for (const e2 of n3)
                  r2.encodeCentroid(void 0, r2.featuresOnBorder[e2], false);
                if (x2) {
                  for (const e2 of u3)
                    h3.encodeCentroid(void 0, h3.featuresOnBorder[e2], false);
                  h3.borderDoneWithNeighborZ[i3] = r2.canonical.z, h3.needsCentroidUpdate = true;
                }
                r2.borderDoneWithNeighborZ[t3] = h3.canonical.z, r2.needsCentroidUpdate = true;
              }
            }
            (r2.needsCentroidUpdate || !r2.centroidVertexBuffer && 0 !== r2.centroidVertexArray.length) && r2.uploadCentroid(t2);
          }
          const bo = new e.Color(1, 0, 0, 1), wo = new e.Color(0, 1, 0, 1), To = new e.Color(0, 0, 1, 1), Eo = new e.Color(1, 0, 1, 1), Co = new e.Color(0, 1, 1, 1);
          function Mo(t2, i2, o2) {
            const r2 = t2.context, n2 = t2.transform, s2 = r2.gl, a2 = "globe" === n2.projection.name, l2 = a2 ? ["PROJECTION_GLOBE_VIEW"] : null;
            let c2 = o2.projMatrix;
            if (a2 && e.globeToMercatorTransition(n2.zoom) > 0) {
              const t3 = e.transitionTileAABBinECEF(o2.canonical, n2), i3 = e.globeDenormalizeECEF(t3);
              c2 = e.multiply(new Float32Array(16), n2.globeMatrix, i3), e.multiply(c2, n2.projMatrix, c2);
            }
            const h2 = t2.useProgram("debug", null, l2), u2 = i2.getTileByID(o2.key);
            t2.terrain && t2.terrain.setupElevationDraw(u2, h2);
            const _2 = e.DepthMode.disabled, d2 = e.StencilMode.disabled, p2 = t2.colorModeForRenderPass(), m2 = "$debug";
            r2.activeTexture.set(s2.TEXTURE0), t2.emptyTexture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE), a2 ? u2._makeGlobeTileDebugBuffers(t2.context, n2) : u2._makeDebugTileBoundsBuffers(t2.context, n2.projection);
            const f2 = u2._tileDebugBuffer || t2.debugBuffer, g2 = u2._tileDebugIndexBuffer || t2.debugIndexBuffer, v2 = u2._tileDebugSegments || t2.debugSegments;
            h2.draw(r2, s2.LINE_STRIP, _2, d2, p2, e.CullFaceMode.disabled, Xi(c2, e.Color.red), m2, f2, g2, v2, null, null, null, [u2._globeTileDebugBorderBuffer]);
            const x2 = u2.latestRawTileData, y2 = Math.floor((x2 && x2.byteLength || 0) / 1024), b2 = i2.getTile(o2).tileSize, w2 = 512 / Math.min(b2, 512) * (o2.overscaledZ / n2.zoom) * 0.5;
            let T2 = o2.canonical.toString();
            o2.overscaledZ !== o2.canonical.z && (T2 += ` => ${o2.overscaledZ}`), T2 += ` ${y2}kb`, function(e2, t3) {
              e2.initDebugOverlayCanvas();
              const i3 = e2.debugOverlayCanvas, o3 = e2.context.gl, r3 = e2.debugOverlayCanvas.getContext("2d");
              r3.clearRect(0, 0, i3.width, i3.height), r3.shadowColor = "white", r3.shadowBlur = 2, r3.lineWidth = 1.5, r3.strokeStyle = "white", r3.textBaseline = "top", r3.font = "bold 36px Open Sans, sans-serif", r3.fillText(t3, 5, 5), r3.strokeText(t3, 5, 5), e2.debugOverlayTexture.update(i3), e2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
            }(t2, T2);
            const E2 = u2._tileDebugTextBuffer || t2.debugBuffer, C2 = u2._tileDebugTextIndexBuffer || t2.quadTriangleIndexBuffer, M2 = u2._tileDebugTextSegments || t2.debugSegments;
            h2.draw(r2, s2.TRIANGLES, _2, d2, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Xi(c2, e.Color.transparent, w2), m2, E2, C2, M2, null, null, null, [u2._globeTileDebugTextBuffer]);
          }
          function Io(e2, t2, i2, o2) {
            Do(e2, 0, t2 + i2 / 2, e2.transform.width, i2, o2);
          }
          function So(e2, t2, i2, o2) {
            Do(e2, t2 - i2 / 2, 0, i2, e2.transform.height, o2);
          }
          function Do(t2, i2, o2, r2, n2, s2) {
            const a2 = t2.context, l2 = a2.gl;
            l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * e.exported.devicePixelRatio, o2 * e.exported.devicePixelRatio, r2 * e.exported.devicePixelRatio, n2 * e.exported.devicePixelRatio), a2.clear({ color: s2 }), l2.disable(l2.SCISSOR_TEST);
          }
          const Lo = e.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Ao } = Lo;
          function zo(e2, t2, i2, o2) {
            e2.emplaceBack(t2, i2, o2);
          }
          class Po {
            constructor(t2) {
              this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), zo(this.vertexArray, -1, -1, 1), zo(this.vertexArray, 1, -1, 1), zo(this.vertexArray, -1, 1, 1), zo(this.vertexArray, 1, 1, 1), zo(this.vertexArray, -1, -1, -1), zo(this.vertexArray, 1, -1, -1), zo(this.vertexArray, -1, 1, -1), zo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, Ao), this.indexBuffer = t2.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);
            }
          }
          function Ro(t2, i2, o2, r2, n2, s2) {
            const a2 = t2.gl, l2 = i2.paint.get("sky-atmosphere-color"), c2 = i2.paint.get("sky-atmosphere-halo-color"), h2 = i2.paint.get("sky-atmosphere-sun-intensity"), u2 = ((e2, t3, i3, o3, r3) => ({ u_matrix_3f: e2, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r3.r, r3.g, r3.b, r3.a], u_luminance: 5e-5 }))(e.fromMat4(e.create$1(), r2), n2, h2, l2, c2);
            a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_CUBE_MAP_POSITIVE_X + s2, i2.skyboxTexture, 0), o2.draw(t2, a2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, u2, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
          }
          const Oo = e.createLayout([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
          class Bo {
            constructor(t2) {
              const i2 = new e.StructArrayLayout5f20();
              i2.emplaceBack(-1, 1, 1, 0, 0), i2.emplaceBack(1, 1, 1, 1, 0), i2.emplaceBack(1, -1, 1, 1, 1), i2.emplaceBack(-1, -1, 1, 0, 1);
              const o2 = new e.StructArrayLayout3ui6();
              o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t2.createVertexBuffer(i2, Oo.members), this.indexBuffer = t2.createIndexBuffer(o2), this.segments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
              this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
          }
          const ko = { symbol: function(t2, i2, o2, r2, n2) {
            if ("translucent" !== t2.renderPass)
              return;
            const s2 = e.StencilMode.disabled, a2 = t2.colorModeForRenderPass();
            o2.layout.get("text-variable-anchor") && function(t3, i3, o3, r3, n3, s3, a3) {
              const l2 = i3.transform, c2 = "map" === n3, h2 = "map" === s3;
              for (const i4 of t3) {
                const t4 = r3.getTile(i4), n4 = t4.getBucket(o3);
                if (!n4 || !n4.text || !n4.text.segments.get().length)
                  continue;
                const s4 = e.evaluateSizeForZoom(n4.textSizeData, l2.zoom), u2 = bt(i4, n4.getProjection(), l2), _2 = l2.calculatePixelsToTileUnitsMatrix(t4), d2 = it(u2, t4.tileID.canonical, h2, c2, l2, n4.getProjection(), _2), p2 = "none" !== o3.layout.get("icon-text-fit") && n4.hasIconData();
                if (s4) {
                  const o4 = Math.pow(2, l2.zoom - t4.tileID.overscaledZ);
                  po(n4, c2, h2, a3, e.symbolSize, l2, d2, i4, o4, s4, p2);
                }
              }
            }(r2, t2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), n2), 0 !== o2.paint.get("icon-opacity").constantOr(1) && fo(t2, i2, o2, r2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), s2, a2), 0 !== o2.paint.get("text-opacity").constantOr(1) && fo(t2, i2, o2, r2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), s2, a2), i2.map.showCollisionBoxes && (ho(t2, i2, o2, r2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), ho(t2, i2, o2, r2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
          }, circle: function(t2, i2, o2, r2) {
            if ("translucent" !== t2.renderPass)
              return;
            const n2 = o2.paint.get("circle-opacity"), s2 = o2.paint.get("circle-stroke-width"), a2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1);
            if (0 === n2.constantOr(1) && (0 === s2.constantOr(1) || 0 === a2.constantOr(1)))
              return;
            const c2 = t2.context, h2 = c2.gl, u2 = t2.transform, _2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), d2 = e.StencilMode.disabled, p2 = t2.colorModeForRenderPass(), m2 = "globe" === u2.projection.name, f2 = [e.mercatorXfromLng(u2.center.lng), e.mercatorYfromLat(u2.center.lat)], g2 = [];
            for (let n3 = 0; n3 < r2.length; n3++) {
              const s3 = r2[n3], a3 = i2.getTile(s3), c3 = a3.getBucket(o2);
              if (!c3 || c3.projection.name !== u2.projection.name)
                continue;
              const h3 = c3.programConfigurations.get(o2.id), _3 = Vi(o2);
              m2 && _3.push("PROJECTION_GLOBE_VIEW");
              const d3 = t2.useProgram("circle", h3, _3), p3 = c3.layoutVertexBuffer, v3 = c3.globeExtVertexBuffer, x2 = c3.indexBuffer, y2 = u2.projection.createInversionMatrix(u2, s3.canonical), b2 = { programConfiguration: h3, program: d3, layoutVertexBuffer: p3, globeExtVertexBuffer: v3, indexBuffer: x2, uniformValues: Zi(t2, s3, a3, y2, f2, o2), tile: a3 };
              if (l2) {
                const t3 = c3.segments.get();
                for (const i3 of t3)
                  g2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: b2 });
              } else
                g2.push({ segments: c3.segments, sortKey: 0, state: b2 });
            }
            l2 && g2.sort((e2, t3) => e2.sortKey - t3.sortKey);
            const v2 = { useDepthForOcclusion: !m2 };
            for (const i3 of g2) {
              const { programConfiguration: r3, program: n3, layoutVertexBuffer: s3, globeExtVertexBuffer: a3, indexBuffer: l3, uniformValues: m3, tile: f3 } = i3.state, g3 = i3.segments;
              t2.terrain && t2.terrain.setupElevationDraw(f3, n3, v2), t2.prepareDrawProgram(c2, n3, f3.tileID.toUnwrapped()), n3.draw(c2, h2.TRIANGLES, _2, d2, p2, e.CullFaceMode.disabled, m3, o2.id, s3, l3, g3, o2.paint, u2.zoom, r3, [a3]);
            }
          }, heatmap: function(t2, i2, o2, r2) {
            if (0 !== o2.paint.get("heatmap-opacity"))
              if ("offscreen" === t2.renderPass) {
                const n2 = t2.context, s2 = n2.gl, a2 = e.StencilMode.disabled, l2 = new e.ColorMode([s2.ONE, s2.ONE], e.Color.transparent, [true, true, true, true]);
                !function(e2, t3, i3, o3) {
                  const r3 = e2.gl, n3 = t3.width * o3, s3 = t3.height * o3;
                  e2.activeTexture.set(r3.TEXTURE1), e2.viewport.set([0, 0, n3, s3]);
                  let a3 = i3.heatmapFbo;
                  if (!a3 || a3 && (a3.width !== n3 || a3.height !== s3)) {
                    a3 && a3.destroy();
                    const t4 = r3.createTexture();
                    r3.bindTexture(r3.TEXTURE_2D, t4), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_S, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_T, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MIN_FILTER, r3.LINEAR), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MAG_FILTER, r3.LINEAR), a3 = i3.heatmapFbo = e2.createFramebuffer(n3, s3, false), function(e3, t5, i4, o4, r4, n4) {
                      const s4 = e3.gl;
                      s4.texImage2D(s4.TEXTURE_2D, 0, e3.isWebGL2 && e3.extRenderToTextureHalfFloat ? s4.RGBA16F : s4.RGBA, r4, n4, 0, s4.RGBA, e3.extRenderToTextureHalfFloat ? e3.isWebGL2 ? s4.HALF_FLOAT : e3.extTextureHalfFloat.HALF_FLOAT_OES : s4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                    }(e2, 0, t4, a3, n3, s3);
                  } else
                    r3.bindTexture(r3.TEXTURE_2D, a3.colorAttachment.get()), e2.bindFramebuffer.set(a3.framebuffer);
                }(n2, t2, o2, "globe" === t2.transform.projection.name ? 0.5 : 0.25), n2.clear({ color: e.Color.transparent });
                const c2 = t2.transform, h2 = "globe" === c2.projection.name, u2 = h2 ? ["PROJECTION_GLOBE_VIEW"] : null, _2 = h2 ? e.CullFaceMode.frontCCW : e.CullFaceMode.disabled, d2 = [e.mercatorXfromLng(c2.center.lng), e.mercatorYfromLat(c2.center.lat)];
                for (let p2 = 0; p2 < r2.length; p2++) {
                  const m2 = r2[p2];
                  if (i2.hasRenderableParent(m2))
                    continue;
                  const f2 = i2.getTile(m2), g2 = f2.getBucket(o2);
                  if (!g2 || g2.projection.name !== c2.projection.name)
                    continue;
                  const v2 = g2.programConfigurations.get(o2.id), x2 = t2.useProgram("heatmap", v2, u2), { zoom: y2 } = t2.transform;
                  t2.terrain && t2.terrain.setupElevationDraw(f2, x2), t2.prepareDrawProgram(n2, x2, m2.toUnwrapped());
                  const b2 = c2.projection.createInversionMatrix(c2, m2.canonical);
                  x2.draw(n2, s2.TRIANGLES, e.DepthMode.disabled, a2, l2, _2, $i(t2, m2, f2, b2, d2, y2, o2.paint.get("heatmap-intensity")), o2.id, g2.layoutVertexBuffer, g2.indexBuffer, g2.segments, o2.paint, t2.transform.zoom, v2, h2 ? [g2.globeExtVertexBuffer] : null);
                }
                n2.viewport.set([0, 0, t2.width, t2.height]);
              } else
                "translucent" === t2.renderPass && (t2.context.setColorMode(t2.colorModeForRenderPass()), function(t3, i3) {
                  const o3 = t3.context, r3 = o3.gl, n2 = i3.heatmapFbo;
                  if (!n2)
                    return;
                  o3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, n2.colorAttachment.get()), o3.activeTexture.set(r3.TEXTURE1);
                  let s2 = i3.colorRampTexture;
                  s2 || (s2 = i3.colorRampTexture = new e.Texture(o3, i3.colorRamp, r3.RGBA)), s2.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), t3.useProgram("heatmapTexture").draw(o3, r3.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e2, t4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
                }(t2, o2));
          }, line: function(t2, i2, o2, r2) {
            if ("translucent" !== t2.renderPass)
              return;
            const n2 = o2.paint.get("line-opacity"), s2 = o2.paint.get("line-width");
            if (0 === n2.constantOr(1) || 0 === s2.constantOr(1))
              return;
            const a2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), l2 = t2.colorModeForRenderPass(), c2 = t2.terrain && t2.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio, h2 = o2.paint.get("line-dasharray"), u2 = h2.constantOr(1), _2 = o2.layout.get("line-cap"), d2 = o2.paint.get("line-pattern"), p2 = d2.constantOr(1), m2 = o2.paint.get("line-gradient"), f2 = p2 ? "linePattern" : "line", g2 = t2.context, v2 = g2.gl, x2 = ((e2) => {
              const t3 = [];
              Qi(e2) && t3.push("RENDER_LINE_DASH"), e2.paint.get("line-gradient") && t3.push("RENDER_LINE_GRADIENT");
              const i3 = e2.paint.get("line-trim-offset");
              0 === i3[0] && 0 === i3[1] || t3.push("RENDER_LINE_TRIM_OFFSET");
              const o3 = e2.paint.get("line-pattern").constantOr(1), r3 = 1 !== e2.paint.get("line-opacity").constantOr(1);
              return !o3 && r3 && t3.push("RENDER_LINE_ALPHA_DISCARD"), t3;
            })(o2);
            let y2 = x2.includes("RENDER_LINE_ALPHA_DISCARD");
            t2.terrain && t2.terrain.clipOrMaskOverlapStencilType() && (y2 = false);
            for (const n3 of r2) {
              const r3 = i2.getTile(n3);
              if (p2 && !r3.patternsLoaded())
                continue;
              const s3 = r3.getBucket(o2);
              if (!s3)
                continue;
              t2.prepareDrawTile();
              const b2 = s3.programConfigurations.get(o2.id), w2 = t2.useProgram(f2, b2, x2), T2 = d2.constantOr(null);
              if (T2 && r3.imageAtlas) {
                const e2 = r3.imageAtlas.patternPositions[T2.toString()];
                e2 && b2.setConstantPatternPositions(e2);
              }
              const E2 = h2.constantOr(null), C2 = _2.constantOr(null);
              if (!p2 && E2 && C2 && r3.lineAtlas) {
                const e2 = r3.lineAtlas.getDash(E2, C2);
                e2 && b2.setConstantPatternPositions(e2);
              }
              let [M2, I2] = o2.paint.get("line-trim-offset");
              if ("round" === C2 || "square" === C2) {
                const e2 = 1;
                M2 !== I2 && (0 === M2 && (M2 -= e2), 1 === I2 && (I2 += e2));
              }
              const S2 = t2.terrain ? n3.projMatrix : null, D2 = p2 ? Yi(t2, r3, o2, S2, c2) : Hi(t2, r3, o2, S2, s3.lineClipsArray.length, c2, [M2, I2]);
              if (m2) {
                const r4 = s3.gradients[o2.id];
                let a3 = r4.texture;
                if (o2.gradientVersion !== r4.version) {
                  let l3 = 256;
                  if (o2.stepInterpolant) {
                    const o3 = i2.getSource().maxzoom, r5 = n3.canonical.z === o3 ? Math.ceil(1 << t2.transform.maxZoom - n3.canonical.z) : 1;
                    l3 = e.clamp(e.nextPowerOfTwo(s3.maxLineLength / e.EXTENT * 1024 * r5), 256, g2.maxTextureSize);
                  }
                  r4.gradient = e.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: r4.gradient || void 0, clips: s3.lineClipsArray }), r4.texture ? r4.texture.update(r4.gradient) : r4.texture = new e.Texture(g2, r4.gradient, v2.RGBA), r4.version = o2.gradientVersion, a3 = r4.texture;
                }
                g2.activeTexture.set(v2.TEXTURE1), a3.bind(o2.stepInterpolant ? v2.NEAREST : v2.LINEAR, v2.CLAMP_TO_EDGE);
              }
              u2 && (g2.activeTexture.set(v2.TEXTURE0), r3.lineAtlasTexture.bind(v2.LINEAR, v2.REPEAT), b2.updatePaintBuffers()), p2 && (g2.activeTexture.set(v2.TEXTURE0), r3.imageAtlasTexture.bind(v2.LINEAR, v2.CLAMP_TO_EDGE), b2.updatePaintBuffers()), t2.prepareDrawProgram(g2, w2, n3.toUnwrapped());
              const L2 = (i3) => {
                w2.draw(g2, v2.TRIANGLES, a2, i3, l2, e.CullFaceMode.disabled, D2, o2.id, s3.layoutVertexBuffer, s3.indexBuffer, s3.segments, o2.paint, t2.transform.zoom, b2, [s3.layoutVertexBuffer2]);
              };
              if (y2) {
                const i3 = t2.stencilModeForClipping(n3).ref;
                0 === i3 && t2.terrain && g2.clear({ stencil: 0 });
                const o3 = { func: v2.EQUAL, mask: 255 };
                D2.u_alpha_discard_threshold = 0.8, L2(new e.StencilMode(o3, i3, 255, v2.KEEP, v2.KEEP, v2.INVERT)), D2.u_alpha_discard_threshold = 0, L2(new e.StencilMode(o3, i3, 255, v2.KEEP, v2.KEEP, v2.KEEP));
              } else
                L2(t2.stencilModeForClipping(n3));
            }
            y2 && (t2.resetStencilClippingMasks(), t2.terrain && g2.clear({ stencil: 0 }));
          }, fill: function(t2, i2, o2, r2) {
            const n2 = o2.paint.get("fill-color"), s2 = o2.paint.get("fill-opacity");
            if (0 === s2.constantOr(1))
              return;
            const a2 = t2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = t2.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === n2.constantOr(e.Color.transparent).a && 1 === s2.constantOr(0) ? "opaque" : "translucent";
            if (t2.renderPass === c2) {
              const n3 = t2.depthModeForSublayer(1, "opaque" === t2.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);
              vo(t2, i2, o2, r2, n3, a2, false);
            }
            if ("translucent" === t2.renderPass && o2.paint.get("fill-antialias")) {
              const n3 = t2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly);
              vo(t2, i2, o2, r2, n3, a2, true);
            }
          }, "fill-extrusion": function(t2, i2, o2, r2) {
            const n2 = o2.paint.get("fill-extrusion-opacity");
            if (0 !== n2 && "translucent" === t2.renderPass) {
              const s2 = new e.DepthMode(t2.context.gl.LEQUAL, e.DepthMode.ReadWrite, t2.depthRangeFor3D);
              if (1 !== n2 || o2.paint.get("fill-extrusion-pattern").constantOr(1))
                xo(t2, i2, o2, r2, s2, e.StencilMode.disabled, e.ColorMode.disabled), xo(t2, i2, o2, r2, s2, t2.stencilModeFor3D(), t2.colorModeForRenderPass()), t2.resetStencilClippingMasks();
              else {
                const n3 = t2.colorModeForRenderPass();
                xo(t2, i2, o2, r2, s2, e.StencilMode.disabled, n3);
              }
            }
          }, hillshade: function(t2, i2, o2, r2) {
            if ("offscreen" !== t2.renderPass && "translucent" !== t2.renderPass)
              return;
            const n2 = t2.context, s2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), a2 = t2.colorModeForRenderPass(), l2 = t2.terrain && t2.terrain.renderingToTexture, [c2, h2] = "translucent" !== t2.renderPass || l2 ? [{}, r2] : t2.stencilConfigForOverlap(r2);
            for (const r3 of h2) {
              const n3 = i2.getTile(r3);
              if (n3.needsHillshadePrepare && "offscreen" === t2.renderPass)
                vi(t2, n3, o2, s2, e.StencilMode.disabled, a2);
              else if ("translucent" === t2.renderPass) {
                const e2 = l2 && t2.terrain ? t2.terrain.stencilModeForRTTOverlap(r3) : c2[r3.overscaledZ];
                fi(t2, r3, n3, o2, s2, e2, a2);
              }
            }
            n2.viewport.set([0, 0, t2.width, t2.height]), t2.resetStencilClippingMasks();
          }, raster: function(t2, i2, o2, r2, n2, s2) {
            if ("translucent" !== t2.renderPass)
              return;
            if (0 === o2.paint.get("raster-opacity"))
              return;
            if (!r2.length)
              return;
            const a2 = t2.context, l2 = a2.gl, c2 = i2.getSource(), h2 = t2.useProgram("raster"), u2 = t2.colorModeForRenderPass(), _2 = t2.terrain && t2.terrain.renderingToTexture, [d2, p2] = c2 instanceof Ae || _2 ? [{}, r2] : t2.stencilConfigForOverlap(r2), m2 = p2[p2.length - 1].overscaledZ, f2 = !t2.options.moving;
            for (const r3 of p2) {
              const n3 = _2 ? e.DepthMode.disabled : t2.depthModeForSublayer(r3.overscaledZ - m2, 1 === o2.paint.get("raster-opacity") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l2.LESS), p3 = r3.toUnwrapped(), g2 = i2.getTile(r3);
              if (_2 && (!g2 || !g2.hasData()))
                continue;
              const v2 = _2 ? r3.projMatrix : t2.transform.calculateProjMatrix(p3, f2), x2 = t2.terrain && _2 ? t2.terrain.stencilModeForRTTOverlap(r3) : d2[r3.overscaledZ], y2 = s2 ? 0 : o2.paint.get("raster-fade-duration");
              g2.registerFadeDuration(y2);
              const b2 = i2.findLoadedParent(r3, 0), w2 = Si(g2, b2, i2, t2.transform, y2);
              let T2, E2;
              t2.terrain && t2.terrain.prepareDrawTile();
              const C2 = "nearest" === o2.paint.get("raster-resampling") ? l2.NEAREST : l2.LINEAR;
              a2.activeTexture.set(l2.TEXTURE0), g2.texture.bind(C2, l2.CLAMP_TO_EDGE), a2.activeTexture.set(l2.TEXTURE1), b2 ? (b2.texture.bind(C2, l2.CLAMP_TO_EDGE), T2 = Math.pow(2, b2.tileID.overscaledZ - g2.tileID.overscaledZ), E2 = [g2.tileID.canonical.x * T2 % 1, g2.tileID.canonical.y * T2 % 1]) : g2.texture.bind(C2, l2.CLAMP_TO_EDGE), g2.texture.useMipmap && a2.extTextureFilterAnisotropic && t2.transform.pitch > 20 && l2.texParameterf(l2.TEXTURE_2D, a2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a2.extTextureFilterAnisotropicMax);
              const M2 = eo(v2, E2 || [0, 0], T2 || 1, w2, o2, c2 instanceof Ae ? c2.perspectiveTransform : [0, 0]);
              if (t2.prepareDrawProgram(a2, h2, p3), c2 instanceof Ae)
                c2.boundsBuffer && c2.boundsSegments && h2.draw(a2, l2.TRIANGLES, n3, e.StencilMode.disabled, u2, e.CullFaceMode.disabled, M2, o2.id, c2.boundsBuffer, t2.quadTriangleIndexBuffer, c2.boundsSegments);
              else {
                const { tileBoundsBuffer: i3, tileBoundsIndexBuffer: r4, tileBoundsSegments: s3 } = t2.getTileBoundsBuffers(g2);
                h2.draw(a2, l2.TRIANGLES, n3, x2, u2, e.CullFaceMode.disabled, M2, o2.id, i3, r4, s3);
              }
            }
            t2.resetStencilClippingMasks();
          }, background: function(t2, i2, o2, r2) {
            const n2 = o2.paint.get("background-color"), s2 = o2.paint.get("background-opacity");
            if (0 === s2)
              return;
            const a2 = t2.context, l2 = a2.gl, c2 = t2.transform, h2 = c2.tileSize, u2 = o2.paint.get("background-pattern");
            if (t2.isPatternMissing(u2))
              return;
            const _2 = !u2 && 1 === n2.a && 1 === s2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (t2.renderPass !== _2)
              return;
            const d2 = e.StencilMode.disabled, p2 = t2.depthModeForSublayer(0, "opaque" === _2 ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly), m2 = t2.colorModeForRenderPass(), f2 = t2.useProgram(u2 ? "backgroundPattern" : "background");
            let g2, v2 = r2;
            v2 || (g2 = t2.getBackgroundTiles(), v2 = Object.values(g2).map((e2) => e2.tileID)), u2 && (a2.activeTexture.set(l2.TEXTURE0), t2.imageManager.bind(t2.context));
            for (const _3 of v2) {
              const v3 = _3.toUnwrapped(), x2 = r2 ? _3.projMatrix : t2.transform.calculateProjMatrix(v3);
              t2.prepareDrawTile();
              const y2 = i2 ? i2.getTile(_3) : g2 ? g2[_3.key] : new e.Tile(_3, h2, c2.zoom, t2), b2 = u2 ? ao(x2, s2, t2, u2, { tileID: _3, tileSize: h2 }) : so(x2, s2, n2);
              t2.prepareDrawProgram(a2, f2, v3);
              const { tileBoundsBuffer: w2, tileBoundsIndexBuffer: T2, tileBoundsSegments: E2 } = t2.getTileBoundsBuffers(y2);
              f2.draw(a2, l2.TRIANGLES, p2, d2, m2, e.CullFaceMode.disabled, b2, o2.id, w2, T2, E2);
            }
          }, sky: function(t2, i2, o2) {
            const r2 = t2.transform, n2 = "mercator" === r2.projection.name || "globe" === r2.projection.name ? 1 : e.smoothstep(7, 8, r2.zoom), s2 = o2.paint.get("sky-opacity") * n2;
            if (0 === s2)
              return;
            const a2 = t2.context, l2 = o2.paint.get("sky-type"), c2 = new e.DepthMode(a2.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), h2 = t2.frameCounter / 1e3 % 1;
            "atmosphere" === l2 ? "offscreen" === t2.renderPass ? o2.needsSkyboxCapture(t2) && (function(t3, i3, o3, r3) {
              const n3 = t3.context, s3 = n3.gl;
              let a3 = i3.skyboxFbo;
              if (!a3) {
                a3 = i3.skyboxFbo = n3.createFramebuffer(32, 32, false), i3.skyboxGeometry = new Po(n3), i3.skyboxTexture = n3.gl.createTexture(), s3.bindTexture(s3.TEXTURE_CUBE_MAP, i3.skyboxTexture), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_WRAP_S, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_WRAP_T, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_MIN_FILTER, s3.LINEAR), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_MAG_FILTER, s3.LINEAR);
                for (let e2 = 0; e2 < 6; ++e2)
                  s3.texImage2D(s3.TEXTURE_CUBE_MAP_POSITIVE_X + e2, 0, s3.RGBA, 32, 32, 0, s3.RGBA, s3.UNSIGNED_BYTE, null);
              }
              n3.bindFramebuffer.set(a3.framebuffer), n3.viewport.set([0, 0, 32, 32]);
              const l3 = i3.getCenter(t3, true), c3 = t3.useProgram("skyboxCapture"), h3 = new Float64Array(16);
              e.identity(h3), e.rotateY(h3, h3, 0.5 * -Math.PI), Ro(n3, i3, c3, h3, l3, 0), e.identity(h3), e.rotateY(h3, h3, 0.5 * Math.PI), Ro(n3, i3, c3, h3, l3, 1), e.identity(h3), e.rotateX(h3, h3, 0.5 * -Math.PI), Ro(n3, i3, c3, h3, l3, 2), e.identity(h3), e.rotateX(h3, h3, 0.5 * Math.PI), Ro(n3, i3, c3, h3, l3, 3), e.identity(h3), Ro(n3, i3, c3, h3, l3, 4), e.identity(h3), e.rotateY(h3, h3, Math.PI), Ro(n3, i3, c3, h3, l3, 5), n3.viewport.set([0, 0, t3.width, t3.height]);
            }(t2, o2), o2.markSkyboxValid(t2)) : "sky" === t2.renderPass && function(t3, i3, o3, r3, n3) {
              const s3 = t3.context, a3 = s3.gl, l3 = t3.transform, c3 = t3.useProgram("skybox");
              s3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_CUBE_MAP, i3.skyboxTexture);
              const h3 = ((e2, t4, i4, o4, r4) => ({ u_matrix: e2, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), 0, r3, n3);
              t3.prepareDrawProgram(s3, c3), c3.draw(s3, a3.TRIANGLES, o3, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.backCW, h3, "skybox", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
            }(t2, o2, c2, s2, h2) : "gradient" === l2 && "sky" === t2.renderPass && function(t3, i3, o3, r3, n3) {
              const s3 = t3.context, a3 = s3.gl, l3 = t3.transform, c3 = t3.useProgram("skyboxGradient");
              i3.skyboxGeometry || (i3.skyboxGeometry = new Po(s3)), s3.activeTexture.set(a3.TEXTURE0);
              let h3 = i3.colorRampTexture;
              h3 || (h3 = i3.colorRampTexture = new e.Texture(s3, i3.colorRamp, a3.RGBA)), h3.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
              const u2 = ((t4, i4, o4, r4, n4) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e.degToRad(o4), u_opacity: r4, u_temporal_offset: n4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), r3, n3);
              t3.prepareDrawProgram(s3, c3), c3.draw(s3, a3.TRIANGLES, o3, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.backCW, u2, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
            }(t2, o2, c2, s2, h2);
          }, debug: function(e2, t2, i2) {
            for (let o2 = 0; o2 < i2.length; o2++)
              Mo(e2, t2, i2[o2]);
          }, custom: function(t2, i2, o2, r2) {
            const n2 = t2.context, s2 = o2.implementation;
            if (!t2.transform.projection.unsupportedLayers || !t2.transform.projection.unsupportedLayers.includes("custom") || t2.terrain && (t2.terrain.renderingToTexture || "offscreen" === t2.renderPass) && o2.isLayerDraped()) {
              if ("offscreen" === t2.renderPass) {
                const i3 = s2.prerender;
                if (i3) {
                  if (t2.setCustomLayerDefaults(), n2.setColorMode(t2.colorModeForRenderPass()), "globe" === t2.transform.projection.name) {
                    const o3 = t2.transform.pointMerc;
                    i3.call(s2, n2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t2.transform.zoom), [o3.x, o3.y], t2.transform.pixelsPerMeterRatio);
                  } else
                    i3.call(s2, n2.gl, t2.transform.customLayerMatrix());
                  n2.setDirty(), t2.setBaseState();
                }
              } else if ("translucent" === t2.renderPass) {
                if (t2.terrain && t2.terrain.renderingToTexture) {
                  const i4 = s2.renderToTile;
                  if (i4) {
                    const o3 = r2[0].canonical, a2 = new e.MercatorCoordinate(o3.x + r2[0].wrap * (1 << o3.z), o3.y, o3.z);
                    n2.setDepthMode(e.DepthMode.disabled), n2.setStencilMode(e.StencilMode.disabled), n2.setColorMode(t2.colorModeForRenderPass()), t2.setCustomLayerDefaults(), i4.call(s2, n2.gl, a2), n2.setDirty(), t2.setBaseState();
                  }
                  return;
                }
                t2.setCustomLayerDefaults(), n2.setColorMode(t2.colorModeForRenderPass()), n2.setStencilMode(e.StencilMode.disabled);
                const i3 = "3d" === s2.renderingMode ? new e.DepthMode(t2.context.gl.LEQUAL, e.DepthMode.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, e.DepthMode.ReadOnly);
                if (n2.setDepthMode(i3), "globe" === t2.transform.projection.name) {
                  const i4 = t2.transform.pointMerc;
                  s2.render(n2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t2.transform.zoom), [i4.x, i4.y], t2.transform.pixelsPerMeterRatio);
                } else
                  s2.render(n2.gl, t2.transform.customLayerMatrix());
                n2.setDirty(), t2.setBaseState(), n2.bindFramebuffer.set(null);
              }
            } else
              e.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
          } };
          class Fo {
            constructor(t2, i2, o2 = false) {
              this.context = new Me(t2, o2), this.transform = i2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new qt(), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
            }
            updateTerrain(e2, t2) {
              const i2 = !!e2 && !!e2.terrain && this.transform.projection.supportsTerrain;
              if (!(i2 || this._terrain && this._terrain.enabled))
                return;
              this._terrain || (this._terrain = new zi(this, e2));
              const o2 = this._terrain;
              this.transform.elevation = i2 ? o2 : null, o2.update(e2, this.transform, t2);
            }
            _updateFog(e2) {
              const t2 = e2.fog;
              if (!t2 || "globe" === this.transform.projection.name || t2.getOpacity(this.transform.pitch) < 1 || t2.properties.get("horizon-blend") < 0.03)
                return void (this.transform.fogCullDistSq = null);
              const [i2, o2] = t2.getFovAdjustedRange(this.transform._fov);
              if (i2 > o2)
                return void (this.transform.fogCullDistSq = null);
              const r2 = i2 + 0.78 * (o2 - i2);
              this.transform.fogCullDistSq = r2 * r2;
            }
            get terrain() {
              return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
            }
            resize(t2, i2) {
              if (this.width = t2 * e.exported.devicePixelRatio, this.height = i2 * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
                for (const e2 of this.style.order)
                  this.style._layers[e2].resize();
            }
            setup() {
              const t2 = this.context, i2 = new e.StructArrayLayout2i4();
              i2.emplaceBack(0, 0), i2.emplaceBack(e.EXTENT, 0), i2.emplaceBack(0, e.EXTENT), i2.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t2.createVertexBuffer(i2, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
              const o2 = new e.StructArrayLayout2i4();
              o2.emplaceBack(0, 0), o2.emplaceBack(e.EXTENT, 0), o2.emplaceBack(0, e.EXTENT), o2.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t2.createVertexBuffer(o2, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);
              const r2 = new e.StructArrayLayout2i4();
              r2.emplaceBack(-1, -1), r2.emplaceBack(1, -1), r2.emplaceBack(-1, 1), r2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(r2, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
              const n2 = new e.StructArrayLayout4i8();
              n2.emplaceBack(0, 0, 0, 0), n2.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), n2.emplaceBack(0, e.EXTENT, 0, e.EXTENT), n2.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t2.createVertexBuffer(n2, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
              const s2 = new e.StructArrayLayout3ui6();
              s2.emplaceBack(0, 1, 2), s2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(s2);
              const a2 = new e.StructArrayLayout1ui2();
              for (const e2 of [0, 1, 3, 2, 0])
                a2.emplaceBack(e2);
              this.debugIndexBuffer = t2.createIndexBuffer(a2), this.emptyTexture = new e.Texture(t2, new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t2.gl.RGBA), this.identityMat = e.create();
              const l2 = this.context.gl;
              this.stencilClearMode = new e.StencilMode({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(e.window.performance.now()), this.atmosphereBuffer = new Bo(this.context);
            }
            getMercatorTileBoundsBuffers() {
              return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
            }
            getTileBoundsBuffers(e2) {
              return e2._makeTileBoundsBuffers(this.context, this.transform.projection), e2._tileBoundsBuffer ? { tileBoundsBuffer: e2._tileBoundsBuffer, tileBoundsIndexBuffer: e2._tileBoundsIndexBuffer, tileBoundsSegments: e2._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
            }
            clearStencil() {
              const t2 = this.context, i2 = t2.gl;
              this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t2, i2.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
              this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
            }
            _renderTileClippingMasks(t2, i2, o2) {
              if (!i2 || this.currentStencilSource === i2.id || !t2.isTileClipped() || !o2 || 0 === o2.length)
                return;
              if (this._tileClippingMaskIDs && !this.terrain) {
                let e2 = false;
                for (const t3 of o2)
                  if (void 0 === this._tileClippingMaskIDs[t3.key]) {
                    e2 = true;
                    break;
                  }
                if (!e2)
                  return;
              }
              this.currentStencilSource = i2.id;
              const r2 = this.context, n2 = r2.gl;
              this.nextStencilID + o2.length > 256 && this.clearStencil(), r2.setColorMode(e.ColorMode.disabled), r2.setDepthMode(e.DepthMode.disabled);
              const s2 = this.useProgram("clippingMask");
              this._tileClippingMaskIDs = {};
              for (const t3 of o2) {
                const o3 = i2.getTile(t3), a2 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, { tileBoundsBuffer: l2, tileBoundsIndexBuffer: c2, tileBoundsSegments: h2 } = this.getTileBoundsBuffers(o3);
                s2.draw(r2, n2.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n2.ALWAYS, mask: 0 }, a2, 255, n2.KEEP, n2.KEEP, n2.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(t3.projMatrix), "$clipping", l2, c2, h2);
              }
            }
            stencilModeFor3D() {
              this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
              const t2 = this.nextStencilID++, i2 = this.context.gl;
              return new e.StencilMode({ func: i2.NOTEQUAL, mask: 255 }, t2, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
            }
            stencilModeForClipping(t2) {
              if (this.terrain)
                return this.terrain.stencilModeForRTTOverlap(t2);
              const i2 = this.context.gl;
              return new e.StencilMode({ func: i2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, i2.KEEP, i2.KEEP, i2.REPLACE);
            }
            stencilConfigForOverlap(t2) {
              const i2 = this.context.gl, o2 = t2.sort((e2, t3) => t3.overscaledZ - e2.overscaledZ), r2 = o2[o2.length - 1].overscaledZ, n2 = o2[0].overscaledZ - r2 + 1;
              if (n2 > 1) {
                this.currentStencilSource = void 0, this.nextStencilID + n2 > 256 && this.clearStencil();
                const t3 = {};
                for (let o3 = 0; o3 < n2; o3++)
                  t3[o3 + r2] = new e.StencilMode({ func: i2.GEQUAL, mask: 255 }, o3 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
                return this.nextStencilID += n2, [t3, o2];
              }
              return [{ [r2]: e.StencilMode.disabled }, o2];
            }
            colorModeForRenderPass() {
              const t2 = this.context.gl;
              if (this._showOverdrawInspector) {
                const i2 = 1 / 8;
                return new e.ColorMode([t2.CONSTANT_COLOR, t2.ONE], new e.Color(i2, i2, i2, 0), [true, true, true, true]);
              }
              return "opaque" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended;
            }
            depthModeForSublayer(t2, i2, o2) {
              if (!this.opaquePassEnabledForLayer())
                return e.DepthMode.disabled;
              const r2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
              return new e.DepthMode(o2 || this.context.gl.LEQUAL, i2, [r2, r2]);
            }
            opaquePassEnabledForLayer() {
              return this.currentLayer < this.opaquePassCutoff;
            }
            render(t2, i2) {
              this.style = t2, this.options = i2, this.imageManager = t2.imageManager, this.glyphManager = t2.glyphManager, this.symbolFadeChange = t2.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();
              const o2 = this.style.order, r2 = this.style._sourceCaches;
              for (const e2 in r2) {
                const t3 = r2[e2];
                t3.used && t3.prepare(this.context);
              }
              const n2 = {}, s2 = {}, a2 = {};
              for (const e2 in r2) {
                const t3 = r2[e2];
                n2[e2] = t3.getVisibleCoordinates(), s2[e2] = n2[e2].slice().reverse(), a2[e2] = t3.getVisibleCoordinates(true).reverse();
              }
              this.opaquePassCutoff = 1 / 0;
              for (let e2 = 0; e2 < o2.length; e2++)
                if (this.style._layers[o2[e2]].is3D()) {
                  this.opaquePassCutoff = e2;
                  break;
                }
              if (this.terrain && (this.terrain.updateTileBinding(a2), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), !e.isMapAuthenticated(this.context.gl))
                return;
              this.renderPass = "offscreen";
              for (const e2 of o2) {
                const i3 = this.style._layers[e2], o3 = t2._getLayerSourceCache(i3);
                if (!i3.hasOffscreenPass() || i3.isHidden(this.transform.zoom))
                  continue;
                const r3 = o3 ? s2[o3.id] : void 0;
                ("custom" === i3.type || i3.isSky() || r3 && r3.length) && this.renderLayer(this, o3, i3, r3);
              }
              this.depthRangeFor3D = [0, 1 - (t2.order.length + 2) * this.numSublayers * this.depthEpsilon];
              const l2 = this.terrain;
              if (l2 && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && l2.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({ color: i2.showOverdrawInspector ? e.Color.black : e.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", !this.terrain)
                for (this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                  const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
                  if (e2.isSky())
                    continue;
                  const r3 = i3 ? s2[i3.id] : void 0;
                  this._renderTileClippingMasks(e2, i3, r3), this.renderLayer(this, i3, e2, r3);
                }
              if (this.style.fog && this.transform.projection.supportsFog && function(t3, i3) {
                const o3 = t3.context, r3 = o3.gl, n3 = t3.transform, s3 = new e.DepthMode(r3.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), a3 = t3.useProgram("globeAtmosphere", null, "globe" === n3.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]), l3 = e.globeToMercatorTransition(n3.zoom), c2 = i3.properties.get("color").toArray01(), h2 = i3.properties.get("high-color").toArray01(), u2 = i3.properties.get("space-color").toArray01PremultipliedAlpha(), _2 = e.identity$1([]);
                e.rotateY$1(_2, _2, -e.degToRad(n3._center.lng)), e.rotateX$1(_2, _2, e.degToRad(n3._center.lat)), e.rotateZ$1(_2, _2, n3.angle), e.rotateX$1(_2, _2, -n3._pitch);
                const d2 = e.fromQuat(new Float32Array(16), _2), p2 = e.mapValue(i3.properties.get("star-intensity"), 0, 1, 0, 0.25), m2 = 5e-4, f2 = e.mapValue(i3.properties.get("horizon-blend"), 0, 1, m2, 0.25), g2 = e.globeUseCustomAntiAliasing(t3, o3, n3) && f2 === m2 ? n3.worldSize / (2 * Math.PI * 1.025) - 1 : n3.globeRadius, v2 = t3.frameCounter / 1e3 % 1, x2 = e.length(n3.globeCenterInViewSpace), y2 = Math.sqrt(Math.pow(x2, 2) - Math.pow(g2, 2)), b2 = Math.acos(y2 / x2), w2 = ((t4, i4, o4, r4, n4, s4, a4, l4, c3, h3, u3, _3, d3, p3) => ({ u_frustum_tl: t4, u_frustum_tr: i4, u_frustum_br: o4, u_frustum_bl: r4, u_horizon: n4, u_transition: s4, u_fadeout_range: a4, u_color: l4, u_high_color: c3, u_space_color: h3, u_star_intensity: u3, u_star_size: 5 * e.exported.devicePixelRatio, u_star_density: 0, u_temporal_offset: _3, u_horizon_angle: d3, u_rotation_matrix: p3 }))(n3.frustumCorners.TL, n3.frustumCorners.TR, n3.frustumCorners.BR, n3.frustumCorners.BL, n3.frustumCorners.horizon, l3, f2, c2, h2, u2, p2, v2, b2, d2);
                t3.prepareDrawProgram(o3, a3);
                const T2 = t3.atmosphereBuffer;
                T2 && a3.draw(o3, r3.TRIANGLES, s3, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, w2, "skybox", T2.vertexBuffer, T2.indexBuffer, T2.segments);
              }(this, this.style.fog), this.renderPass = "sky", (e.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible())
                for (this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
                  const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
                  e2.isSky() && this.renderLayer(this, i3, e2, i3 ? s2[i3.id] : void 0);
                }
              for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; ) {
                const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
                if (e2.isSky()) {
                  ++this.currentLayer;
                  continue;
                }
                if (this.terrain && this.style.isLayerDraped(e2)) {
                  if (e2.isHidden(this.transform.zoom)) {
                    ++this.currentLayer;
                    continue;
                  }
                  this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                  continue;
                }
                const r3 = i3 ? ("symbol" === e2.type ? a2 : s2)[i3.id] : void 0;
                this._renderTileClippingMasks(e2, i3, i3 ? n2[i3.id] : void 0), this.renderLayer(this, i3, e2, r3), ++this.currentLayer;
              }
              if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                let i3 = null;
                e.values(this.style._layers).forEach((e2) => {
                  const o3 = t2._getLayerSourceCache(e2);
                  o3 && !e2.isHidden(this.transform.zoom) && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
                }), i3 && this.options.showTileBoundaries && ko.debug(this, i3, i3.getVisibleCoordinates());
              }
              this.options.showPadding && function(e2) {
                const t3 = e2.transform.padding;
                Io(e2, e2.transform.height - (t3.top || 0), 3, bo), Io(e2, t3.bottom || 0, 3, wo), So(e2, t3.left || 0, 3, To), So(e2, e2.transform.width - (t3.right || 0), 3, Eo);
                const i3 = e2.transform.centerPoint;
                !function(e3, t4, i4, o3) {
                  Do(e3, t4 - 1, i4 - 10, 2, 20, o3), Do(e3, t4 - 10, i4 - 1, 20, 2, o3);
                }(e2, i3.x, e2.transform.height - i3.y, Co);
              }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());
            }
            renderLayer(e2, t2, i2, o2) {
              i2.isHidden(this.transform.zoom) || ("background" === i2.type || "sky" === i2.type || "custom" === i2.type || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), (!e2.transform.projection.unsupportedLayers || !e2.transform.projection.unsupportedLayers.includes(i2.type) || e2.terrain && "custom" === i2.type) && ko[i2.type](e2, t2, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(e2) {
              if (!this.options.gpuTiming)
                return;
              const t2 = this.context.extTimerQuery;
              let i2 = this.gpuTimers[e2.id];
              i2 || (i2 = this.gpuTimers[e2.id] = { calls: 0, cpuTime: 0, query: t2.createQueryEXT() }), i2.calls++, t2.beginQueryEXT(t2.TIME_ELAPSED_EXT, i2.query);
            }
            gpuTimingDeferredRenderStart() {
              if (this.options.gpuTimingDeferredRender) {
                const e2 = this.context.extTimerQuery, t2 = e2.createQueryEXT();
                this.deferredRenderGpuTimeQueries.push(t2), e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, t2);
              }
            }
            gpuTimingDeferredRenderEnd() {
              if (!this.options.gpuTimingDeferredRender)
                return;
              const e2 = this.context.extTimerQuery;
              e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
              if (!this.options.gpuTiming)
                return;
              const e2 = this.context.extTimerQuery;
              e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
              const e2 = this.gpuTimers;
              return this.gpuTimers = {}, e2;
            }
            collectDeferredRenderGpuQueries() {
              const e2 = this.deferredRenderGpuTimeQueries;
              return this.deferredRenderGpuTimeQueries = [], e2;
            }
            queryGpuTimers(e2) {
              const t2 = {};
              for (const i2 in e2) {
                const o2 = e2[i2], r2 = this.context.extTimerQuery, n2 = r2.getQueryObjectEXT(o2.query, r2.QUERY_RESULT_EXT) / 1e6;
                r2.deleteQueryEXT(o2.query), t2[i2] = n2;
              }
              return t2;
            }
            queryGpuTimeDeferredRender(e2) {
              if (!this.options.gpuTimingDeferredRender)
                return 0;
              const t2 = this.context.extTimerQuery;
              let i2 = 0;
              for (const o2 of e2)
                i2 += t2.getQueryObjectEXT(o2, t2.QUERY_RESULT_EXT) / 1e6, t2.deleteQueryEXT(o2);
              return i2;
            }
            translatePosMatrix(t2, i2, o2, r2, n2) {
              if (!o2[0] && !o2[1])
                return t2;
              const s2 = n2 ? "map" === r2 ? this.transform.angle : 0 : "viewport" === r2 ? -this.transform.angle : 0;
              if (s2) {
                const e2 = Math.sin(s2), t3 = Math.cos(s2);
                o2 = [o2[0] * t3 - o2[1] * e2, o2[0] * e2 + o2[1] * t3];
              }
              const a2 = [n2 ? o2[0] : P(i2, o2[0], this.transform.zoom), n2 ? o2[1] : P(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
              return e.translate(l2, t2, a2), l2;
            }
            saveTileTexture(e2) {
              const t2 = this._tileTextures[e2.size[0]];
              t2 ? t2.push(e2) : this._tileTextures[e2.size[0]] = [e2];
            }
            getTileTexture(e2) {
              const t2 = this._tileTextures[e2];
              return t2 && t2.length > 0 ? t2.pop() : null;
            }
            isPatternMissing(e2) {
              return null === e2 || void 0 !== e2 && !this.imageManager.getPattern(e2.toString());
            }
            terrainRenderModeElevated() {
              return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
            }
            currentGlobalDefines() {
              const e2 = this.terrain && this.terrain.renderingToTexture, t2 = this.terrain && 0 === this.terrain.exaggeration(), i2 = this.style && this.style.fog, o2 = [];
              return this.terrainRenderModeElevated() && o2.push("TERRAIN"), "globe" === this.transform.projection.name && o2.push("GLOBE"), t2 && o2.push("ZERO_EXAGGERATION"), i2 && !e2 && 0 !== i2.getOpacity(this.transform.pitch) && o2.push("FOG"), e2 && o2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o2.push("OVERDRAW_INSPECTOR"), o2;
            }
            useProgram(e2, t2, i2) {
              this.cache = this.cache || {};
              const o2 = i2 || [], r2 = this.currentGlobalDefines().concat(o2), n2 = Pi.cacheKey(ui[e2], e2, r2, t2);
              return this.cache[n2] || (this.cache[n2] = new Pi(this.context, e2, ui[e2], t2, lo[e2], r2)), this.cache[n2];
            }
            setCustomLayerDefaults() {
              this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
              const e2 = this.context.gl;
              this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
              null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
              this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
            }
            prepareDrawTile() {
              this.terrain && this.terrain.prepareDrawTile();
            }
            prepareDrawProgram(t2, i2, o2) {
              if (this.terrain && this.terrain.renderingToTexture)
                return;
              const r2 = this.style.fog;
              if (r2) {
                const n2 = r2.getOpacity(this.transform.pitch), s2 = ((t3, i3, o3, r3, n3, s3, a2, l2, c2, h2, u2) => {
                  const _2 = t3.transform, d2 = i3.properties.get("color").toArray01();
                  d2[3] = r3;
                  const p2 = t3.frameCounter / 1e3 % 1;
                  return { u_fog_matrix: o3 ? _2.calculateFogTileMatrix(o3) : t3.identityMat, u_fog_range: i3.getFovAdjustedRange(_2._fov), u_fog_color: d2, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_temporal_offset: p2, u_frustum_tl: n3, u_frustum_tr: s3, u_frustum_br: a2, u_frustum_bl: l2, u_globe_pos: c2, u_globe_radius: h2, u_viewport: u2, u_globe_transition: e.globeToMercatorTransition(_2.zoom), u_is_globe: +("globe" === _2.projection.name) };
                })(this, r2, o2, n2, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.exported.devicePixelRatio, this.transform.height * e.exported.devicePixelRatio]);
                i2.setFogUniformValues(t2, s2);
              }
            }
            setTileLoadedFlag(e2) {
              this.tileLoaded = e2;
            }
            saveCanvasCopy() {
              const e2 = this.canvasCopy();
              e2 && (this.frameCopies.push(e2), this.tileLoaded = false);
            }
            canvasCopy() {
              const e2 = this.context.gl, t2 = e2.createTexture();
              return e2.bindTexture(e2.TEXTURE_2D, t2), e2.copyTexImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight, 0), t2;
            }
            getCanvasCopiesAndTimestamps() {
              return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
            }
            averageElevationNeedsEasing() {
              if (!this.transform._elevation)
                return false;
              const e2 = this.style && this.style.fog;
              return !!e2 && 0 !== e2.getOpacity(this.transform.pitch);
            }
            getBackgroundTiles() {
              const t2 = this._backgroundTiles, i2 = this._backgroundTiles = {}, o2 = this.transform.coveringTiles({ tileSize: 512 });
              for (const r2 of o2)
                i2[r2.key] = t2[r2.key] || new e.Tile(r2, 512, this.transform.tileZoom, this);
              return i2;
            }
            clearBackgroundTiles() {
              this._backgroundTiles = {};
            }
          }
          class Uo {
            constructor(e2 = 0, t2 = 0, i2 = 0, o2 = 0) {
              if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
                throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
              this.top = e2, this.bottom = t2, this.left = i2, this.right = o2;
            }
            interpolate(t2, i2, o2) {
              return null != i2.top && null != t2.top && (this.top = e.number(t2.top, i2.top, o2)), null != i2.bottom && null != t2.bottom && (this.bottom = e.number(t2.bottom, i2.bottom, o2)), null != i2.left && null != t2.left && (this.left = e.number(t2.left, i2.left, o2)), null != i2.right && null != t2.right && (this.right = e.number(t2.right, i2.right, o2)), this;
            }
            getCenter(t2, i2) {
              const o2 = e.clamp((this.left + t2 - this.right) / 2, 0, t2), r2 = e.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
              return new e.pointGeometry(o2, r2);
            }
            equals(e2) {
              return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
            }
            clone() {
              return new Uo(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
              return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
          }
          function No(t2, i2) {
            const o2 = e.getColumn(t2, 3);
            e.fromQuat(t2, i2), e.setColumn(t2, 3, o2);
          }
          function Go(t2, i2) {
            const o2 = e.identity$1([]);
            return e.rotateZ$1(o2, o2, -i2), e.rotateX$1(o2, o2, -t2), o2;
          }
          function jo(t2, i2) {
            const o2 = [t2[0], t2[1], 0], r2 = [i2[0], i2[1], 0];
            if (e.length(o2) >= 1e-15) {
              const t3 = e.normalize([], o2);
              e.scale$2(r2, t3, e.dot(r2, t3)), i2[0] = r2[0], i2[1] = r2[1];
            }
            const n2 = e.cross([], i2, t2);
            if (e.len(n2) < 1e-15)
              return null;
            const s2 = Math.atan2(-n2[1], n2[0]);
            return Go(Math.atan2(Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]), -t2[2]), s2);
          }
          class Zo {
            constructor(e2, t2) {
              this.position = e2, this.orientation = t2;
            }
            get position() {
              return this._position;
            }
            set position(t2) {
              if (t2) {
                const i2 = t2 instanceof e.MercatorCoordinate ? t2 : new e.MercatorCoordinate(t2[0], t2[1], t2[2]);
                this._renderWorldCopies && (i2.x = e.wrap(i2.x, 0, 1)), this._position = i2;
              } else
                this._position = null;
            }
            lookAtPoint(t2, i2) {
              if (this.orientation = null, !this.position)
                return;
              const o2 = this.position, r2 = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t2)) : 0, n2 = e.MercatorCoordinate.fromLngLat(t2, r2), s2 = [n2.x - o2.x, n2.y - o2.y, n2.z - o2.z];
              i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = jo(s2, i2);
            }
            setPitchBearing(t2, i2) {
              this.orientation = Go(e.degToRad(t2), e.degToRad(-i2));
            }
          }
          class Vo {
            constructor(t2, i2) {
              this._transform = e.identity([]), this.orientation = i2, this.position = t2;
            }
            get mercatorPosition() {
              const t2 = this.position;
              return new e.MercatorCoordinate(t2[0], t2[1], t2[2]);
            }
            get position() {
              const t2 = e.getColumn(this._transform, 3);
              return [t2[0], t2[1], t2[2]];
            }
            set position(t2) {
              var i2;
              t2 && e.setColumn(this._transform, 3, [(i2 = t2)[0], i2[1], i2[2], 1]);
            }
            get orientation() {
              return this._orientation;
            }
            set orientation(t2) {
              this._orientation = t2 || e.identity$1([]), t2 && No(this._transform, this._orientation);
            }
            getPitchBearing() {
              const e2 = this.forward(), t2 = this.right();
              return { bearing: Math.atan2(-t2[1], t2[0]), pitch: Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]) };
            }
            setPitchBearing(e2, t2) {
              this._orientation = Go(e2, t2), No(this._transform, this._orientation);
            }
            forward() {
              const t2 = e.getColumn(this._transform, 2);
              return [-t2[0], -t2[1], -t2[2]];
            }
            up() {
              const t2 = e.getColumn(this._transform, 1);
              return [-t2[0], -t2[1], -t2[2]];
            }
            right() {
              const t2 = e.getColumn(this._transform, 0);
              return [t2[0], t2[1], t2[2]];
            }
            getCameraToWorld(t2, i2) {
              const o2 = new Float64Array(16);
              return e.invert(o2, this.getWorldToCamera(t2, i2)), o2;
            }
            getWorldToCameraPosition(t2, i2, o2) {
              const r2 = this.position;
              e.scale$2(r2, r2, -t2);
              const n2 = new Float64Array(16);
              return e.fromScaling(n2, [o2, o2, o2]), e.translate(n2, n2, r2), n2[10] *= i2, n2;
            }
            getWorldToCamera(t2, i2) {
              const o2 = new Float64Array(16), r2 = new Float64Array(4), n2 = this.position;
              return e.conjugate(r2, this._orientation), e.scale$2(n2, n2, -t2), e.fromQuat(o2, r2), e.translate(o2, o2, n2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
            }
            getCameraToClipPerspective(t2, i2, o2, r2) {
              const n2 = new Float64Array(16);
              return e.perspective(n2, t2, i2, o2, r2), n2;
            }
            getDistanceToElevation(t2, i2 = false) {
              const o2 = 0 === t2 ? 0 : e.mercatorZfromAltitude(t2, i2 ? e.latFromMercatorY(this.position[1]) : this.position[1]), r2 = this.forward();
              return (o2 - this.position[2]) / r2[2];
            }
            clone() {
              return new Vo([...this.position], [...this.orientation]);
            }
          }
          function Wo(t2, i2) {
            const o2 = qo(t2.projection, t2.zoom, t2.width, t2.height), r2 = function(t3, i3, o3, r3, n3) {
              const s2 = new e.LngLat(o3.lng - 180 * $o, o3.lat), a2 = new e.LngLat(o3.lng + 180 * $o, o3.lat), l2 = t3.project(s2.lng, s2.lat), c2 = t3.project(a2.lng, a2.lat), h2 = -Math.atan2(c2.y - l2.y, c2.x - l2.x), u2 = e.MercatorCoordinate.fromLngLat(o3);
              u2.y = e.clamp(u2.y, -0.999975, 0.999975);
              const _2 = u2.toLngLat(), d2 = t3.project(_2.lng, _2.lat), p2 = e.MercatorCoordinate.fromLngLat(_2);
              p2.x += $o;
              const m2 = p2.toLngLat(), f2 = t3.project(m2.lng, m2.lat), g2 = Yo(f2.x - d2.x, f2.y - d2.y, h2), v2 = e.MercatorCoordinate.fromLngLat(_2);
              v2.y += $o;
              const x2 = v2.toLngLat(), y2 = t3.project(x2.lng, x2.lat), b2 = Yo(y2.x - d2.x, y2.y - d2.y, h2), w2 = Math.abs(g2.x) / Math.abs(b2.y), T2 = e.identity([]);
              e.rotateZ(T2, T2, -h2 * (1 - (n3 ? 0 : r3)));
              const E2 = e.identity([]);
              return e.scale(E2, E2, [1, 1 - (1 - w2) * r3, 1]), E2[4] = -b2.x / b2.y * r3, e.rotateZ(E2, E2, h2), e.multiply(E2, T2, E2), E2;
            }(t2.projection, 0, t2.center, o2, i2), n2 = Xo(t2);
            return e.scale(r2, r2, [n2, n2, 1]), r2;
          }
          function Xo(t2) {
            const i2 = t2.projection, o2 = qo(t2.projection, t2.zoom, t2.width, t2.height), r2 = Ho(i2, t2.center), n2 = Ho(i2, e.LngLat.convert(i2.center));
            return Math.pow(2, r2 * o2 + (1 - o2) * n2);
          }
          function qo(t2, i2, o2, r2, n2 = 1 / 0) {
            const s2 = t2.range;
            if (!s2)
              return 0;
            const a2 = Math.min(n2, Math.max(o2, r2)), l2 = Math.log(a2 / 1024) / Math.LN2;
            return e.smoothstep(s2[0] + l2, s2[1] + l2, i2);
          }
          const $o = 1 / 4e4;
          function Ho(t2, i2) {
            const o2 = e.clamp(i2.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), r2 = new e.LngLat(i2.lng - 180 * $o, o2), n2 = new e.LngLat(i2.lng + 180 * $o, o2), s2 = t2.project(r2.lng, o2), a2 = t2.project(n2.lng, o2), l2 = e.MercatorCoordinate.fromLngLat(r2), c2 = e.MercatorCoordinate.fromLngLat(n2), h2 = a2.x - s2.x, u2 = a2.y - s2.y, _2 = c2.x - l2.x, d2 = c2.y - l2.y, p2 = Math.sqrt((_2 * _2 + d2 * d2) / (h2 * h2 + u2 * u2));
            return Math.log(p2) / Math.LN2;
          }
          function Yo(e2, t2, i2) {
            const o2 = Math.cos(i2), r2 = Math.sin(i2);
            return { x: e2 * o2 - t2 * r2, y: e2 * r2 + t2 * o2 };
          }
          class Ko {
            constructor(t2, i2, o2, r2, n2, s2, a2) {
              this.tileSize = 512, this._renderWorldCopies = void 0 === n2 || n2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == r2 ? 60 : r2, this.setProjection(s2), this.setMaxBounds(a2), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new Uo(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Vo(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = 0.1;
            }
            clone() {
              const e2 = new Ko(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
              return e2._elevation = this._elevation, e2._centerAltitude = this._centerAltitude, e2._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e2.tileSize = this.tileSize, e2.mercatorFromTransition = this.mercatorFromTransition, e2.width = this.width, e2.height = this.height, e2.cameraElevationReference = this.cameraElevationReference, e2._center = this._center, e2._setZoom(this.zoom), e2._seaLevelZoom = this._seaLevelZoom, e2.angle = this.angle, e2._fov = this._fov, e2._pitch = this._pitch, e2._nearZ = this._nearZ, e2._farZ = this._farZ, e2._averageElevation = this._averageElevation, e2._unmodified = this._unmodified, e2._edgeInsets = this._edgeInsets.clone(), e2._camera = this._camera.clone(), e2._calcMatrices(), e2.freezeTileCoverage = this.freezeTileCoverage, e2.frustumCorners = this.frustumCorners, e2;
            }
            get elevation() {
              return this._elevation;
            }
            set elevation(e2) {
              this._elevation !== e2 && (this._elevation = e2, this._updateCameraOnTerrain(), this._calcMatrices());
            }
            updateElevation(e2, t2 = false) {
              const i2 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
              (null == this._seaLevelZoom || i2) && this._updateCameraOnTerrain(), (e2 || i2) && this._constrainCamera(t2), this._calcMatrices();
            }
            getProjection() {
              return e.pick(this.projection, ["name", "center", "parallels"]);
            }
            setProjection(i2) {
              this.projectionOptions = i2 || { name: "mercator" };
              const o2 = this.projection ? this.getProjection() : void 0;
              this.projection = e.getProjection(this.projectionOptions);
              const r2 = !t(o2, this.getProjection());
              return r2 && this._calcMatrices(), this.mercatorFromTransition = false, r2;
            }
            setMercatorFromTransition() {
              const t2 = this.projection.name;
              this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e.getProjection({ name: "mercator" });
              const i2 = t2 !== this.projection.name;
              return i2 && this._calcMatrices(), i2;
            }
            get minZoom() {
              return this._minZoom;
            }
            set minZoom(e2) {
              this._minZoom !== e2 && (this._minZoom = e2, this.zoom = Math.max(this.zoom, e2));
            }
            get maxZoom() {
              return this._maxZoom;
            }
            set maxZoom(e2) {
              this._maxZoom !== e2 && (this._maxZoom = e2, this.zoom = Math.min(this.zoom, e2));
            }
            get minPitch() {
              return this._minPitch;
            }
            set minPitch(e2) {
              this._minPitch !== e2 && (this._minPitch = e2, this.pitch = Math.max(this.pitch, e2));
            }
            get maxPitch() {
              return this._maxPitch;
            }
            set maxPitch(e2) {
              this._maxPitch !== e2 && (this._maxPitch = e2, this.pitch = Math.min(this.pitch, e2));
            }
            get renderWorldCopies() {
              return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
            }
            set renderWorldCopies(e2) {
              void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
            }
            get worldSize() {
              return this.tileSize * this.scale;
            }
            get cameraWorldSizeForFog() {
              const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
              return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
            }
            get cameraWorldSize() {
              const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
              return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
            }
            get pixelsPerMeter() {
              return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }
            get cameraPixelsPerMeter() {
              return e.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
            }
            get centerOffset() {
              return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
              return new e.pointGeometry(this.width, this.height);
            }
            get bearing() {
              return e.wrap(this.rotation, -180, 180);
            }
            set bearing(e2) {
              this.rotation = e2;
            }
            get rotation() {
              return -this.angle / Math.PI * 180;
            }
            set rotation(t2) {
              const i2 = -t2 * Math.PI / 180;
              var o2;
              this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = (o2 = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o2[1] = 0, o2[2] = 0), o2[0] = 1, o2[3] = 1, o2), function(e2, t3, i3) {
                var o3 = t3[0], r2 = t3[1], n2 = t3[2], s2 = t3[3], a2 = Math.sin(i3), l2 = Math.cos(i3);
                e2[0] = o3 * l2 + n2 * a2, e2[1] = r2 * l2 + s2 * a2, e2[2] = o3 * -a2 + n2 * l2, e2[3] = r2 * -a2 + s2 * l2;
              }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
              return this._pitch / Math.PI * 180;
            }
            set pitch(t2) {
              const i2 = e.clamp(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
              this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
            }
            get aspect() {
              return this.width / this.height;
            }
            get fov() {
              return this._fov / Math.PI * 180;
            }
            get fovX() {
              return this._fov;
            }
            get fovY() {
              const e2 = 1 / Math.tan(0.5 * this.fovX);
              return 2 * Math.atan(1 / this.aspect / e2);
            }
            set fov(t2) {
              t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = e.degToRad(t2), this._calcMatrices());
            }
            get averageElevation() {
              return this._averageElevation;
            }
            set averageElevation(e2) {
              this._averageElevation = e2, this._calcFogMatrices(), this._distanceTileDataCache = {};
            }
            get zoom() {
              return this._zoom;
            }
            set zoom(e2) {
              const t2 = Math.min(Math.max(e2, this.minZoom), this.maxZoom);
              this._zoom !== t2 && (this._unmodified = false, this._setZoom(t2), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }
            _setZoom(e2) {
              this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom;
            }
            _updateCameraOnTerrain() {
              if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))
                return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
              const e2 = this._elevation;
              this._centerAltitude = e2.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e2.exaggeration(), this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
              void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
            }
            sampleAverageElevation() {
              if (!this._elevation)
                return 0;
              const t2 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
              let r2 = 0, n2 = 0;
              for (let s2 = 0; s2 < i2.length; s2++) {
                const a2 = new e.pointGeometry(i2[s2][0] * this.width, o2 + i2[s2][1] * (this.height - o2)), l2 = t2.pointCoordinate(a2);
                if (!l2)
                  continue;
                const c2 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
                r2 += l2[3] * c2, n2 += c2;
              }
              return 0 === n2 ? NaN : r2 / n2;
            }
            get center() {
              return this._center;
            }
            set center(e2) {
              e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
              if (null == this._seaLevelZoom || !this._elevation)
                return;
              const e2 = this._seaLevelZoom, t2 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t2, o2 = this._mercatorZfromZoom(e2), r2 = this._mercatorZfromZoom(this._maxZoom), n2 = Math.max(o2 - i2, r2);
              this._setZoom(this._zoomFromMercatorZ(n2));
            }
            get padding() {
              return this._edgeInsets.toJSON();
            }
            set padding(e2) {
              this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
            }
            computeZoomRelativeTo(t2) {
              const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t2.toAltitude()));
              let o2;
              o2 = t2.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t2.x, t2.y, t2.z];
              const r2 = e.length(e.sub([], this._camera.position, o2));
              return e.clamp(this._zoomFromMercatorZ(r2), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(t2) {
              if (!this.height)
                return;
              if (!t2.position && !t2.orientation)
                return;
              this._updateCameraState();
              let i2 = false;
              if (t2.orientation && !e.exactEquals(t2.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t2.orientation)), t2.position) {
                const o2 = [t2.position.x, t2.position.y, t2.position.z];
                e.exactEquals$1(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
              }
              i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
              this._updateCameraState();
              const t2 = this._camera.position, i2 = new Zo();
              return i2.position = new e.MercatorCoordinate(t2[0], t2[1], t2[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this.renderWorldCopies, i2;
            }
            _setCameraOrientation(t2) {
              if (!e.length$1(t2))
                return false;
              e.normalize$1(t2, t2);
              const i2 = e.transformQuat([], [0, 0, -1], t2), o2 = e.transformQuat([], [0, -1, 0], t2);
              if (o2[2] < 0)
                return false;
              const r2 = jo(i2, o2);
              return !!r2 && (this._camera.orientation = r2, true);
            }
            _setCameraPosition(t2) {
              const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r2 = this.cameraToCenterDistance;
              t2[2] = e.clamp(t2[2], r2 / o2, r2 / i2), this._camera.position = t2;
            }
            get centerPoint() {
              return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
              return this._fov * (0.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(e2) {
              return this._edgeInsets.equals(e2);
            }
            interpolatePadding(e2, t2, i2) {
              this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(e2) {
              const t2 = (e2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e2.tileSize));
              return Math.max(0, t2);
            }
            getVisibleUnwrappedCoordinates(t2) {
              const i2 = [new e.UnwrappedTileID(0, t2)];
              if (this.renderWorldCopies) {
                const o2 = this.pointCoordinate(new e.pointGeometry(0, 0)), r2 = this.pointCoordinate(new e.pointGeometry(this.width, 0)), n2 = this.pointCoordinate(new e.pointGeometry(this.width, this.height)), s2 = this.pointCoordinate(new e.pointGeometry(0, this.height)), a2 = Math.floor(Math.min(o2.x, r2.x, n2.x, s2.x)), l2 = Math.floor(Math.max(o2.x, r2.x, n2.x, s2.x)), c2 = 1;
                for (let o3 = a2 - c2; o3 <= l2 + c2; o3++)
                  0 !== o3 && i2.push(new e.UnwrappedTileID(o3, t2));
              }
              return i2;
            }
            coveringTiles(t2) {
              let i2 = this.coveringZoomLevel(t2);
              const o2 = i2, r2 = this.elevation && !t2.isTerrainDEM, n2 = "mercator" === this.projection.name;
              if (void 0 !== t2.minzoom && i2 < t2.minzoom)
                return [];
              void 0 !== t2.maxzoom && i2 > t2.maxzoom && (i2 = t2.maxzoom);
              const s2 = this.locationCoordinate(this.center), a2 = this.center.lat, l2 = 1 << i2, c2 = [l2 * s2.x, l2 * s2.y, 0], h2 = "globe" === this.projection.name, u2 = !h2, _2 = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2, u2), d2 = h2 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), p2 = l2 * e.mercatorZfromAltitude(1, this.center.lat), m2 = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat), f2 = [l2 * d2.x, l2 * d2.y, m2 * (u2 ? 1 : p2)], g2 = this.cameraToCenterDistance / t2.tileSize * (t2.roundZoom ? 1 : 0.502), v2 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i2 : 0, x2 = t2.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, y2 = t2.isTerrainDEM ? -x2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b2 = this.projection.isReprojectedInTileSpace ? Xo(this) : 1, w2 = (t3) => {
                const i3 = 1 / 4e4, o3 = new e.MercatorCoordinate(t3.x + i3, t3.y, t3.z), r3 = new e.MercatorCoordinate(t3.x, t3.y + i3, t3.z), n3 = t3.toLngLat(), s3 = o3.toLngLat(), a3 = r3.toLngLat(), l3 = this.locationCoordinate(n3), c3 = this.locationCoordinate(s3), h3 = this.locationCoordinate(a3), u3 = Math.hypot(c3.x - l3.x, c3.y - l3.y), _3 = Math.hypot(h3.x - l3.x, h3.y - l3.y);
                return Math.sqrt(u3 * _3) * b2 / i3;
              }, T2 = (t3) => {
                const i3 = x2, o3 = y2;
                return { aabb: e.tileAABB(this, l2, 0, 0, 0, t3, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t3, fullyVisible: false };
              }, E2 = [];
              let C2 = [];
              const M2 = i2, I2 = t2.reparseOverscaled ? o2 : i2, S2 = (e2) => e2 * e2, D2 = S2((m2 - this._centerAltitude) * p2), L2 = (e2) => {
                if (!this._elevation || !e2.tileID || !n2)
                  return;
                const t3 = this._elevation.getMinMaxForTile(e2.tileID), i3 = e2.aabb;
                t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e2.shouldSplit = A2(e2), e2.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
              }, A2 = (t3) => {
                if (t3.zoom < v2)
                  return true;
                if (t3.zoom === M2)
                  return false;
                if (null != t3.shouldSplit)
                  return t3.shouldSplit;
                const i3 = t3.aabb.distanceX(f2), n3 = t3.aabb.distanceY(f2);
                let s3 = D2, l3 = 1;
                if (h2) {
                  s3 = S2(t3.aabb.distanceZ(f2));
                  const i4 = Math.pow(2, t3.zoom), o3 = e.latFromMercatorY((t3.y + 1) / i4), r3 = e.latFromMercatorY(t3.y / i4), n4 = Math.min(Math.max(a2, o3), r3), c4 = e.circumferenceAtLatitude(n4) / e.circumferenceAtLatitude(a2);
                  if (l3 = n4 === a2 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, c4 / this._mercatorScaleRatio), this.zoom <= e.GLOBE_ZOOM_THRESHOLD_MIN && t3.zoom === M2 - 1 && c4 >= 0.9)
                    return true;
                } else if (r2 && (s3 = S2(t3.aabb.distanceZ(f2) * p2)), this.projection.isReprojectedInTileSpace && o2 <= 5) {
                  const i4 = Math.pow(2, t3.zoom), o3 = w2(new e.MercatorCoordinate((t3.x + 0.5) / i4, (t3.y + 0.5) / i4));
                  l3 = o3 > 0.85 ? 1 : o3;
                }
                const c3 = i3 * i3 + n3 * n3 + s3, u3 = S2((1 << M2 - t3.zoom) * g2 * l3 * ((e2, t4) => {
                  if (t4 * S2(0.707) < e2)
                    return 1;
                  const i4 = Math.sqrt(t4 / e2);
                  return i4 / (1.4144271570014144 + (Math.pow(1.1, i4 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                })(Math.max(s3, D2), c3));
                return c3 < u3;
              };
              if (this.renderWorldCopies)
                for (let e2 = 1; e2 <= 3; e2++)
                  E2.push(T2(-e2)), E2.push(T2(e2));
              for (E2.push(T2(0)); E2.length > 0; ) {
                const o3 = E2.pop(), s3 = o3.x, a3 = o3.y;
                let u3 = o3.fullyVisible;
                if (!u3) {
                  const e2 = o3.aabb.intersects(_2);
                  if (0 === e2)
                    continue;
                  u3 = 2 === e2;
                }
                if (o3.zoom !== M2 && A2(o3))
                  for (let t3 = 0; t3 < 4; t3++) {
                    const i3 = (s3 << 1) + t3 % 2, c3 = (a3 << 1) + (t3 >> 1), _3 = { aabb: n2 ? o3.aabb.quadrant(t3) : e.tileAABB(this, l2, o3.zoom + 1, i3, c3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: c3, wrap: o3.wrap, fullyVisible: u3, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                    r2 && !h2 && (_3.tileID = new e.OverscaledTileID(o3.zoom + 1 === M2 ? I2 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, c3), L2(_3)), E2.push(_3);
                  }
                else {
                  const r3 = o3.zoom === M2 ? I2 : o3.zoom;
                  if (t2.minzoom && t2.minzoom > r3)
                    continue;
                  const n3 = c2[0] - (0.5 + s3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), l3 = c2[1] - 0.5 - a3, h3 = o3.tileID ? o3.tileID : new e.OverscaledTileID(r3, o3.wrap, o3.zoom, s3, a3);
                  C2.push({ tileID: h3, distanceSq: n3 * n3 + l3 * l3 });
                }
              }
              if (this.fogCullDistSq) {
                const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
                C2 = C2.filter((r3) => {
                  const n3 = [0, 0, 0, 1], s3 = [e.EXTENT, e.EXTENT, 0, 1], a3 = this.calculateFogTileMatrix(r3.tileID.toUnwrapped());
                  e.transformMat4$1(n3, n3, a3), e.transformMat4$1(s3, s3, a3);
                  const l3 = e.getAABBPointSquareDist(n3, s3);
                  if (0 === l3)
                    return true;
                  let c3 = false;
                  const h3 = this._elevation;
                  if (h3 && l3 > i3 && 0 !== o3) {
                    const i4 = this.calculateProjMatrix(r3.tileID.toUnwrapped());
                    let n4;
                    t2.isTerrainDEM || (n4 = h3.getMinMaxForTile(r3.tileID)), n4 || (n4 = { min: y2, max: x2 });
                    const s4 = e.furthestTileCorner(this.rotation), a4 = [s4[0] * e.EXTENT, s4[1] * e.EXTENT, n4.max];
                    e.transformMat4(a4, a4, i4), c3 = (1 - a4[1]) * this.height * 0.5 < o3;
                  }
                  return l3 < i3 || c3;
                });
              }
              return C2.sort((e2, t3) => e2.distanceSq - t3.distanceSq).map((e2) => e2.tileID);
            }
            resize(e2, t2) {
              this.width = e2, this.height = t2, this.pixelsToGLUnits = [2 / e2, -2 / t2], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
              return this._unmodified;
            }
            zoomScale(e2) {
              return Math.pow(2, e2);
            }
            scaleZoom(e2) {
              return Math.log(e2) / Math.LN2;
            }
            project(t2) {
              const i2 = e.clamp(t2.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), o2 = this.projection.project(t2.lng, i2);
              return new e.pointGeometry(o2.x * this.worldSize, o2.y * this.worldSize);
            }
            unproject(e2) {
              return this.projection.unproject(e2.x / this.worldSize, e2.y / this.worldSize);
            }
            get point() {
              return this.project(this.center);
            }
            get pointMerc() {
              return this.point._div(this.worldSize);
            }
            get pixelsPerMeterRatio() {
              return this.pixelsPerMeter / e.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;
            }
            setLocationAtPoint(t2, i2) {
              let o2, r2;
              const n2 = this.centerPoint;
              if ("globe" === this.projection.name) {
                const e2 = this.worldSize;
                o2 = (i2.x - n2.x) / e2, r2 = (i2.y - n2.y) / e2;
              } else {
                const e2 = this.pointCoordinate(i2), t3 = this.pointCoordinate(n2);
                o2 = e2.x - t3.x, r2 = e2.y - t3.y;
              }
              const s2 = this.locationCoordinate(t2);
              this.setLocation(new e.MercatorCoordinate(s2.x - o2, s2.y - r2));
            }
            setLocation(e2) {
              this.center = this.coordinateLocation(e2), this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(e2) {
              return this.projection.locationPoint(this, e2);
            }
            locationPoint3D(e2) {
              return this.projection.locationPoint(this, e2, true);
            }
            pointLocation(e2) {
              return this.coordinateLocation(this.pointCoordinate(e2));
            }
            pointLocation3D(e2) {
              return this.coordinateLocation(this.pointCoordinate3D(e2));
            }
            locationCoordinate(t2, i2) {
              const o2 = i2 ? e.mercatorZfromAltitude(i2, t2.lat) : void 0, r2 = this.projection.project(t2.lng, t2.lat);
              return new e.MercatorCoordinate(r2.x, r2.y, o2);
            }
            coordinateLocation(e2) {
              return this.projection.unproject(e2.x, e2.y);
            }
            pointRayIntersection(t2, i2) {
              const o2 = null != i2 ? i2 : this._centerAltitude, r2 = [t2.x, t2.y, 0, 1], n2 = [t2.x, t2.y, 1, 1];
              e.transformMat4$1(r2, r2, this.pixelMatrixInverse), e.transformMat4$1(n2, n2, this.pixelMatrixInverse);
              const s2 = n2[3];
              e.scale$1(r2, r2, 1 / r2[3]), e.scale$1(n2, n2, 1 / s2);
              const a2 = r2[2], l2 = n2[2];
              return { p0: r2, p1: n2, t: a2 === l2 ? 0 : (o2 - a2) / (l2 - a2) };
            }
            screenPointToMercatorRay(t2) {
              const i2 = [t2.x, t2.y, 0, 1], o2 = [t2.x, t2.y, 1, 1];
              return e.transformMat4$1(i2, i2, this.pixelMatrixInverse), e.transformMat4$1(o2, o2, this.pixelMatrixInverse), e.scale$1(i2, i2, 1 / i2[3]), e.scale$1(o2, o2, 1 / o2[3]), i2[2] = e.mercatorZfromAltitude(i2[2], this._center.lat) * this.worldSize, o2[2] = e.mercatorZfromAltitude(o2[2], this._center.lat) * this.worldSize, e.scale$1(i2, i2, 1 / this.worldSize), e.scale$1(o2, o2, 1 / this.worldSize), new e.Ray([i2[0], i2[1], i2[2]], e.normalize([], e.sub([], o2, i2)));
            }
            rayIntersectionCoordinate(t2) {
              const { p0: i2, p1: o2, t: r2 } = t2, n2 = e.mercatorZfromAltitude(i2[2], this._center.lat), s2 = e.mercatorZfromAltitude(o2[2], this._center.lat);
              return new e.MercatorCoordinate(e.number(i2[0], o2[0], r2) / this.worldSize, e.number(i2[1], o2[1], r2) / this.worldSize, e.number(n2, s2, r2));
            }
            pointCoordinate(e2, t2 = this._centerAltitude) {
              return this.projection.pointCoordinate(this, e2.x, e2.y, t2);
            }
            pointCoordinate3D(t2) {
              if (!this.elevation)
                return this.pointCoordinate(t2);
              let i2 = this.projection.pointCoordinate3D(this, t2.x, t2.y);
              if (i2)
                return new e.MercatorCoordinate(i2[0], i2[1], i2[2]);
              let o2 = 0, r2 = this.horizonLineFromTop();
              if (t2.y > r2)
                return this.pointCoordinate(t2);
              const n2 = 0.02 * r2, s2 = t2.clone();
              for (let t3 = 0; t3 < 10 && r2 - o2 > n2; t3++) {
                s2.y = e.number(o2, r2, 0.66);
                const t4 = this.projection.pointCoordinate3D(this, s2.x, s2.y);
                t4 ? (r2 = s2.y, i2 = t4) : o2 = s2.y;
              }
              return i2 ? new e.MercatorCoordinate(i2[0], i2[1], i2[2]) : this.pointCoordinate(t2);
            }
            isPointAboveHorizon(e2) {
              return this.projection.isPointAboveHorizon(this, e2);
            }
            _coordinatePoint(t2, i2) {
              const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t2, this._centerAltitude) : this._centerAltitude, r2 = [t2.x * this.worldSize, t2.y * this.worldSize, o2 + t2.toAltitude(), 1];
              return e.transformMat4$1(r2, r2, this.pixelMatrix), r2[3] > 0 ? new e.pointGeometry(r2[0] / r2[3], r2[1] / r2[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            _getBoundsNonRectangular() {
              const { top: t2, left: i2 } = this._edgeInsets, o2 = this.height - this._edgeInsets.bottom, r2 = this.width - this._edgeInsets.right, n2 = this.pointLocation3D(new e.pointGeometry(i2, t2)), s2 = this.pointLocation3D(new e.pointGeometry(r2, t2)), a2 = this.pointLocation3D(new e.pointGeometry(r2, o2)), l2 = this.pointLocation3D(new e.pointGeometry(i2, o2));
              let c2 = Math.min(n2.lng, s2.lng, a2.lng, l2.lng), h2 = Math.max(n2.lng, s2.lng, a2.lng, l2.lng), u2 = Math.min(n2.lat, s2.lat, a2.lat, l2.lat), _2 = Math.max(n2.lat, s2.lat, a2.lat, l2.lat);
              const d2 = Math.pow(2, -this.zoom) / 16 * 270, p2 = "globe" === this.projection.name ? 1 : 4, m2 = (t3, i3, o3, r3, n3) => {
                const s3 = (t3 + o3) / 2, a3 = (i3 + r3) / 2, l3 = new e.pointGeometry(s3, a3), { lng: f2, lat: g2 } = this.pointLocation3D(l3), v2 = Math.max(0, c2 - f2, u2 - g2, f2 - h2, g2 - _2);
                c2 = Math.min(c2, f2), h2 = Math.max(h2, f2), u2 = Math.min(u2, g2), _2 = Math.max(_2, g2), (n3 < p2 || v2 > d2) && (m2(t3, i3, s3, a3, n3 + 1), m2(s3, a3, o3, r3, n3 + 1));
              };
              if (m2(i2, t2, r2, t2, 1), m2(r2, t2, r2, o2, 1), m2(r2, o2, i2, o2, 1), m2(i2, o2, i2, t2, 1), "globe" === this.projection.name) {
                const [t3, i3] = e.polesInViewport(this);
                t3 ? (_2 = 90, h2 = 180, c2 = -180) : i3 && (u2 = -90, h2 = 180, c2 = -180);
              }
              return new e.LngLatBounds(new e.LngLat(c2, u2), new e.LngLat(h2, _2));
            }
            _getBoundsRectangular(t2, i2) {
              const { top: o2, left: r2 } = this._edgeInsets, n2 = this.height - this._edgeInsets.bottom, s2 = this.width - this._edgeInsets.right, a2 = new e.pointGeometry(r2, o2), l2 = new e.pointGeometry(s2, o2), c2 = new e.pointGeometry(s2, n2), h2 = new e.pointGeometry(r2, n2);
              let u2 = this.pointCoordinate(a2, t2), _2 = this.pointCoordinate(l2, t2);
              const d2 = this.pointCoordinate(c2, i2), p2 = this.pointCoordinate(h2, i2), m2 = (e2, t3) => (t3.y - e2.y) / (t3.x - e2.x);
              return u2.y > 1 && _2.y >= 0 ? u2 = new e.MercatorCoordinate((1 - p2.y) / m2(p2, u2) + p2.x, 1) : u2.y < 0 && _2.y <= 1 && (u2 = new e.MercatorCoordinate(-p2.y / m2(p2, u2) + p2.x, 0)), _2.y > 1 && u2.y >= 0 ? _2 = new e.MercatorCoordinate((1 - d2.y) / m2(d2, _2) + d2.x, 1) : _2.y < 0 && u2.y <= 1 && (_2 = new e.MercatorCoordinate(-d2.y / m2(d2, _2) + d2.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(u2)).extend(this.coordinateLocation(_2)).extend(this.coordinateLocation(p2)).extend(this.coordinateLocation(d2));
            }
            _getBoundsRectangularTerrain() {
              const e2 = this.elevation;
              if (!e2.visibleDemTiles.length || e2.isUsingMockSource())
                return this._getBoundsRectangular(0, 0);
              const t2 = e2.visibleDemTiles.reduce((e3, t3) => {
                if (t3.dem) {
                  const i2 = t3.dem.tree;
                  e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
                }
                return e3;
              }, { min: Number.MAX_VALUE, max: 0 });
              return this._getBoundsRectangular(t2.min * e2.exaggeration(), t2.max * e2.exaggeration());
            }
            getBounds() {
              return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
            }
            horizonLineFromTop(e2 = true) {
              const t2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i2 = this.height / 2 - t2 * (1 - this._horizonShift);
              return e2 ? Math.max(0, i2) : i2;
            }
            getMaxBounds() {
              return this.maxBounds;
            }
            setMaxBounds(t2) {
              this.maxBounds = t2, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t2 && (this.minLat = t2.getSouth(), this.maxLat = t2.getNorth(), this.minLng = t2.getWest(), this.maxLng = t2.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
            }
            calculatePosMatrix(e2, t2) {
              return this.projection.createTileMatrix(this, t2, e2);
            }
            calculateDistanceTileData(t2) {
              const i2 = t2.key, o2 = this._distanceTileDataCache;
              if (o2[i2])
                return o2[i2];
              const r2 = t2.canonical, n2 = 1 / this.height, s2 = this.cameraWorldSize, a2 = s2 / this.zoomScale(r2.z), l2 = (r2.x + Math.pow(2, r2.z) * t2.wrap) * a2, c2 = r2.y * a2, h2 = this.point;
              h2.x *= s2 / this.worldSize, h2.y *= s2 / this.worldSize;
              const u2 = this.angle, _2 = Math.sin(-u2), d2 = -Math.cos(-u2);
              return o2[i2] = { bearing: [_2, d2], center: [(h2.x - l2) * n2, (h2.y - c2) * n2], scale: a2 / e.EXTENT * n2 }, o2[i2];
            }
            calculateFogTileMatrix(t2) {
              const i2 = t2.key, o2 = this._fogTileMatrixCache;
              if (o2[i2])
                return o2[i2];
              const r2 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t2);
              return e.multiply(r2, this.worldToFogMatrix, r2), o2[i2] = new Float32Array(r2), o2[i2];
            }
            calculateProjMatrix(t2, i2 = false) {
              const o2 = t2.key, r2 = i2 ? this._alignedProjMatrixCache : this._projMatrixCache;
              if (r2[o2])
                return r2[o2];
              const n2 = this.calculatePosMatrix(t2, this.worldSize);
              return e.multiply(n2, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i2 ? this.alignedProjMatrix : this.projMatrix, n2), r2[o2] = new Float32Array(n2), r2[o2];
            }
            calculatePixelsToTileUnitsMatrix(t2) {
              const i2 = t2.tileID.key, o2 = this._pixelsToTileUnitsCache;
              if (o2[i2])
                return o2[i2];
              const r2 = function(t3, i3) {
                const { scale: o3 } = t3.tileTransform, r3 = o3 * e.EXTENT / (t3.tileSize * Math.pow(2, i3.zoom - t3.tileID.overscaledZ + t3.tileID.canonical.z));
                return n2 = new Float32Array(4), l2 = (s2 = i3.inverseAdjustmentMatrix)[1], c2 = s2[2], h2 = s2[3], _2 = (a2 = [r3, r3])[1], n2[0] = s2[0] * (u2 = a2[0]), n2[1] = l2 * u2, n2[2] = c2 * _2, n2[3] = h2 * _2, n2;
                var n2, s2, a2, l2, c2, h2, u2, _2;
              }(t2, this);
              return o2[i2] = r2, o2[i2];
            }
            customLayerMatrix() {
              return this.mercatorMatrix.slice();
            }
            globeToMercatorMatrix() {
              if ("globe" === this.projection.name) {
                const t2 = 1 / this.worldSize, i2 = e.fromScaling([], [t2, t2, t2]);
                return e.multiply(i2, i2, this.globeMatrix), i2;
              }
            }
            recenterOnTerrain() {
              if (!this._elevation || "globe" === this.projection.name)
                return;
              const t2 = this._elevation;
              this._updateCameraState();
              const i2 = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), r2 = this._camera.forward(), n2 = e.mercatorZfromAltitude(1, this._center.lat);
              o2[2] /= n2, r2[2] /= n2, e.normalize(r2, r2);
              const s2 = t2.raycast(o2, r2, t2.exaggeration());
              if (s2) {
                const t3 = e.scaleAndAdd([], o2, r2, s2), i3 = new e.MercatorCoordinate(t3[0], t3[1], e.mercatorZfromAltitude(t3[2], e.latFromMercatorY(t3[1]))), a2 = (i3.z + e.length([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * n2])) * this._pixelsPerMercatorPixel;
                this._seaLevelZoom = this._zoomFromMercatorZ(a2), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
              }
            }
            _constrainCamera(t2 = false) {
              if (!this._elevation)
                return;
              const i2 = this._elevation, o2 = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, r2 = this._computeCameraPosition(o2), n2 = i2.getAtPointOrZero(new e.MercatorCoordinate(...r2)), s2 = this.pixelsPerMeter / this.worldSize * n2, a2 = this._minimumHeightOverTerrain(), l2 = r2[2] - s2;
              if (l2 <= a2)
                if (l2 < 0 || t2) {
                  const t3 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [r2[0], r2[1], t3.z - r2[2]], o3 = e.length(i3);
                  i3[2] -= (a2 - l2) / this._pixelsPerMercatorPixel;
                  const n3 = e.length(i3);
                  if (0 === n3)
                    return;
                  e.scale$2(i3, i3, o3 / n3 * this._pixelsPerMercatorPixel), this._camera.position = [r2[0], r2[1], t3.z * this._pixelsPerMercatorPixel - i3[2]], this._updateStateFromCamera();
                } else
                  this._isCameraConstrained = true;
            }
            _constrain() {
              if (!this.center || !this.width || !this.height || this._constraining)
                return;
              this._constraining = true;
              const t2 = "globe" === this.projection.name || this.mercatorFromTransition;
              if (this.projection.isReprojectedInTileSpace || t2) {
                const i3 = this.center;
                return i3.lat = e.clamp(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t2) && (i3.lng = e.clamp(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
              }
              const i2 = this._unmodified, { x: o2, y: r2 } = this.point;
              let n2 = 0, s2 = o2, a2 = r2;
              const l2 = this.width / 2, c2 = this.height / 2, h2 = this.worldMinY * this.scale, u2 = this.worldMaxY * this.scale;
              if (r2 - c2 < h2 && (a2 = h2 + c2), r2 + c2 > u2 && (a2 = u2 - c2), u2 - h2 < this.height && (n2 = Math.max(n2, this.height / (u2 - h2)), a2 = (u2 + h2) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                const e2 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e2 + t3) / 2;
                s2 = (o2 + i3 + this.worldSize) % this.worldSize - i3, s2 - l2 < e2 && (s2 = e2 + l2), s2 + l2 > t3 && (s2 = t3 - l2), t3 - e2 < this.width && (n2 = Math.max(n2, this.width / (t3 - e2)), s2 = (t3 + e2) / 2);
              }
              s2 === o2 && a2 === r2 || (this.center = this.unproject(new e.pointGeometry(s2, a2))), n2 && (this.zoom += this.scaleZoom(n2)), this._constrainCamera(), this._unmodified = i2, this._constraining = false;
            }
            _minZoomForBounds() {
              let e2 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
              return this.maxBounds && (e2 = Math.max(e2, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e2;
            }
            _maxCameraBoundsDistance() {
              return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
              if (!this.height)
                return;
              const t2 = this.centerOffset, i2 = this.pixelsPerMeter;
              "globe" === this.projection.name && (this._mercatorScaleRatio = e.mercatorZfromAltitude(1, this.center.lat) / e.mercatorZfromAltitude(1, e.GLOBE_SCALE_MATCH_LATITUDE));
              const o2 = qo(this.projection, this.zoom, this.width, this.height, 1024);
              this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
              const r2 = "meters" === this.projection.zAxisUnit ? i2 : 1, n2 = this._camera.getWorldToCamera(this.worldSize, r2), s2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
              s2[8] = 2 * -t2.x / this.width, s2[9] = 2 * t2.y / this.height;
              let a2 = e.mul([], s2, n2);
              if (this.projection.isReprojectedInTileSpace) {
                const t3 = this.locationCoordinate(this.center), i3 = e.identity([]);
                e.translate(i3, i3, [t3.x * this.worldSize, t3.y * this.worldSize, 0]), e.multiply(i3, i3, Wo(this)), e.translate(i3, i3, [-t3.x * this.worldSize, -t3.y * this.worldSize, 0]), e.multiply(a2, a2, i3), this.inverseAdjustmentMatrix = function(e2) {
                  const t4 = Wo(e2, true);
                  return v([], [t4[0], t4[1], t4[4], t4[5]]);
                }(this);
              } else
                this.inverseAdjustmentMatrix = [1, 0, 0, 1];
              this.mercatorMatrix = e.scale([], a2, [this.worldSize, this.worldSize, this.worldSize / r2, 1]), this.projMatrix = a2, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);
              const l2 = e.invert([], s2);
              this.frustumCorners = e.FrustumCorners.fromInvProjectionMatrix(l2, this.horizonLineFromTop(), this.height);
              const c2 = new Float32Array(16);
              e.identity(c2), e.scale(c2, c2, [1, -1, 1]), e.rotateX(c2, c2, this._pitch), e.rotateZ(c2, c2, this.angle);
              const h2 = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), u2 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
              h2[8] = 2 * -t2.x / this.width, h2[9] = 2 * (t2.y + u2) / this.height, this.skyboxMatrix = e.multiply(c2, h2, c2);
              const _2 = this.point, d2 = _2.x, p2 = _2.y, m2 = this.width % 2 / 2, f2 = this.height % 2 / 2, g2 = Math.cos(this.angle), x2 = Math.sin(this.angle), y2 = d2 - Math.round(d2) + g2 * m2 + x2 * f2, b2 = p2 - Math.round(p2) + g2 * f2 + x2 * m2, w2 = new Float64Array(a2);
              if (e.translate(w2, w2, [y2 > 0.5 ? y2 - 1 : y2, b2 > 0.5 ? b2 - 1 : b2, 0]), this.alignedProjMatrix = w2, a2 = e.create(), e.scale(a2, a2, [this.width / 2, -this.height / 2, 1]), e.translate(a2, a2, [1, -1, 0]), this.labelPlaneMatrix = a2, a2 = e.create(), e.scale(a2, a2, [1, -1, 1]), e.translate(a2, a2, [-1, -1, 0]), e.scale(a2, a2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a2, this.pixelMatrix = e.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a2 = e.invert(new Float64Array(16), this.pixelMatrix), !a2)
                throw new Error("failed to invert matrix");
              if (this.pixelMatrixInverse = a2, "globe" === this.projection.name || this.mercatorFromTransition) {
                this.globeMatrix = e.calculateGlobeMatrix(this);
                const t3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
                this.globeCenterInViewSpace = e.transformMat4(t3, t3, n2), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
              } else
                this.globeMatrix = a2;
              this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
            }
            _calcFogMatrices() {
              this._fogTileMatrixCache = {};
              const t2 = this.cameraWorldSizeForFog, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, r2 = 1 / this.height / this._pixelsPerMercatorPixel, n2 = [t2, t2, i2];
              e.scale$2(n2, n2, r2), e.scale$2(o2, o2, -1), e.multiply$2(o2, o2, n2);
              const s2 = e.create();
              e.translate(s2, s2, o2), e.scale(s2, s2, n2), this.mercatorFogMatrix = s2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t2, i2, r2);
            }
            _computeCameraPosition(e2) {
              const t2 = (e2 = e2 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), o2 = this.point, r2 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t2 - e2 / this.worldSize * this._centerAltitude;
              return [o2.x / this.worldSize - i2[0] * r2, o2.y / this.worldSize - i2[1] * r2, e2 / this.worldSize * this._centerAltitude - i2[2] * r2];
            }
            _updateCameraState() {
              this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(t2) {
              const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = this._camera.position[2], r2 = t2[2];
              let n2 = 1;
              this.projection.wrap && (this.center = this.center.wrap()), r2 > 0 && (n2 = Math.min((i2 - o2) / r2, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t2, n2), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
              const t2 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: r2 } = this._camera.getPitchBearing(), n2 = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, s2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)), a2 = Math.max((t2[2] - n2) / Math.cos(o2), s2), l2 = this._zoomFromMercatorZ(a2);
              e.scaleAndAdd(t2, t2, i2, a2), this._pitch = e.clamp(o2, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r2, -Math.PI, Math.PI), this._setZoom(e.clamp(l2, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t2[0], t2[1], t2[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(e2) {
              return Math.pow(2, e2) * this.tileSize;
            }
            _mercatorZfromZoom(e2) {
              return this.cameraToCenterDistance / this._worldSizeFromZoom(e2);
            }
            _minimumHeightOverTerrain() {
              const e2 = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
              return this._mercatorZfromZoom(e2);
            }
            _zoomFromMercatorZ(e2) {
              return this.scaleZoom(this.cameraToCenterDistance / (e2 * this.tileSize));
            }
            zoomFromMercatorZAdjusted(t2) {
              let i2 = 0, o2 = e.GLOBE_ZOOM_THRESHOLD_MAX, r2 = 0, n2 = 1 / 0;
              for (; o2 - i2 > 1e-6 && o2 > i2; ) {
                const e2 = i2 + 0.5 * (o2 - i2), s2 = this.tileSize * Math.pow(2, e2), a2 = this.getCameraToCenterDistance(this.projection, e2, s2), l2 = this.scaleZoom(a2 / (t2 * this.tileSize)), c2 = Math.abs(e2 - l2);
                c2 < n2 && (n2 = c2, r2 = e2), e2 < l2 ? i2 = e2 : o2 = e2;
              }
              return r2;
            }
            _terrainEnabled() {
              return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }
            anyCornerOffEdge(t2, i2) {
              const o2 = Math.min(t2.x, i2.x), r2 = Math.max(t2.x, i2.x), n2 = Math.min(t2.y, i2.y), s2 = Math.max(t2.y, i2.y);
              if (n2 < this.horizonLineFromTop(false))
                return true;
              if ("mercator" !== this.projection.name)
                return false;
              const a2 = [new e.pointGeometry(o2, n2), new e.pointGeometry(r2, s2), new e.pointGeometry(o2, s2), new e.pointGeometry(r2, n2)], l2 = this.renderWorldCopies ? -3 : 0, c2 = this.renderWorldCopies ? 4 : 1;
              for (const e2 of a2) {
                const t3 = this.pointRayIntersection(e2);
                if (t3.t < 0)
                  return true;
                const i3 = this.rayIntersectionCoordinate(t3);
                if (i3.x < l2 || i3.y < 0 || i3.x > c2 || i3.y > 1)
                  return true;
              }
              return false;
            }
            isHorizonVisible() {
              return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height));
            }
            zoomDeltaToMovement(t2, i2) {
              const o2 = e.length(e.sub([], this._camera.position, t2)), r2 = this._zoomFromMercatorZ(o2) + i2;
              return o2 - this._mercatorZfromZoom(r2);
            }
            getCameraPoint() {
              if ("globe" === this.projection.name) {
                const t2 = function([t3, i2, o2], r2) {
                  const n2 = [t3, i2, o2, 1];
                  e.transformMat4$1(n2, n2, r2);
                  const s2 = n2[3] = Math.max(n2[3], 1e-6);
                  return n2[0] /= s2, n2[1] /= s2, n2[2] /= s2, n2;
                }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
                return new e.pointGeometry(t2[0], t2[1]);
              }
              {
                const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                return this.centerPoint.add(new e.pointGeometry(0, t2));
              }
            }
            getCameraToCenterDistance(e2, t2 = this.zoom, i2 = this.worldSize) {
              const o2 = qo(e2, t2, this.width, this.height, 1024), r2 = e2.pixelSpaceConversion(this.center.lat, i2, o2);
              return 0.5 / Math.tan(0.5 * this._fov) * this.height * r2;
            }
            getWorldToCameraMatrix() {
              const t2 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
              return "globe" === this.projection.name && e.multiply(t2, t2, this.globeMatrix), t2;
            }
          }
          function Jo(e2, t2) {
            let i2 = false, o2 = null;
            const r2 = () => {
              o2 = null, i2 && (e2(), o2 = setTimeout(r2, t2), i2 = false);
            };
            return () => (i2 = true, o2 || r2(), o2);
          }
          class Qo {
            constructor(t2) {
              this._hashName = t2 && encodeURIComponent(t2), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Jo(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(t2) {
              return this._map = t2, e.window.addEventListener("hashchange", this._onHashChange, false), t2.on("moveend", this._updateHash), this;
            }
            remove() {
              return this._map ? (this._map.off("moveend", this._updateHash), e.window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }
            getHashString() {
              const t2 = this._map;
              if (!t2)
                return "";
              const i2 = er(t2);
              if (this._hashName) {
                const t3 = this._hashName;
                let o2 = false;
                const r2 = e.window.location.hash.slice(1).split("&").map((e2) => {
                  const r3 = e2.split("=")[0];
                  return r3 === t3 ? (o2 = true, `${r3}=${i2}`) : e2;
                }).filter((e2) => e2);
                return o2 || r2.push(`${t3}=${i2}`), `#${r2.join("&")}`;
              }
              return `#${i2}`;
            }
            _getCurrentHash() {
              const t2 = e.window.location.hash.replace("#", "");
              if (this._hashName) {
                let e2;
                return t2.split("&").map((e3) => e3.split("=")).forEach((t3) => {
                  t3[0] === this._hashName && (e2 = t3);
                }), (e2 && e2[1] || "").split("/");
              }
              return t2.split("/");
            }
            _onHashChange() {
              const e2 = this._map;
              if (!e2)
                return false;
              const t2 = this._getCurrentHash();
              if (t2.length >= 3 && !t2.some((e3) => isNaN(e3))) {
                const i2 = e2.dragRotate.isEnabled() && e2.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : e2.getBearing();
                return e2.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: i2, pitch: +(t2[4] || 0) }), true;
              }
              return false;
            }
            _updateHashUnthrottled() {
              const t2 = e.window.location.href.replace(/(#.+)?$/, this.getHashString());
              e.window.history.replaceState(e.window.history.state, null, t2);
            }
          }
          function er(e2, t2) {
            const i2 = e2.getCenter(), o2 = Math.round(100 * e2.getZoom()) / 100, r2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), n2 = Math.pow(10, r2), s2 = Math.round(i2.lng * n2) / n2, a2 = Math.round(i2.lat * n2) / n2, l2 = e2.getBearing(), c2 = e2.getPitch();
            let h2 = t2 ? `/${s2}/${a2}/${o2}` : `${o2}/${a2}/${s2}`;
            return (l2 || c2) && (h2 += "/" + Math.round(10 * l2) / 10), c2 && (h2 += `/${Math.round(c2)}`), h2;
          }
          const tr = { linearity: 0.3, easing: e.bezier(0, 0, 0.3, 1) }, ir = e.extend({ deceleration: 2500, maxSpeed: 1400 }, tr), or = e.extend({ deceleration: 20, maxSpeed: 1400 }, tr), rr = e.extend({ deceleration: 1e3, maxSpeed: 360 }, tr), nr = e.extend({ deceleration: 1e3, maxSpeed: 90 }, tr);
          class sr {
            constructor(e2) {
              this._map = e2, this.clear();
            }
            clear() {
              this._inertiaBuffer = [];
            }
            record(t2) {
              this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.exported.now(), settings: t2 });
            }
            _drainInertiaBuffer() {
              const t2 = this._inertiaBuffer, i2 = e.exported.now();
              for (; t2.length > 0 && i2 - t2[0].time > 160; )
                t2.shift();
            }
            _onMoveEnd(t2) {
              if (e.exported.prefersReducedMotion)
                return;
              if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                return;
              const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
              for (const { settings: e2 } of this._inertiaBuffer)
                i2.zoom += e2.zoomDelta || 0, i2.bearing += e2.bearingDelta || 0, i2.pitch += e2.pitchDelta || 0, e2.panDelta && i2.pan._add(e2.panDelta), e2.around && (i2.around = e2.around), e2.pinchAround && (i2.pinchAround = e2.pinchAround);
              const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r2 = {};
              if (i2.pan.mag()) {
                const n2 = lr(i2.pan.mag(), o2, e.extend({}, ir, t2 || {}));
                r2.offset = i2.pan.mult(n2.amount / i2.pan.mag()), r2.center = this._map.transform.center, ar(r2, n2);
              }
              if (i2.zoom) {
                const e2 = lr(i2.zoom, o2, or);
                r2.zoom = this._map.transform.zoom + e2.amount, ar(r2, e2);
              }
              if (i2.bearing) {
                const t3 = lr(i2.bearing, o2, rr);
                r2.bearing = this._map.transform.bearing + e.clamp(t3.amount, -179, 179), ar(r2, t3);
              }
              if (i2.pitch) {
                const e2 = lr(i2.pitch, o2, nr);
                r2.pitch = this._map.transform.pitch + e2.amount, ar(r2, e2);
              }
              if (r2.zoom || r2.bearing) {
                const e2 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
                r2.around = e2 ? this._map.unproject(e2) : this._map.getCenter();
              }
              return this.clear(), r2.noMoveStart = true, r2;
            }
          }
          function ar(e2, t2) {
            (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
          }
          function lr(t2, i2, o2) {
            const { maxSpeed: r2, linearity: n2, deceleration: s2 } = o2, a2 = e.clamp(t2 * n2 / (i2 / 1e3), -r2, r2), l2 = Math.abs(a2) / (s2 * n2);
            return { easing: o2.easing, duration: 1e3 * l2, amount: a2 * (l2 / 2) };
          }
          class cr extends e.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(t2, i2, o2, r2 = {}) {
              const n2 = p(i2.getCanvasContainer(), o2), s2 = i2.unproject(n2);
              super(t2, e.extend({ point: n2, lngLat: s2, originalEvent: o2 }, r2)), this._defaultPrevented = false, this.target = i2;
            }
          }
          class hr extends e.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(t2, i2, o2) {
              const r2 = "touchend" === t2 ? o2.changedTouches : o2.touches, n2 = m(i2.getCanvasContainer(), r2), s2 = n2.map((e2) => i2.unproject(e2)), a2 = n2.reduce((e2, t3, i3, o3) => e2.add(t3.div(o3.length)), new e.pointGeometry(0, 0));
              super(t2, { points: n2, point: a2, lngLats: s2, lngLat: i2.unproject(a2), originalEvent: o2 }), this._defaultPrevented = false;
            }
          }
          class ur extends e.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e2, t2, i2) {
              super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
            }
          }
          class _r {
            constructor(e2, t2) {
              this._map = e2, this._clickTolerance = t2.clickTolerance;
            }
            reset() {
              this._mousedownPos = void 0;
            }
            wheel(e2) {
              return this._firePreventable(new ur(e2.type, this._map, e2));
            }
            mousedown(e2, t2) {
              return this._mousedownPos = t2, this._firePreventable(new cr(e2.type, this._map, e2));
            }
            mouseup(e2) {
              this._map.fire(new cr(e2.type, this._map, e2));
            }
            preclick(t2) {
              const i2 = e.extend({}, t2);
              i2.type = "preclick", this._map.fire(new cr(i2.type, this._map, i2));
            }
            click(e2, t2) {
              this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || (this.preclick(e2), this._map.fire(new cr(e2.type, this._map, e2)));
            }
            dblclick(e2) {
              return this._firePreventable(new cr(e2.type, this._map, e2));
            }
            mouseover(e2) {
              this._map.fire(new cr(e2.type, this._map, e2));
            }
            mouseout(e2) {
              this._map.fire(new cr(e2.type, this._map, e2));
            }
            touchstart(e2) {
              return this._firePreventable(new hr(e2.type, this._map, e2));
            }
            touchmove(e2) {
              this._map.fire(new hr(e2.type, this._map, e2));
            }
            touchend(e2) {
              this._map.fire(new hr(e2.type, this._map, e2));
            }
            touchcancel(e2) {
              this._map.fire(new hr(e2.type, this._map, e2));
            }
            _firePreventable(e2) {
              if (this._map.fire(e2), e2.defaultPrevented)
                return {};
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class dr {
            constructor(e2) {
              this._map = e2;
            }
            reset() {
              this._delayContextMenu = false, this._contextMenuEvent = void 0;
            }
            mousemove(e2) {
              this._map.fire(new cr(e2.type, this._map, e2));
            }
            mousedown() {
              this._delayContextMenu = true;
            }
            mouseup() {
              this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new cr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e2) {
              this._delayContextMenu ? this._contextMenuEvent = e2 : this._map.fire(new cr(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class pr {
            constructor(e2, t2) {
              this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            enable() {
              this.isEnabled() || (this._enabled = true);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            mousedown(e2, t2) {
              this.isEnabled() && e2.shiftKey && 0 === e2.button && (h(), this._startPos = this._lastPos = t2, this._active = true);
            }
            mousemoveWindow(e2, t2) {
              if (!this._active)
                return;
              const i2 = t2, o2 = this._startPos, r2 = this._lastPos;
              if (!o2 || !r2 || r2.equals(i2) || !this._box && i2.dist(o2) < this._clickTolerance)
                return;
              this._lastPos = i2, this._box || (this._box = n("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e2));
              const s2 = Math.min(o2.x, i2.x), a2 = Math.max(o2.x, i2.x), l2 = Math.min(o2.y, i2.y), c2 = Math.max(o2.y, i2.y);
              this._map._requestDomTask(() => {
                this._box && (this._box.style.transform = `translate(${s2}px,${l2}px)`, this._box.style.width = a2 - s2 + "px", this._box.style.height = c2 - l2 + "px");
              });
            }
            mouseupWindow(t2, i2) {
              if (!this._active)
                return;
              const o2 = this._startPos, r2 = i2;
              if (o2 && 0 === t2.button) {
                if (this.reset(), d(), o2.x !== r2.x || o2.y !== r2.y)
                  return this._map.fire(new e.Event("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (e2) => e2.fitScreenCoordinates(o2, r2, this._map.getBearing(), { linear: false }) };
                this._fireEvent("boxzoomcancel", t2);
              }
            }
            keydown(e2) {
              this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(t2, i2) {
              return this._map.fire(new e.Event(t2, { originalEvent: i2 }));
            }
          }
          function mr(e2, t2) {
            const i2 = {};
            for (let o2 = 0; o2 < e2.length; o2++)
              i2[e2[o2].identifier] = t2[o2];
            return i2;
          }
          class fr {
            constructor(e2) {
              this.reset(), this.numTouches = e2.numTouches;
            }
            reset() {
              this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
            }
            touchstart(t2, i2, o2) {
              (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t2.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
                const i3 = new e.pointGeometry(0, 0);
                for (const e2 of t3)
                  i3._add(e2);
                return i3.div(t3.length);
              }(i2), this.touches = mr(o2, i2)));
            }
            touchmove(e2, t2, i2) {
              if (this.aborted || !this.centroid)
                return;
              const o2 = mr(i2, t2);
              for (const e3 in this.touches) {
                const t3 = this.touches[e3], i3 = o2[e3];
                (!i3 || i3.dist(t3) > 30) && (this.aborted = true);
              }
            }
            touchend(e2, t2, i2) {
              if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
                const e3 = !this.aborted && this.centroid;
                if (this.reset(), e3)
                  return e3;
              }
            }
          }
          class gr {
            constructor(e2) {
              this.singleTap = new fr(e2), this.numTaps = e2.numTaps, this.reset();
            }
            reset() {
              this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }
            touchstart(e2, t2, i2) {
              this.singleTap.touchstart(e2, t2, i2);
            }
            touchmove(e2, t2, i2) {
              this.singleTap.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              const o2 = this.singleTap.touchend(e2, t2, i2);
              if (o2) {
                const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
                if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
                  return this.reset(), o2;
              }
            }
          }
          class vr {
            constructor() {
              this._zoomIn = new gr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new gr({ numTouches: 2, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e2, t2, i2) {
              this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
            }
            touchmove(e2, t2, i2) {
              this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              const o2 = this._zoomIn.touchend(e2, t2, i2), r2 = this._zoomOut.touchend(e2, t2, i2);
              return o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e2 }) }) : r2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(r2) }, { originalEvent: e2 }) }) : void 0;
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          const xr = { 0: 1, 2: 2 };
          class yr {
            constructor(e2) {
              this.reset(), this._clickTolerance = e2.clickTolerance || 1;
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
            }
            _correctButton(e2, t2) {
              return false;
            }
            _move(e2, t2) {
              return {};
            }
            mousedown(e2, t2) {
              if (this._lastPoint)
                return;
              const i2 = f(e2);
              this._correctButton(e2, i2) && (this._lastPoint = t2, this._eventButton = i2);
            }
            mousemoveWindow(e2, t2) {
              const i2 = this._lastPoint;
              if (i2) {
                if (e2.preventDefault(), null != this._eventButton && function(e3, t3) {
                  const i3 = xr[t3];
                  return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
                }(e2, this._eventButton))
                  this.reset();
                else if (this._moved || !(t2.dist(i2) < this._clickTolerance))
                  return this._moved = true, this._lastPoint = t2, this._move(i2, t2);
              }
            }
            mouseupWindow(e2) {
              this._lastPoint && f(e2) === this._eventButton && (this._moved && d(), this.reset());
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class br extends yr {
            mousedown(e2, t2) {
              super.mousedown(e2, t2), this._lastPoint && (this._active = true);
            }
            _correctButton(e2, t2) {
              return 0 === t2 && !e2.ctrlKey;
            }
            _move(e2, t2) {
              return { around: t2, panDelta: t2.sub(e2) };
            }
          }
          class wr extends yr {
            _correctButton(e2, t2) {
              return 0 === t2 && e2.ctrlKey || 2 === t2;
            }
            _move(e2, t2) {
              const i2 = 0.8 * (t2.x - e2.x);
              if (i2)
                return this._active = true, { bearingDelta: i2 };
            }
            contextmenu(e2) {
              e2.preventDefault();
            }
          }
          class Tr extends yr {
            _correctButton(e2, t2) {
              return 0 === t2 && e2.ctrlKey || 2 === t2;
            }
            _move(e2, t2) {
              const i2 = -0.5 * (t2.y - e2.y);
              if (i2)
                return this._active = true, { pitchDelta: i2 };
            }
            contextmenu(e2) {
              e2.preventDefault();
            }
          }
          class Er {
            constructor(t2, i2) {
              this._map = t2, this._el = t2.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i2.clickTolerance || 1, this.reset(), e.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
            }
            reset() {
              this._active = false, this._touches = {}, this._sum = new e.pointGeometry(0, 0);
            }
            touchstart(e2, t2, i2) {
              return this._calculateTransform(e2, t2, i2);
            }
            touchmove(t2, i2, o2) {
              if (this._active && !(o2.length < this._minTouches)) {
                if (this._map._cooperativeGestures && !this._map.isMoving()) {
                  if (1 === o2.length && !e.isFullscreen())
                    return void this._showTouchPanBlockerAlert();
                  "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }
                return t2.cancelable && t2.preventDefault(), this._calculateTransform(t2, i2, o2);
              }
            }
            touchend(e2, t2, i2) {
              this._calculateTransform(e2, t2, i2), this._active && i2.length < this._minTouches && this.reset();
            }
            touchcancel() {
              this.reset();
            }
            _calculateTransform(t2, i2, o2) {
              o2.length > 0 && (this._active = true);
              const r2 = mr(o2, i2), n2 = new e.pointGeometry(0, 0), s2 = new e.pointGeometry(0, 0);
              let a2 = 0;
              for (const e2 in r2) {
                const t3 = r2[e2], i3 = this._touches[e2];
                i3 && (n2._add(t3), s2._add(t3.sub(i3)), a2++, r2[e2] = t3);
              }
              if (this._touches = r2, a2 < this._minTouches || !s2.mag())
                return;
              const l2 = s2.div(a2);
              return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: n2.div(a2), panDelta: l2 };
            }
            enable() {
              this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }
            disable() {
              this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            _addTouchPanBlocker() {
              this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
              this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
                this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
              }, 500);
            }
          }
          class Cr {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false, this._firstTwoTouches = void 0;
            }
            _start(e2) {
            }
            _move(e2, t2, i2) {
              return {};
            }
            touchstart(e2, t2, i2) {
              this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
            }
            touchmove(e2, t2, i2) {
              const o2 = this._firstTwoTouches;
              if (!o2)
                return;
              e2.preventDefault();
              const [r2, n2] = o2, s2 = Mr(i2, t2, r2), a2 = Mr(i2, t2, n2);
              if (!s2 || !a2)
                return;
              const l2 = this._aroundCenter ? null : s2.add(a2).div(2);
              return this._move([s2, a2], l2, e2);
            }
            touchend(e2, t2, i2) {
              if (!this._firstTwoTouches)
                return;
              const [o2, r2] = this._firstTwoTouches, n2 = Mr(i2, t2, o2), s2 = Mr(i2, t2, r2);
              n2 && s2 || (this._active && d(), this.reset());
            }
            touchcancel() {
              this.reset();
            }
            enable(e2) {
              this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          function Mr(e2, t2, i2) {
            for (let o2 = 0; o2 < e2.length; o2++)
              if (e2[o2].identifier === i2)
                return t2[o2];
          }
          function Ir(e2, t2) {
            return Math.log(e2 / t2) / Math.LN2;
          }
          class Sr extends Cr {
            reset() {
              super.reset(), this._distance = 0, this._startDistance = 0;
            }
            _start(e2) {
              this._startDistance = this._distance = e2[0].dist(e2[1]);
            }
            _move(e2, t2) {
              const i2 = this._distance;
              if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(Ir(this._distance, this._startDistance)) < 0.1))
                return this._active = true, { zoomDelta: Ir(this._distance, i2), pinchAround: t2 };
            }
          }
          function Dr(e2, t2) {
            return 180 * e2.angleWith(t2) / Math.PI;
          }
          class Lr extends Cr {
            reset() {
              super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }
            _start(e2) {
              this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
            }
            _move(e2, t2) {
              const i2 = this._vector;
              if (this._vector = e2[0].sub(e2[1]), i2 && (this._active || !this._isBelowThreshold(this._vector)))
                return this._active = true, { bearingDelta: Dr(this._vector, i2), pinchAround: t2 };
            }
            _isBelowThreshold(e2) {
              this._minDiameter = Math.min(this._minDiameter, e2.mag());
              const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = this._startVector;
              if (!i2)
                return false;
              const o2 = Dr(e2, i2);
              return Math.abs(o2) < t2;
            }
          }
          function Ar(e2) {
            return Math.abs(e2.y) > Math.abs(e2.x);
          }
          class zr extends Cr {
            constructor(e2) {
              super(), this._map = e2;
            }
            reset() {
              super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }
            _start(e2) {
              this._lastPoints = e2, Ar(e2[0].sub(e2[1])) && (this._valid = false);
            }
            _move(t2, i2, o2) {
              const r2 = this._lastPoints;
              if (!r2)
                return;
              const n2 = t2[0].sub(r2[0]), s2 = t2[1].sub(r2[1]);
              return this._map._cooperativeGestures && !e.isFullscreen() && o2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n2, s2, o2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t2, this._active = true, { pitchDelta: (n2.y + s2.y) / 2 * -0.5 });
            }
            gestureBeginsVertically(e2, t2, i2) {
              if (void 0 !== this._valid)
                return this._valid;
              const o2 = e2.mag() >= 2, r2 = t2.mag() >= 2;
              if (!o2 && !r2)
                return;
              if (!o2 || !r2)
                return null == this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
              const n2 = e2.y > 0 == t2.y > 0;
              return Ar(e2) && Ar(t2) && n2;
            }
          }
          const Pr = { panStep: 100, bearingStep: 15, pitchStep: 10 };
          class Rr {
            constructor() {
              const e2 = Pr;
              this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            keydown(e2) {
              if (e2.altKey || e2.ctrlKey || e2.metaKey)
                return;
              let t2 = 0, i2 = 0, o2 = 0, r2 = 0, n2 = 0;
              switch (e2.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  t2 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  t2 = -1;
                  break;
                case 37:
                  e2.shiftKey ? i2 = -1 : (e2.preventDefault(), r2 = -1);
                  break;
                case 39:
                  e2.shiftKey ? i2 = 1 : (e2.preventDefault(), r2 = 1);
                  break;
                case 38:
                  e2.shiftKey ? o2 = 1 : (e2.preventDefault(), n2 = -1);
                  break;
                case 40:
                  e2.shiftKey ? o2 = -1 : (e2.preventDefault(), n2 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (s2) => {
                const a2 = s2.getZoom();
                s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Or, zoom: t2 ? Math.round(a2) + t2 * (e2.shiftKey ? 2 : 1) : a2, bearing: s2.getBearing() + i2 * this._bearingStep, pitch: s2.getPitch() + o2 * this._pitchStep, offset: [-r2 * this._panStep, -n2 * this._panStep], center: s2.getCenter() }, { originalEvent: e2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            disableRotation() {
              this._rotationDisabled = true;
            }
            enableRotation() {
              this._rotationDisabled = false;
            }
          }
          function Or(e2) {
            return e2 * (2 - e2);
          }
          const Br = 4.000244140625;
          class kr {
            constructor(t2, i2) {
              this._map = t2, this._el = t2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, e.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
            }
            setZoomRate(e2) {
              this._defaultZoomRate = e2;
            }
            setWheelZoomRate(e2) {
              this._wheelZoomRate = e2;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
              return !!this._zooming;
            }
            enable(e2) {
              this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
              this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }
            wheel(t2) {
              if (!this.isEnabled())
                return;
              if (this._map._cooperativeGestures) {
                if (!(t2.ctrlKey || t2.metaKey || this.isZooming() || e.isFullscreen()))
                  return void this._showBlockerAlert();
                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              let i2 = t2.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
              const o2 = e.exported.now(), r2 = o2 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = o2, 0 !== i2 && i2 % Br == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(r2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= i2, this._active || this._start(t2)), t2.preventDefault();
            }
            _onTimeout(e2) {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e2);
            }
            _start(e2) {
              if (!this._delta)
                return;
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              const t2 = p(this._el, e2);
              this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
            }
            renderFrame() {
              if (!this._frameId)
                return;
              if (this._frameId = null, !this.isActive())
                return;
              const t2 = this._map.transform;
              "wheel" === this._type && t2.projection.wrap && (t2._center.lng >= 180 || t2._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
              const i2 = () => t2._terrainEnabled() && this._aroundCoord ? t2.computeZoomRelativeTo(this._aroundCoord) : t2.zoom;
              if (0 !== this._delta) {
                const e2 = "wheel" === this._type && Math.abs(this._delta) > Br ? this._wheelZoomRate : this._defaultZoomRate;
                let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
                this._delta < 0 && 0 !== o3 && (o3 = 1 / o3);
                const r3 = i2(), n3 = Math.pow(2, r3), s3 = "number" == typeof this._targetZoom ? t2.zoomScale(this._targetZoom) : n3;
                this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(s3 * o3))), "wheel" === this._type && (this._startZoom = r3, this._easing = this._smoothOutEasing(200)), this._delta = 0;
              }
              const o2 = "number" == typeof this._targetZoom ? this._targetZoom : i2(), r2 = this._startZoom, n2 = this._easing;
              let s2, a2 = false;
              if ("wheel" === this._type && r2 && n2) {
                const t3 = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1), i3 = n2(t3);
                s2 = e.number(r2, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : a2 = true;
              } else
                s2 = o2, a2 = true;
              return this._active = true, a2 && (this._active = false, this._finishTimeout = setTimeout(() => {
                this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
              }, 200)), { noInertia: true, needsRenderFrame: !a2, zoomDelta: s2 - i2(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
            }
            _smoothOutEasing(t2) {
              let i2 = e.ease;
              if (this._prevEase) {
                const t3 = this._prevEase, o2 = (e.exported.now() - t3.start) / t3.duration, r2 = t3.easing(o2 + 0.01) - t3.easing(o2), n2 = 0.27 / Math.sqrt(r2 * r2 + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - n2 * n2);
                i2 = e.bezier(n2, s2, 0.25, 1);
              }
              return this._prevEase = { start: e.exported.now(), duration: t2, easing: i2 }, i2;
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            _addScrollZoomBlocker() {
              this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
              this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
                this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
              }, 200);
            }
          }
          class Fr {
            constructor(e2, t2) {
              this._clickZoom = e2, this._tapZoom = t2;
            }
            enable() {
              this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
              this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
              return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
              return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
          }
          class Ur {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            blur() {
              this.reset();
            }
            dblclick(e2, t2) {
              return e2.preventDefault(), { cameraAnimation: (i2) => {
                i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e2.shiftKey ? -1 : 1), around: i2.unproject(t2) }, { originalEvent: e2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Nr {
            constructor() {
              this._tap = new gr({ numTouches: 1, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }
            touchstart(e2, t2, i2) {
              this._swipePoint || (this._tapTime && e2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e2, t2, i2));
            }
            touchmove(e2, t2, i2) {
              if (this._tapTime) {
                if (this._swipePoint) {
                  if (i2[0].identifier !== this._swipeTouch)
                    return;
                  const o2 = t2[0], r2 = o2.y - this._swipePoint.y;
                  return this._swipePoint = o2, e2.preventDefault(), this._active = true, { zoomDelta: r2 / 128 };
                }
              } else
                this._tap.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(e2, t2, i2) && (this._tapTime = e2.timeStamp);
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Gr {
            constructor(e2, t2, i2) {
              this._el = e2, this._mousePan = t2, this._touchPan = i2;
            }
            enable(e2) {
              this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
              this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
              return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
              return this._mousePan.isActive() || this._touchPan.isActive();
            }
          }
          class jr {
            constructor(e2, t2, i2) {
              this._pitchWithRotate = e2.pitchWithRotate, this._mouseRotate = t2, this._mousePitch = i2;
            }
            enable() {
              this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
              this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
              return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
              return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
          }
          class Zr {
            constructor(e2, t2, i2, o2) {
              this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
            }
            enable(e2) {
              this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
              this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
              return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
              return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
              this._rotationDisabled = true, this._touchRotate.disable();
            }
            enableRotation() {
              this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
          }
          const Vr = (e2) => e2.zoom || e2.drag || e2.pitch || e2.rotate;
          class Wr extends e.Event {
          }
          class Xr {
            constructor() {
              this.constants = [1, 1, 0.01], this.radius = 0;
            }
            setup(t2, i2) {
              const o2 = e.sub([], i2, t2);
              this.radius = e.length(o2[2] < 0 ? e.div([], o2, this.constants) : [o2[0], o2[1], 0]);
            }
            projectRay(t2) {
              e.div(t2, t2, this.constants), e.normalize(t2, t2), e.mul$1(t2, t2, this.constants);
              const i2 = e.scale$2([], t2, this.radius);
              if (i2[2] > 0) {
                const t3 = e.scale$2([], [0, 0, 1], e.dot(i2, [0, 0, 1])), o2 = e.scale$2([], e.normalize([], [i2[0], i2[1], 0]), this.radius), r2 = e.add([], i2, e.scale$2([], e.sub([], e.add([], o2, t3), i2), 2));
                i2[0] = r2[0], i2[1] = r2[1];
              }
              return i2;
            }
          }
          function qr(e2) {
            return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta;
          }
          class $r {
            constructor(t2, i2) {
              this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new sr(t2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Xr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e.bindAll(["handleEvent", "handleWindowEvent"], this);
              const o2 = this._el;
              this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [e.window.document, "mousemove", { capture: true }], [e.window.document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [e.window, "blur", void 0]];
              for (const [t3, i3, o3] of this._listeners)
                t3.addEventListener(i3, t3 === e.window.document ? this.handleWindowEvent : this.handleEvent, o3);
            }
            destroy() {
              for (const [t2, i2, o2] of this._listeners)
                t2.removeEventListener(i2, t2 === e.window.document ? this.handleWindowEvent : this.handleEvent, o2);
            }
            _addDefaultHandlers(e2) {
              const t2 = this._map, i2 = t2.getCanvasContainer();
              this._add("mapEvent", new _r(t2, e2));
              const o2 = t2.boxZoom = new pr(t2, e2);
              this._add("boxZoom", o2);
              const r2 = new vr(), n2 = new Ur();
              t2.doubleClickZoom = new Fr(n2, r2), this._add("tapZoom", r2), this._add("clickZoom", n2);
              const s2 = new Nr();
              this._add("tapDragZoom", s2);
              const a2 = t2.touchPitch = new zr(t2);
              this._add("touchPitch", a2);
              const l2 = new wr(e2), c2 = new Tr(e2);
              t2.dragRotate = new jr(e2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
              const h2 = new br(e2), u2 = new Er(t2, e2);
              t2.dragPan = new Gr(i2, h2, u2), this._add("mousePan", h2), this._add("touchPan", u2, ["touchZoom", "touchRotate"]);
              const _2 = new Lr(), d2 = new Sr();
              t2.touchZoomRotate = new Zr(i2, d2, _2, s2), this._add("touchRotate", _2, ["touchPan", "touchZoom"]), this._add("touchZoom", d2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new dr(t2));
              const p2 = t2.scrollZoom = new kr(t2, this);
              this._add("scrollZoom", p2, ["mousePan"]);
              const m2 = t2.keyboard = new Rr();
              this._add("keyboard", m2);
              for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                e2.interactive && e2[i3] && t2[i3].enable(e2[i3]);
            }
            _add(e2, t2, i2) {
              this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
            }
            stop(e2) {
              if (!this._updatingCamera) {
                for (const { handler: e3 } of this._handlers)
                  e3.reset();
                this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
              }
            }
            isActive() {
              for (const { handler: e2 } of this._handlers)
                if (e2.isActive())
                  return true;
              return false;
            }
            isZooming() {
              return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
              return !!this._eventsInProgress.rotate;
            }
            isMoving() {
              return !!Vr(this._eventsInProgress) || this.isZooming();
            }
            _isDragging() {
              return !!this._eventsInProgress.drag;
            }
            _blockedByActive(e2, t2, i2) {
              for (const o2 in e2)
                if (o2 !== i2 && (!t2 || t2.indexOf(o2) < 0))
                  return true;
              return false;
            }
            handleWindowEvent(e2) {
              this.handleEvent(e2, `${e2.type}Window`);
            }
            _getMapTouches(e2) {
              const t2 = [];
              for (const i2 of e2)
                this._el.contains(i2.target) && t2.push(i2);
              return t2;
            }
            handleEvent(e2, t2) {
              this._updatingCamera = true;
              const i2 = "renderFrame" === e2.type, o2 = i2 ? void 0 : e2, r2 = { needsRenderFrame: false }, n2 = {}, s2 = {}, a2 = e2.touches ? this._getMapTouches(e2.touches) : void 0, l2 = a2 ? m(this._el, a2) : i2 ? void 0 : p(this._el, e2);
              for (const { handlerName: i3, handler: c3, allowed: h3 } of this._handlers) {
                if (!c3.isEnabled())
                  continue;
                let u2;
                this._blockedByActive(s2, h3, i3) ? c3.reset() : c3[t2 || e2.type] && (u2 = c3[t2 || e2.type](e2, l2, a2), this.mergeHandlerResult(r2, n2, u2, i3, o2), u2 && u2.needsRenderFrame && this._triggerRenderFrame()), (u2 || c3.isActive()) && (s2[i3] = c3);
              }
              const c2 = {};
              for (const e3 in this._previousActiveHandlers)
                s2[e3] || (c2[e3] = o2);
              this._previousActiveHandlers = s2, (Object.keys(c2).length || qr(r2)) && (this._changes.push([r2, n2, c2]), this._triggerRenderFrame()), (Object.keys(s2).length || qr(r2)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: h2 } = r2;
              h2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h2(this._map));
            }
            mergeHandlerResult(t2, i2, o2, r2, n2) {
              if (!o2)
                return;
              e.extend(t2, o2);
              const s2 = { handlerName: r2, originalEvent: o2.originalEvent || n2 };
              void 0 !== o2.zoomDelta && (i2.zoom = s2), void 0 !== o2.panDelta && (i2.drag = s2), void 0 !== o2.pitchDelta && (i2.pitch = s2), void 0 !== o2.bearingDelta && (i2.rotate = s2);
            }
            _applyChanges() {
              const t2 = {}, i2 = {}, o2 = {};
              for (const [r2, n2, s2] of this._changes)
                r2.panDelta && (t2.panDelta = (t2.panDelta || new e.pointGeometry(0, 0))._add(r2.panDelta)), r2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + r2.zoomDelta), r2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + r2.bearingDelta), r2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + r2.pitchDelta), void 0 !== r2.around && (t2.around = r2.around), void 0 !== r2.aroundCoord && (t2.aroundCoord = r2.aroundCoord), void 0 !== r2.pinchAround && (t2.pinchAround = r2.pinchAround), r2.noInertia && (t2.noInertia = r2.noInertia), e.extend(i2, n2), e.extend(o2, s2);
              this._updateMapTransform(t2, i2, o2), this._changes = [];
            }
            _updateMapTransform(t2, i2, o2) {
              const r2 = this._map, n2 = r2.transform, s2 = (e2) => [e2.x, e2.y, e2.z];
              if (((e2) => {
                const t3 = this._eventsInProgress.drag;
                return t3 && !this._handlersById[t3.handlerName].isActive();
              })() && !qr(t2)) {
                const e2 = n2.zoom;
                n2.cameraElevationReference = "sea", n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", e2 !== n2.zoom && this._map._update(true);
              }
              if (n2._isCameraConstrained && r2._stop(true), !qr(t2))
                return void this._fireEvents(i2, o2, true);
              let { panDelta: a2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h2, around: u2, aroundCoord: _2, pinchAround: d2 } = t2;
              n2._isCameraConstrained && (l2 > 0 && (l2 = 0), n2._isCameraConstrained = false), void 0 !== d2 && (u2 = d2), (l2 || ((e2) => i2.drag && !this._eventsInProgress.drag)()) && u2 && (this._dragOrigin = s2(n2.pointCoordinate3D(u2)), this._trackingEllipsoid.setup(n2._camera.position, this._dragOrigin)), n2.cameraElevationReference = "sea", r2._stop(true), u2 = u2 || r2.transform.centerPoint, c2 && (n2.bearing += c2), h2 && (n2.pitch += h2), n2._updateCameraState();
              const p2 = [0, 0, 0];
              if (a2)
                if ("mercator" === n2.projection.name) {
                  const e2 = this._trackingEllipsoid.projectRay(n2.screenPointToMercatorRay(u2).dir), t3 = this._trackingEllipsoid.projectRay(n2.screenPointToMercatorRay(u2.sub(a2)).dir);
                  p2[0] = t3[0] - e2[0], p2[1] = t3[1] - e2[1];
                } else {
                  const t3 = n2.pointCoordinate(u2);
                  if ("globe" === n2.projection.name) {
                    a2 = a2.rotate(-n2.angle);
                    const i3 = n2._pixelsPerMercatorPixel / n2.worldSize;
                    p2[0] = -a2.x * e.mercatorScale(e.latFromMercatorY(t3.y)) * i3, p2[1] = -a2.y * e.mercatorScale(n2.center.lat) * i3;
                  } else {
                    const e2 = n2.pointCoordinate(u2.sub(a2));
                    t3 && e2 && (p2[0] = e2.x - t3.x, p2[1] = e2.y - t3.y);
                  }
                }
              const m2 = n2.zoom, f2 = [0, 0, 0];
              if (l2) {
                const t3 = s2(_2 || n2.pointCoordinate3D(u2)), i3 = { dir: e.normalize([], e.sub([], t3, n2._camera.position)) };
                if (i3.dir[2] < 0) {
                  const o3 = n2.zoomDeltaToMovement(t3, l2);
                  e.scale$2(f2, i3.dir, o3);
                }
              }
              const g2 = e.add(p2, p2, f2);
              n2._translateCameraConstrained(g2), l2 && Math.abs(n2.zoom - m2) > 1e-4 && n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(i2, o2, true);
            }
            _fireEvents(t2, i2, o2) {
              const r2 = Vr(this._eventsInProgress), n2 = Vr(t2), s2 = {};
              for (const e2 in t2) {
                const { originalEvent: i3 } = t2[e2];
                this._eventsInProgress[e2] || (s2[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
              }
              !r2 && n2 && this._fireEvent("movestart", n2.originalEvent);
              for (const e2 in s2)
                this._fireEvent(e2, s2[e2]);
              n2 && this._fireEvent("move", n2.originalEvent);
              for (const e2 in t2) {
                const { originalEvent: i3 } = t2[e2];
                this._fireEvent(e2, i3);
              }
              const a2 = {};
              let l2;
              for (const e2 in this._eventsInProgress) {
                const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e2];
                this._handlersById[t3].isActive() || (delete this._eventsInProgress[e2], l2 = i2[t3] || o3, a2[`${e2}end`] = l2);
              }
              for (const e2 in a2)
                this._fireEvent(e2, a2[e2]);
              const c2 = Vr(this._eventsInProgress);
              if (o2 && (r2 || n2) && !c2) {
                this._updatingCamera = true;
                const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e2) => 0 !== e2 && -this._bearingSnap < e2 && e2 < this._bearingSnap;
                t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l2 })) : (this._map.fire(new e.Event("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
              }
            }
            _fireEvent(t2, i2) {
              this._map.fire(new e.Event(t2, i2 ? { originalEvent: i2 } : {}));
            }
            _requestFrame() {
              return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
                this._frameId = void 0, this.handleEvent(new Wr("renderFrame", { timeStamp: e2 })), this._applyChanges();
              });
            }
            _triggerRenderFrame() {
              void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
          }
          const Hr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
          class Yr extends e.Evented {
            constructor(t2, i2) {
              super(), this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = i2.bearingSnap, e.bindAll(["_renderFrameCallback"], this);
            }
            getCenter() {
              return new e.LngLat(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e2, t2) {
              return this.jumpTo({ center: e2 }, t2);
            }
            panBy(t2, i2, o2) {
              return t2 = e.pointGeometry.convert(t2).mult(-1), this.panTo(this.transform.center, e.extend({ offset: t2 }, i2), o2);
            }
            panTo(t2, i2, o2) {
              return this.easeTo(e.extend({ center: t2 }, i2), o2);
            }
            getZoom() {
              return this.transform.zoom;
            }
            setZoom(e2, t2) {
              return this.jumpTo({ zoom: e2 }, t2), this;
            }
            zoomTo(t2, i2, o2) {
              return this.easeTo(e.extend({ zoom: t2 }, i2), o2);
            }
            zoomIn(e2, t2) {
              return this.zoomTo(this.getZoom() + 1, e2, t2), this;
            }
            zoomOut(e2, t2) {
              return this.zoomTo(this.getZoom() - 1, e2, t2), this;
            }
            getBearing() {
              return this.transform.bearing;
            }
            setBearing(e2, t2) {
              return this.jumpTo({ bearing: e2 }, t2), this;
            }
            getPadding() {
              return this.transform.padding;
            }
            setPadding(e2, t2) {
              return this.jumpTo({ padding: e2 }, t2), this;
            }
            rotateTo(t2, i2, o2) {
              return this.easeTo(e.extend({ bearing: t2 }, i2), o2);
            }
            resetNorth(t2, i2) {
              return this.rotateTo(0, e.extend({ duration: 1e3 }, t2), i2), this;
            }
            resetNorthPitch(t2, i2) {
              return this.easeTo(e.extend({ bearing: 0, pitch: 0, duration: 1e3 }, t2), i2), this;
            }
            snapToNorth(e2, t2) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
            }
            getPitch() {
              return this.transform.pitch;
            }
            setPitch(e2, t2) {
              return this.jumpTo({ pitch: e2 }, t2), this;
            }
            cameraForBounds(t2, i2) {
              t2 = e.LngLatBounds.convert(t2);
              const o2 = i2 && i2.bearing || 0, r2 = i2 && i2.pitch || 0, n2 = t2.getNorthWest(), s2 = t2.getSouthEast();
              return this._cameraForBounds(this.transform, n2, s2, o2, r2, i2);
            }
            _extendCameraOptions(t2) {
              const i2 = { top: 0, bottom: 0, right: 0, left: 0 };
              if ("number" == typeof (t2 = e.extend({ padding: i2, offset: [0, 0], maxZoom: this.transform.maxZoom }, t2)).padding) {
                const e2 = t2.padding;
                t2.padding = { top: e2, bottom: e2, right: e2, left: e2 };
              }
              return t2.padding = e.extend(i2, t2.padding), t2;
            }
            _minimumAABBFrustumDistance(e2, t2) {
              const i2 = t2.max[0] - t2.min[0], o2 = t2.max[1] - t2.min[1];
              return i2 / o2 > e2.aspect ? i2 / (2 * Math.tan(0.5 * e2.fovX) * e2.aspect) : o2 / (2 * Math.tan(0.5 * e2.fovY) * e2.aspect);
            }
            _cameraForBoundsOnGlobe(t2, i2, o2, r2, n2, s2) {
              const a2 = t2.clone(), l2 = this._extendCameraOptions(s2);
              a2.bearing = r2, a2.pitch = n2;
              const c2 = e.LngLat.convert(i2), h2 = e.LngLat.convert(o2), u2 = 0.5 * (c2.lat + h2.lat), _2 = 0.5 * (c2.lng + h2.lng), d2 = e.latLngToECEF(u2, _2), p2 = e.normalize([], d2), m2 = e.normalize([], e.cross([], p2, [0, 1, 0])), f2 = e.cross([], m2, p2), g2 = [m2[0], m2[1], m2[2], 0, f2[0], f2[1], f2[2], 0, p2[0], p2[1], p2[2], 0, 0, 0, 0, 1], v2 = [d2, e.latLngToECEF(c2.lat, c2.lng), e.latLngToECEF(h2.lat, c2.lng), e.latLngToECEF(h2.lat, h2.lng), e.latLngToECEF(c2.lat, h2.lng), e.latLngToECEF(u2, c2.lng), e.latLngToECEF(u2, h2.lng), e.latLngToECEF(c2.lat, _2), e.latLngToECEF(h2.lat, _2)];
              let x2 = e.Aabb.fromPoints(v2.map((t3) => [e.dot(m2, t3), e.dot(f2, t3), e.dot(p2, t3)]));
              const y2 = e.transformMat4([], x2.center, g2);
              0 === e.squaredLength(y2) && e.set(y2, 0, 0, 1), e.normalize(y2, y2), e.scale$2(y2, y2, e.GLOBE_RADIUS), a2.center = e.ecefToLatLng(y2);
              const b2 = a2.getWorldToCameraMatrix(), w2 = e.invert(new Float64Array(16), b2);
              x2 = e.Aabb.applyTransform(x2, e.multiply([], b2, g2)), e.transformMat4(y2, y2, b2);
              const T2 = 0.5 * (x2.max[2] - x2.min[2]), E2 = this._minimumAABBFrustumDistance(a2, x2), C2 = e.scale$2([], [0, 0, 1], T2), M2 = e.add(C2, y2, C2), I2 = E2 + (0 === a2.pitch ? 0 : e.distance(y2, M2)), S2 = a2.globeCenterInViewSpace, D2 = e.sub([], y2, [S2[0], S2[1], S2[2]]);
              e.normalize(D2, D2), e.scale$2(D2, D2, I2);
              const L2 = e.add([], y2, D2);
              e.transformMat4(L2, L2, w2);
              const A2 = e.earthRadius / e.GLOBE_RADIUS, z2 = e.length(L2), P2 = e.mercatorZfromAltitude(Math.max(z2 * A2 - e.earthRadius, Number.EPSILON), 0), R2 = Math.min(a2.zoomFromMercatorZAdjusted(P2), l2.maxZoom);
              return R2 > 0.5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a2.setProjection({ name: "mercator" }), a2.zoom = R2, this._cameraForBounds(a2, i2, o2, r2, n2, s2)) : { center: a2.center, zoom: R2, bearing: r2, pitch: n2 };
            }
            queryTerrainElevation(t2, i2) {
              const o2 = this.transform.elevation;
              return o2 ? (i2 = e.extend({}, { exaggerated: true }, i2), o2.getAtPoint(e.MercatorCoordinate.fromLngLat(t2), null, i2.exaggerated)) : null;
            }
            _cameraForBounds(t2, i2, o2, r2, n2, s2) {
              if ("globe" === t2.projection.name)
                return this._cameraForBoundsOnGlobe(t2, i2, o2, r2, n2, s2);
              const a2 = t2.clone(), l2 = this._extendCameraOptions(s2), c2 = a2.padding;
              a2.bearing = r2, a2.pitch = n2;
              const h2 = e.LngLat.convert(i2), u2 = e.LngLat.convert(o2), _2 = new e.LngLat(h2.lng, u2.lat), d2 = new e.LngLat(u2.lng, h2.lat), p2 = a2.project(h2), m2 = a2.project(u2), f2 = this.queryTerrainElevation(h2), g2 = this.queryTerrainElevation(u2), v2 = this.queryTerrainElevation(_2), x2 = this.queryTerrainElevation(d2), y2 = [[p2.x, p2.y, Math.min(f2 || 0, g2 || 0, v2 || 0, x2 || 0)], [m2.x, m2.y, Math.max(f2 || 0, g2 || 0, v2 || 0, x2 || 0)]];
              let b2 = e.Aabb.fromPoints(y2);
              const w2 = a2.getWorldToCameraMatrix(), T2 = e.invert(new Float64Array(16), w2);
              b2 = e.Aabb.applyTransform(b2, w2);
              const E2 = e.sub([], b2.max, b2.min), C2 = c2.left || 0, M2 = c2.right || 0, I2 = c2.bottom || 0, S2 = c2.top || 0, { left: D2, right: L2, top: A2, bottom: z2 } = l2.padding, P2 = 0.5 * (C2 + M2), R2 = 0.5 * (S2 + I2), O2 = Math.min(a2.scaleZoom(a2.scale * Math.min((a2.width - (C2 + M2 + D2 + L2)) / E2[0], (a2.height - (I2 + S2 + z2 + A2)) / E2[1])), l2.maxZoom), B2 = a2.scale / a2.zoomScale(O2);
              b2 = new e.Aabb([b2.min[0] - (D2 + P2) * B2, b2.min[1] - (z2 + R2) * B2, b2.min[2]], [b2.max[0] + (L2 + P2) * B2, b2.max[1] + (A2 + R2) * B2, b2.max[2]]);
              const k2 = 0.5 * E2[2], F2 = this._minimumAABBFrustumDistance(a2, b2), U2 = [0, 0, 1, 0];
              e.transformMat4$1(U2, U2, w2), e.normalize$2(U2, U2);
              const N2 = e.scale$2([], U2, F2 + k2), G2 = e.add([], b2.center, N2), j2 = ("number" == typeof l2.offset.x && "number" == typeof l2.offset.y ? new e.pointGeometry(l2.offset.x, l2.offset.y) : e.pointGeometry.convert(l2.offset)).rotate(-e.degToRad(r2));
              b2.center[0] -= j2.x * B2, b2.center[1] += j2.y * B2, e.transformMat4(b2.center, b2.center, T2), e.transformMat4(G2, G2, T2);
              const Z2 = [b2.center[0], b2.center[1], G2[2] * a2.pixelsPerMeter];
              e.scale$2(Z2, Z2, 1 / a2.worldSize);
              const V2 = e.lngFromMercatorX(Z2[0]), W2 = e.latFromMercatorY(Z2[1]), X2 = Math.min(a2._zoomFromMercatorZ(Z2[2]), l2.maxZoom), q2 = new e.LngLat(V2, W2);
              return a2.mercatorFromTransition && X2 < 0.5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a2.setProjection({ name: "globe" }), a2.zoom = X2, this._cameraForBounds(a2, i2, o2, r2, n2, s2)) : { center: q2, zoom: X2, bearing: r2, pitch: n2 };
            }
            fitBounds(e2, t2, i2) {
              const o2 = this.cameraForBounds(e2, t2);
              return this._fitInternal(o2, t2, i2);
            }
            fitScreenCoordinates(t2, i2, o2, r2, n2) {
              const s2 = e.pointGeometry.convert(t2), a2 = e.pointGeometry.convert(i2), l2 = new e.pointGeometry(Math.min(s2.x, a2.x), Math.min(s2.y, a2.y)), c2 = new e.pointGeometry(Math.max(s2.x, a2.x), Math.max(s2.y, a2.y));
              if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s2, a2))
                return this;
              const h2 = this.transform.pointLocation3D(l2), u2 = this.transform.pointLocation3D(c2), _2 = this.transform.pointLocation3D(new e.pointGeometry(l2.x, c2.y)), d2 = this.transform.pointLocation3D(new e.pointGeometry(c2.x, l2.y)), p2 = [Math.min(h2.lng, u2.lng, _2.lng, d2.lng), Math.min(h2.lat, u2.lat, _2.lat, d2.lat)], m2 = [Math.max(h2.lng, u2.lng, _2.lng, d2.lng), Math.max(h2.lat, u2.lat, _2.lat, d2.lat)], f2 = r2 && r2.pitch ? r2.pitch : this.getPitch(), g2 = this._cameraForBounds(this.transform, p2, m2, o2, f2, r2);
              return this._fitInternal(g2, r2, n2);
            }
            _fitInternal(t2, i2, o2) {
              return t2 ? (delete (i2 = e.extend(t2, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
            }
            jumpTo(t2, i2) {
              this.stop();
              const o2 = t2.preloadOnly ? this.transform.clone() : this.transform;
              let r2 = false, n2 = false, s2 = false;
              return "zoom" in t2 && o2.zoom !== +t2.zoom && (r2 = true, o2.zoom = +t2.zoom), void 0 !== t2.center && (o2.center = e.LngLat.convert(t2.center)), "bearing" in t2 && o2.bearing !== +t2.bearing && (n2 = true, o2.bearing = +t2.bearing), "pitch" in t2 && o2.pitch !== +t2.pitch && (s2 = true, o2.pitch = +t2.pitch), null == t2.padding || o2.isPaddingEqual(t2.padding) || (o2.padding = t2.padding), t2.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), r2 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), n2 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), s2 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)));
            }
            getFreeCameraOptions() {
              return this.transform.projection.supportsFreeCamera || e.warnOnce(Hr), this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(t2, i2) {
              const o2 = this.transform;
              if (!o2.projection.supportsFreeCamera)
                return e.warnOnce(Hr), this;
              this.stop();
              const r2 = o2.zoom, n2 = o2.pitch, s2 = o2.bearing;
              o2.setFreeCameraOptions(t2);
              const a2 = r2 !== o2.zoom, l2 = n2 !== o2.pitch, c2 = s2 !== o2.bearing;
              return this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), a2 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), c2 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), l2 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)), this;
            }
            easeTo(t2, i2) {
              this._stop(false, t2.easeId), (false === (t2 = e.extend({ offset: [0, 0], duration: 500, easing: e.ease }, t2)).animate || !t2.essential && e.exported.prefersReducedMotion) && (t2.duration = 0);
              const o2 = this.transform, r2 = this.getZoom(), n2 = this.getBearing(), s2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? +t2.zoom : r2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, h2 = "pitch" in t2 ? +t2.pitch : s2, u2 = "padding" in t2 ? t2.padding : o2.padding, _2 = e.pointGeometry.convert(t2.offset);
              let d2, p2, m2;
              if ("globe" === o2.projection.name) {
                const i3 = e.MercatorCoordinate.fromLngLat(o2.center), r3 = _2.rotate(-o2.angle);
                i3.x += r3.x / o2.worldSize, i3.y += r3.y / o2.worldSize;
                const n3 = i3.toLngLat(), s3 = e.LngLat.convert(t2.center || n3);
                this._normalizeCenter(s3), d2 = o2.centerPoint.add(r3), p2 = new e.pointGeometry(i3.x, i3.y).mult(o2.worldSize), m2 = new e.pointGeometry(e.mercatorXfromLng(s3.lng), e.mercatorYfromLat(s3.lat)).mult(o2.worldSize).sub(p2);
              } else {
                d2 = o2.centerPoint.add(_2);
                const i3 = o2.pointLocation(d2), r3 = e.LngLat.convert(t2.center || i3);
                this._normalizeCenter(r3), p2 = o2.project(i3), m2 = o2.project(r3).sub(p2);
              }
              const f2 = o2.zoomScale(l2 - r2);
              let g2, v2;
              t2.around && (g2 = e.LngLat.convert(t2.around), v2 = o2.locationPoint(g2));
              const x2 = this._zooming || l2 !== r2, y2 = this._rotating || n2 !== c2, b2 = this._pitching || h2 !== s2, w2 = !o2.isPaddingEqual(u2), T2 = (o3) => (T3) => {
                if (x2 && (o3.zoom = e.number(r2, l2, T3)), y2 && (o3.bearing = e.number(n2, c2, T3)), b2 && (o3.pitch = e.number(s2, h2, T3)), w2 && (o3.interpolatePadding(a2, u2, T3), d2 = o3.centerPoint.add(_2)), g2)
                  o3.setLocationAtPoint(g2, v2);
                else {
                  const e2 = o3.zoomScale(o3.zoom - r2), t3 = l2 > r2 ? Math.min(2, f2) : Math.max(0.5, f2), i3 = Math.pow(t3, 1 - T3), n3 = o3.unproject(p2.add(m2.mult(T3 * i3)).mult(e2));
                  o3.setLocationAtPoint(o3.renderWorldCopies ? n3.wrap() : n3, d2);
                }
                return t2.preloadOnly || this._fireMoveEvents(i2), o3;
              };
              if (t2.preloadOnly) {
                const e2 = this._emulate(T2, t2.duration, o2);
                return this._preloadTiles(e2), this;
              }
              const E2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
              return this._zooming = x2, this._rotating = y2, this._pitching = b2, this._padding = w2, this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, E2), this._ease(T2(o2), (e2) => {
                o2.recenterOnTerrain(), this._afterEase(i2, e2);
              }, t2), this;
            }
            _prepareEase(t2, i2, o2 = {}) {
              this._moving = true, this.transform.cameraElevationReference = "sea", i2 || o2.moving || this.fire(new e.Event("movestart", t2)), this._zooming && !o2.zooming && this.fire(new e.Event("zoomstart", t2)), this._rotating && !o2.rotating && this.fire(new e.Event("rotatestart", t2)), this._pitching && !o2.pitching && this.fire(new e.Event("pitchstart", t2));
            }
            _fireMoveEvents(t2) {
              this.fire(new e.Event("move", t2)), this._zooming && this.fire(new e.Event("zoom", t2)), this._rotating && this.fire(new e.Event("rotate", t2)), this._pitching && this.fire(new e.Event("pitch", t2));
            }
            _afterEase(t2, i2) {
              if (this._easeId && i2 && this._easeId === i2)
                return;
              this._easeId = void 0, this.transform.cameraElevationReference = "ground";
              const o2 = this._zooming, r2 = this._rotating, n2 = this._pitching;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e.Event("zoomend", t2)), r2 && this.fire(new e.Event("rotateend", t2)), n2 && this.fire(new e.Event("pitchend", t2)), this.fire(new e.Event("moveend", t2));
            }
            flyTo(t2, i2) {
              if (!t2.essential && e.exported.prefersReducedMotion) {
                const o3 = e.pick(t2, ["center", "zoom", "bearing", "pitch", "around"]);
                return this.jumpTo(o3, i2);
              }
              this.stop(), t2 = e.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease }, t2);
              const o2 = this.transform, r2 = this.getZoom(), n2 = this.getBearing(), s2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? e.clamp(+t2.zoom, o2.minZoom, o2.maxZoom) : r2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, h2 = "pitch" in t2 ? +t2.pitch : s2, u2 = "padding" in t2 ? t2.padding : o2.padding, _2 = o2.zoomScale(l2 - r2), d2 = e.pointGeometry.convert(t2.offset);
              let p2 = o2.centerPoint.add(d2);
              const m2 = o2.pointLocation(p2), f2 = e.LngLat.convert(t2.center || m2);
              this._normalizeCenter(f2);
              const g2 = o2.project(m2), v2 = o2.project(f2).sub(g2);
              let x2 = t2.curve;
              const y2 = Math.max(o2.width, o2.height), b2 = y2 / _2, w2 = v2.mag();
              if ("minZoom" in t2) {
                const i3 = e.clamp(Math.min(t2.minZoom, r2, l2), o2.minZoom, o2.maxZoom), n3 = y2 / o2.zoomScale(i3 - r2);
                x2 = Math.sqrt(n3 / w2 * 2);
              }
              const T2 = x2 * x2;
              function E2(e2) {
                const t3 = (b2 * b2 - y2 * y2 + (e2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e2 ? b2 : y2) * T2 * w2);
                return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
              }
              function C2(e2) {
                return (Math.exp(e2) - Math.exp(-e2)) / 2;
              }
              function M2(e2) {
                return (Math.exp(e2) + Math.exp(-e2)) / 2;
              }
              const I2 = E2(0);
              let S2 = function(e2) {
                return M2(I2) / M2(I2 + x2 * e2);
              }, D2 = function(e2) {
                return y2 * ((M2(I2) * (C2(t3 = I2 + x2 * e2) / M2(t3)) - C2(I2)) / T2) / w2;
                var t3;
              }, L2 = (E2(1) - I2) / x2;
              if (Math.abs(w2) < 1e-6 || !isFinite(L2)) {
                if (Math.abs(y2 - b2) < 1e-6)
                  return this.easeTo(t2, i2);
                const e2 = b2 < y2 ? -1 : 1;
                L2 = Math.abs(Math.log(b2 / y2)) / x2, D2 = function() {
                  return 0;
                }, S2 = function(t3) {
                  return Math.exp(e2 * x2 * t3);
                };
              }
              t2.duration = "duration" in t2 ? +t2.duration : 1e3 * L2 / ("screenSpeed" in t2 ? +t2.screenSpeed / x2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0);
              const A2 = n2 !== c2, z2 = h2 !== s2, P2 = !o2.isPaddingEqual(u2), R2 = (o3) => (_3) => {
                const m3 = _3 * L2, x3 = 1 / S2(m3);
                o3.zoom = 1 === _3 ? l2 : r2 + o3.scaleZoom(x3), A2 && (o3.bearing = e.number(n2, c2, _3)), z2 && (o3.pitch = e.number(s2, h2, _3)), P2 && (o3.interpolatePadding(a2, u2, _3), p2 = o3.centerPoint.add(d2));
                const y3 = 1 === _3 ? f2 : o3.unproject(g2.add(v2.mult(D2(m3))).mult(x3));
                return o3.setLocationAtPoint(o3.renderWorldCopies ? y3.wrap() : y3, p2), o3._updateCameraOnTerrain(), t2.preloadOnly || this._fireMoveEvents(i2), o3;
              };
              if (t2.preloadOnly) {
                const e2 = this._emulate(R2, t2.duration, o2);
                return this._preloadTiles(e2), this;
              }
              return this._zooming = true, this._rotating = A2, this._pitching = z2, this._padding = P2, this._prepareEase(i2, false), this._ease(R2(o2), () => this._afterEase(i2), t2), this;
            }
            isEasing() {
              return !!this._easeFrameId;
            }
            stop() {
              return this._stop();
            }
            _stop(e2, t2) {
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                const e3 = this._onEaseEnd;
                this._onEaseEnd = void 0, e3.call(this, t2);
              }
              if (!e2) {
                const e3 = this.handlers;
                e3 && e3.stop(false);
              }
              return this;
            }
            _ease(t2, i2, o2) {
              false === o2.animate || 0 === o2.duration ? (t2(1), i2()) : (this._easeStart = e.exported.now(), this._easeOptions = o2, this._onEaseFrame = t2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
              const t2 = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1), i2 = this._onEaseFrame;
              i2 && i2(this._easeOptions.easing(t2)), t2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(t2, i2) {
              t2 = e.wrap(t2, -180, 180);
              const o2 = Math.abs(t2 - i2);
              return Math.abs(t2 - 360 - i2) < o2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < o2 && (t2 += 360), t2;
            }
            _normalizeCenter(e2) {
              const t2 = this.transform;
              if (!t2.renderWorldCopies || t2.maxBounds)
                return;
              const i2 = e2.lng - t2.center.lng;
              e2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
            }
            _emulate(e2, t2, i2) {
              const o2 = Math.ceil(15 * t2 / 1e3), r2 = [], n2 = e2(i2.clone());
              for (let e3 = 0; e3 <= o2; e3++) {
                const t3 = n2(e3 / o2);
                r2.push(t3.clone());
              }
              return r2;
            }
          }
          class Kr {
            constructor(t2 = {}) {
              this.options = t2, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
            }
            getDefaultPosition() {
              return "bottom-right";
            }
            onAdd(e2) {
              const t2 = this.options && this.options.compact;
              return this._map = e2, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n("button", "mapboxgl-ctrl-attrib-button", this._container), n("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
              this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(e2, t2) {
              const i2 = this._map._getUIString(`AttributionControl.${t2}`);
              e2.setAttribute("aria-label", i2), e2.removeAttribute("title"), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
            }
            _toggleAttribution() {
              this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
              let t2 = this._editLink;
              t2 || (t2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
              const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN }];
              if (t2) {
                const o2 = i2.reduce((e2, t3, o3) => (t3.value && (e2 += `${t3.key}=${t3.value}${o3 < i2.length - 1 ? "&" : ""}`), e2), "?");
                t2.href = `${e.config.FEEDBACK_URL}/${o2}#${er(this._map, true)}`, t2.rel = "noopener nofollow", this._setElementTitle(t2, "MapFeedback");
              }
            }
            _updateData(e2) {
              !e2 || "metadata" !== e2.sourceDataType && "visibility" !== e2.sourceDataType && "style" !== e2.dataType || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
              if (!this._map.style)
                return;
              let e2 = [];
              if (this._map.style.stylesheet) {
                const e3 = this._map.style.stylesheet;
                this.styleOwner = e3.owner, this.styleId = e3.id;
              }
              const t2 = this._map.style._sourceCaches;
              for (const i3 in t2) {
                const o2 = t2[i3];
                if (o2.used) {
                  const t3 = o2.getSource();
                  t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
                }
              }
              e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
                for (let o2 = i3 + 1; o2 < e2.length; o2++)
                  if (e2[o2].indexOf(t3) >= 0)
                    return false;
                return true;
              }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = [...this.options.customAttribution, ...e2] : e2.unshift(this.options.customAttribution));
              const i2 = e2.join(" | ");
              i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
              this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
          }
          class Jr {
            constructor() {
              e.bindAll(["_updateLogo", "_updateCompact"], this);
            }
            onAdd(e2) {
              this._map = e2, this._container = n("div", "mapboxgl-ctrl");
              const t2 = n("a", "mapboxgl-ctrl-logo");
              return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://www.mapbox.com/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
              this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            _updateLogo(e2) {
              e2 && "metadata" !== e2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
              if (!this._map.style)
                return true;
              const e2 = this._map.style._sourceCaches;
              if (0 === Object.entries(e2).length)
                return true;
              for (const t2 in e2) {
                const i2 = e2[t2].getSource();
                if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo)
                  return false;
              }
              return true;
            }
            _updateCompact() {
              const e2 = this._container.children;
              if (e2.length) {
                const t2 = e2[0];
                this._map.getCanvasContainer().offsetWidth < 250 ? t2.classList.add("mapboxgl-compact") : t2.classList.remove("mapboxgl-compact");
              }
            }
          }
          class Qr {
            constructor() {
              this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
            }
            add(e2) {
              const t2 = ++this._id;
              return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
            }
            remove(e2) {
              const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
              for (const t3 of i2)
                if (t3.id === e2)
                  return void (t3.cancelled = true);
            }
            run(e2 = 0) {
              const t2 = this._currentlyRunning = this._queue;
              this._queue = [];
              for (const i2 of t2)
                if (!i2.cancelled && (i2.callback(e2), this._cleared))
                  break;
              this._cleared = false, this._currentlyRunning = false;
            }
            clear() {
              this._currentlyRunning && (this._cleared = true), this._queue = [];
            }
          }
          function en(t2, i2, o2) {
            if (t2 = new e.LngLat(t2.lng, t2.lat), i2) {
              const r2 = new e.LngLat(t2.lng - 360, t2.lat), n2 = new e.LngLat(t2.lng + 360, t2.lat), s2 = 360 * Math.ceil(Math.abs(t2.lng - o2.center.lng) / 360), a2 = o2.locationPoint(t2).distSqr(i2), l2 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
              o2.locationPoint(r2).distSqr(i2) < a2 && (l2 || Math.abs(r2.lng - o2.center.lng) < s2) ? t2 = r2 : o2.locationPoint(n2).distSqr(i2) < a2 && (l2 || Math.abs(n2.lng - o2.center.lng) < s2) && (t2 = n2);
            }
            for (; Math.abs(t2.lng - o2.center.lng) > 180; ) {
              const e2 = o2.locationPoint(t2);
              if (e2.x >= 0 && e2.y >= 0 && e2.x <= o2.width && e2.y <= o2.height)
                break;
              t2.lng > o2.center.lng ? t2.lng -= 360 : t2.lng += 360;
            }
            return t2;
          }
          const tn = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
          class on extends e.Evented {
            constructor(t2, i2) {
              if (super(), (t2 instanceof e.window.HTMLElement || i2) && (t2 = e.extend({ element: t2 }, i2)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && t2.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t2 && t2.occludedOpacity || 0.2, t2 && t2.element)
                this._element = t2.element, this._offset = e.pointGeometry.convert(t2 && t2.offset || [0, 0]);
              else {
                this._defaultMarker = true, this._element = n("div");
                const i3 = 41, o3 = 27, r2 = s("svg", { display: "block", height: i3 * this._scale + "px", width: o3 * this._scale + "px", viewBox: `0 0 ${o3} ${i3}` }, this._element), a2 = s("radialGradient", { id: "shadowGradient" }, s("defs", {}, r2));
                s("stop", { offset: "10%", "stop-opacity": 0.4 }, a2), s("stop", { offset: "100%", "stop-opacity": 0.05 }, a2), s("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r2), s("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r2), s("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r2), s("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r2), this._offset = e.pointGeometry.convert(t2 && t2.offset || [0, -14]);
              }
              this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e2) => {
                e2.preventDefault();
              }), this._element.addEventListener("mousedown", (e2) => {
                e2.preventDefault();
              });
              const o2 = this._element.classList;
              for (const e2 in tn)
                o2.remove(`mapboxgl-marker-anchor-${e2}`);
              o2.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
            }
            addTo(e2) {
              return e2 === this._map || (this.remove(), this._map = e2, e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._updateMoving), e2.on("moveend", this._update), e2.on("remove", this._clearFadeTimer), e2._addMarker(this), this.setDraggable(this._draggable), this._update(), e2.on("click", this._onMapClick)), this;
            }
            remove() {
              const e2 = this._map;
              return e2 && (e2.off("click", this._onMapClick), e2.off("move", this._updateMoving), e2.off("moveend", this._update), e2.off("mousedown", this._addDragHandler), e2.off("touchstart", this._addDragHandler), e2.off("mouseup", this._onUp), e2.off("touchend", this._onUp), e2.off("mousemove", this._onMove), e2.off("touchmove", this._onMove), e2.off("remove", this._clearFadeTimer), e2._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(t2) {
              return this._lngLat = e.LngLat.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
            }
            getElement() {
              return this._element;
            }
            setPopup(e2) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
                if (!("offset" in e2.options)) {
                  const t2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
                  e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [o2, -1 * (t2 - i2 + o2)], "bottom-right": [-o2, -1 * (t2 - i2 + o2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
                }
                this._popup = e2, e2._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
              }
              return this;
            }
            _onKeyPress(e2) {
              const t2 = e2.code, i2 = e2.charCode || e2.keyCode;
              "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
            }
            _onMapClick(e2) {
              const t2 = e2.originalEvent.target, i2 = this._element;
              this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
            }
            getPopup() {
              return this._popup;
            }
            togglePopup() {
              const e2 = this._popup;
              return e2 ? (e2.isOpen() ? (e2.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e2.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }
            _behindTerrain() {
              const e2 = this._map, t2 = this._pos;
              if (!e2 || !t2)
                return false;
              const i2 = e2.unproject(t2), o2 = e2.getFreeCameraOptions();
              if (!o2.position)
                return false;
              const r2 = o2.position.toLngLat();
              return r2.distanceTo(i2) < 0.9 * r2.distanceTo(this._lngLat);
            }
            _evaluateOpacity() {
              const t2 = this._map;
              if (!t2)
                return;
              const i2 = this._pos;
              if (!i2 || i2.x < 0 || i2.x > t2.transform.width || i2.y < 0 || i2.y > t2.transform.height)
                return void this._clearFadeTimer();
              const o2 = t2.unproject(i2);
              let r2;
              t2._showingGlobe() && e.isLngLatBehindGlobe(t2.transform, this._lngLat) ? r2 = 0 : (r2 = 1 - t2._queryFogOpacity(o2), t2.transform._terrainEnabled() && t2.getTerrain() && this._behindTerrain() && (r2 *= this._occludedOpacity)), this._element.style.opacity = `${r2}`, this._element.style.pointerEvents = r2 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r2), this._fadeTimer = null;
            }
            _clearFadeTimer() {
              this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _updateDOM() {
              const e2 = this._pos;
              if (!e2 || !this._map)
                return;
              const t2 = this._offset.mult(this._scale);
              this._element.style.transform = `
            translate(${e2.x}px,${e2.y}px)
            ${tn[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t2.x}px,${t2.y}px)
        `;
            }
            _calculateXYTransform() {
              const t2 = this._pos, i2 = this._map, o2 = this.getPitchAlignment();
              if (!i2 || !t2 || "map" !== o2)
                return "";
              if (!i2._showingGlobe()) {
                const e2 = i2.getPitch();
                return e2 ? `rotateX(${e2}deg)` : "";
              }
              const r2 = e.radToDeg(e.globeTiltAtLngLat(i2.transform, this._lngLat)), n2 = t2.sub(e.globeCenterToScreenPoint(i2.transform)), s2 = Math.abs(n2.x) + Math.abs(n2.y);
              if (0 === s2)
                return "";
              const a2 = r2 / s2;
              return `rotateX(${-n2.y * a2}deg) rotateY(${n2.x * a2}deg)`;
            }
            _calculateZTransform() {
              const t2 = this._pos, i2 = this._map;
              if (!i2 || !t2)
                return "";
              let o2 = 0;
              const r2 = this.getRotationAlignment();
              if ("map" === r2)
                if (i2._showingGlobe()) {
                  const t3 = i2.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat + 1e-3)), r3 = i2.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t3);
                  o2 = e.radToDeg(Math.atan2(r3.y, r3.x)) - 90;
                } else
                  o2 = -i2.getBearing();
              else if ("horizon" === r2) {
                const r3 = e.smoothstep(4, 6, i2.getZoom()), n2 = e.globeCenterToScreenPoint(i2.transform);
                n2.y += r3 * i2.transform.height;
                const s2 = t2.sub(n2), a2 = e.radToDeg(Math.atan2(s2.y, s2.x));
                o2 = (a2 > 90 ? a2 - 270 : a2 + 90) * (1 - r3);
              }
              return o2 += this._rotation, o2 ? `rotateZ(${o2}deg)` : "";
            }
            _update(t2) {
              e.window.cancelAnimationFrame(this._updateFrameId);
              const i2 = this._map;
              i2 && (i2.transform.renderWorldCopies && (this._lngLat = en(this._lngLat, this._pos, i2.transform)), this._pos = i2.project(this._lngLat), true === t2 ? this._updateFrameId = e.window.requestAnimationFrame(() => {
                this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
              }) : this._pos = this._pos.round(), i2._requestDomTask(() => {
                this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i2._showingGlobe() || i2.getTerrain() || i2.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
              }));
            }
            getOffset() {
              return this._offset;
            }
            setOffset(t2) {
              return this._offset = e.pointGeometry.convert(t2), this._update(), this;
            }
            _onMove(t2) {
              const i2 = this._map;
              if (!i2)
                return;
              const o2 = this._pointerdownPos, r2 = this._positionDelta;
              if (o2 && r2) {
                if (!this._isDragging) {
                  const e2 = this._clickTolerance || i2._clickTolerance;
                  if (t2.point.dist(o2) < e2)
                    return;
                  this._isDragging = true;
                }
                this._pos = t2.point.sub(r2), this._lngLat = i2.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag"));
              }
            }
            _onUp() {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
              const t2 = this._map;
              t2 && (t2.off("mousemove", this._onMove), t2.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.Event("dragend")), this._state = "inactive";
            }
            _addDragHandler(e2) {
              const t2 = this._map, i2 = this._pos;
              t2 && i2 && this._element.contains(e2.originalEvent.target) && (e2.preventDefault(), this._positionDelta = e2.point.sub(i2), this._pointerdownPos = e2.point, this._state = "pending", t2.on("mousemove", this._onMove), t2.on("touchmove", this._onMove), t2.once("mouseup", this._onUp), t2.once("touchend", this._onUp));
            }
            setDraggable(e2) {
              this._draggable = !!e2;
              const t2 = this._map;
              return t2 && (e2 ? (t2.on("mousedown", this._addDragHandler), t2.on("touchstart", this._addDragHandler)) : (t2.off("mousedown", this._addDragHandler), t2.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
              return this._draggable;
            }
            setRotation(e2) {
              return this._rotation = e2 || 0, this._update(), this;
            }
            getRotation() {
              return this._rotation;
            }
            setRotationAlignment(e2) {
              return this._rotationAlignment = e2 || "auto", this._update(), this;
            }
            getRotationAlignment() {
              return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }
            setPitchAlignment(e2) {
              return this._pitchAlignment = e2 || "auto", this._update(), this;
            }
            getPitchAlignment() {
              return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }
            setOccludedOpacity(e2) {
              return this._occludedOpacity = e2 || 0.2, this._update(), this;
            }
            getOccludedOpacity() {
              return this._occludedOpacity;
            }
          }
          const rn = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, nn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
          function sn(t2 = new e.pointGeometry(0, 0), i2 = "bottom") {
            if ("number" == typeof t2) {
              const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t2, 2)));
              switch (i2) {
                case "top":
                  return new e.pointGeometry(0, t2);
                case "top-left":
                  return new e.pointGeometry(o2, o2);
                case "top-right":
                  return new e.pointGeometry(-o2, o2);
                case "bottom":
                  return new e.pointGeometry(0, -t2);
                case "bottom-left":
                  return new e.pointGeometry(o2, -o2);
                case "bottom-right":
                  return new e.pointGeometry(-o2, -o2);
                case "left":
                  return new e.pointGeometry(t2, 0);
                case "right":
                  return new e.pointGeometry(-t2, 0);
              }
              return new e.pointGeometry(0, 0);
            }
            return t2 instanceof e.pointGeometry || Array.isArray(t2) ? e.pointGeometry.convert(t2) : e.pointGeometry.convert(t2[i2] || [0, 0]);
          }
          class an {
            constructor(e2) {
              this.jumpTo(e2);
            }
            getValue(t2) {
              if (t2 <= this._startTime)
                return this._start;
              if (t2 >= this._endTime)
                return this._end;
              const i2 = e.easeCubicInOut((t2 - this._startTime) / (this._endTime - this._startTime));
              return this._start * (1 - i2) + this._end * i2;
            }
            isEasing(e2) {
              return e2 >= this._startTime && e2 <= this._endTime;
            }
            jumpTo(e2) {
              this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e2, this._end = e2;
            }
            easeTo(e2, t2, i2) {
              this._start = this.getValue(t2), this._end = e2, this._startTime = t2, this._endTime = t2 + i2;
            }
          }
          const ln = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, cn = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, optimizeForTerrain: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true }, hn = { showCompass: true, showZoom: true, visualizePitch: false };
          class un {
            constructor(t2, i2, o2 = false) {
              this._clickTolerance = 10, this.element = i2, this.mouseRotate = new wr({ clickTolerance: t2.dragRotate._mouseRotate._clickTolerance }), this.map = t2, o2 && (this.mousePitch = new Tr({ clickTolerance: t2.dragRotate._mousePitch._clickTolerance })), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener("mousedown", this.mousedown), i2.addEventListener("touchstart", this.touchstart, { passive: false }), i2.addEventListener("touchmove", this.touchmove), i2.addEventListener("touchend", this.touchend), i2.addEventListener("touchcancel", this.reset);
            }
            down(e2, t2) {
              this.mouseRotate.mousedown(e2, t2), this.mousePitch && this.mousePitch.mousedown(e2, t2), h();
            }
            move(e2, t2) {
              const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e2, t2), r2 = o2 && o2.bearingDelta;
              if (r2 && i2.setBearing(i2.getBearing() + r2), this.mousePitch) {
                const o3 = this.mousePitch.mousemoveWindow(e2, t2), r3 = o3 && o3.pitchDelta;
                r3 && i2.setPitch(i2.getPitch() + r3);
              }
            }
            off() {
              const e2 = this.element;
              e2.removeEventListener("mousedown", this.mousedown), e2.removeEventListener("touchstart", this.touchstart, { passive: false }), e2.removeEventListener("touchmove", this.touchmove), e2.removeEventListener("touchend", this.touchend), e2.removeEventListener("touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
              u(), e.window.removeEventListener("mousemove", this.mousemove), e.window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(t2) {
              this.down(e.extend({}, t2, { ctrlKey: true, preventDefault: () => t2.preventDefault() }), p(this.element, t2)), e.window.addEventListener("mousemove", this.mousemove), e.window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(e2) {
              this.move(e2, p(this.element, e2));
            }
            mouseup(e2) {
              this.mouseRotate.mouseupWindow(e2), this.mousePitch && this.mousePitch.mouseupWindow(e2), this.offTemp();
            }
            touchstart(e2) {
              1 !== e2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e2.preventDefault() }, this._startPos));
            }
            touchmove(e2) {
              1 !== e2.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e2.targetTouches)[0], this.move({ preventDefault: () => e2.preventDefault() }, this._lastPos));
            }
            touchend(e2) {
              0 === e2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
          }
          const _n = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, dn = { maxWidth: 100, unit: "metric" };
          function pn(e2, t2, i2) {
            const o2 = mn(t2), r2 = o2 / t2, n2 = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }[i2];
            this._map._requestDomTask(() => {
              this._container.style.width = e2 * r2 + "px", this._container.innerHTML = `${o2}&nbsp;${n2}`;
            });
          }
          function mn(e2) {
            const t2 = Math.pow(10, `${Math.floor(e2)}`.length - 1);
            let i2 = e2 / t2;
            return i2 = i2 >= 10 ? 10 : i2 >= 5 ? 5 : i2 >= 3 ? 3 : i2 >= 2 ? 2 : i2 >= 1 ? 1 : function(e3) {
              const t3 = Math.pow(10, Math.ceil(-Math.log(e3) / Math.LN10));
              return Math.round(e3 * t3) / t3;
            }(i2), t2 * i2;
          }
          const fn2 = { version: e.version, supported: i, setRTLTextPlugin: e.setRTLTextPlugin, getRTLTextPluginStatus: e.getRTLTextPluginStatus, Map: class extends Yr {
            constructor(t2) {
              if (e.LivePerformanceUtils.mark(e.PerformanceMarkers.create), null != (t2 = e.extend({}, cn, t2)).minZoom && null != t2.maxZoom && t2.minZoom > t2.maxZoom)
                throw new Error("maxZoom must be greater than or equal to minZoom");
              if (null != t2.minPitch && null != t2.maxPitch && t2.minPitch > t2.maxPitch)
                throw new Error("maxPitch must be greater than or equal to minPitch");
              if (null != t2.minPitch && t2.minPitch < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (null != t2.maxPitch && t2.maxPitch > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (t2.antialias && e.isSafariWithAntialiasingBug(e.window) && (t2.antialias = false, e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ko(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies), t2), this._interactive = t2.interactive, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._useWebGL2 = t2.useWebGL2, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t2.crossSourceCollisions, this._collectResourceTiming = t2.collectResourceTiming, this._optimizeForTerrain = t2.optimizeForTerrain, this._language = this._parseLanguage(t2.language), this._worldview = t2.worldview, this._renderTaskQueue = new Qr(), this._domRenderTaskQueue = new Qr(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, ln, t2.locale), this._clickTolerance = t2.clickTolerance, this._cooperativeGestures = t2.cooperativeGestures, this._performanceMetricsCollection = t2.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new an(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._requestManager = new e.RequestManager(t2.transformRequest, t2.accessToken, t2.testMode), this._silenceAuthErrors = !!t2.testMode, "string" == typeof t2.container) {
                if (this._container = e.window.document.getElementById(t2.container), !this._container)
                  throw new Error(`Container '${t2.container}' not found.`);
              } else {
                if (!(t2.container instanceof e.window.HTMLElement))
                  throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = t2.container;
              }
              if (this._container.childNodes.length > 0 && e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t2.maxBounds && this.setMaxBounds(t2.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
                throw new Error("Failed to initialize WebGL.");
              this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), void 0 !== e.window && (e.window.addEventListener("online", this._onWindowOnline, false), e.window.addEventListener("resize", this._onWindowResize, false), e.window.addEventListener("orientationchange", this._onWindowResize, false), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, false), e.window.addEventListener("visibilitychange", this._onVisibilityChange, false)), this.handlers = new $r(this, t2), this._localFontFamily = t2.localFontFamily, this._localIdeographFontFamily = t2.localIdeographFontFamily, t2.style && this.setStyle(t2.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t2.projection && this.setProjection(t2.projection), this._hash = t2.hash && new Qo("string" == typeof t2.hash && t2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch }), t2.bounds && (this.resize(), this.fitBounds(t2.bounds, e.extend({}, t2.fitBoundsOptions, { duration: 0 })))), this.resize(), t2.attributionControl && this.addControl(new Kr({ customAttribution: t2.customAttribution })), this._logoControl = new Jr(), this.addControl(this._logoControl, t2.logoPosition), this.on("style.load", () => {
                this.transform.unmodified && this.jumpTo(this.style.stylesheet);
              }), this.on("data", (t3) => {
                this._update("style" === t3.dataType), this.fire(new e.Event(`${t3.dataType}data`, t3));
              }), this.on("dataloading", (t3) => {
                this.fire(new e.Event(`${t3.dataType}dataloading`, t3));
              });
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(t2, i2) {
              if (void 0 === i2 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd)
                return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              const o2 = t2.onAdd(this);
              this._controls.push(t2);
              const r2 = this._controlPositions[i2];
              return -1 !== i2.indexOf("bottom") ? r2.insertBefore(o2, r2.firstChild) : r2.appendChild(o2), this;
            }
            removeControl(t2) {
              if (!t2 || !t2.onRemove)
                return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              const i2 = this._controls.indexOf(t2);
              return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
            }
            hasControl(e2) {
              return this._controls.indexOf(e2) > -1;
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            resize(t2) {
              if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
                return this;
              this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
              const i2 = !this._moving;
              return i2 && this.fire(new e.Event("movestart", t2)).fire(new e.Event("move", t2)), this.fire(new e.Event("resize", t2)), i2 && this.fire(new e.Event("moveend", t2)), this;
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds() || null;
            }
            setMaxBounds(t2) {
              return this.transform.setMaxBounds(e.LngLatBounds.convert(t2)), this._update();
            }
            setMinZoom(t2) {
              if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
                return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 ? this.setZoom(t2) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(t2) {
              if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom)
                return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 ? this.setZoom(t2) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(t2) {
              if ((t2 = null == t2 ? 0 : t2) < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (t2 >= 0 && t2 <= this.transform.maxPitch)
                return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 ? this.setPitch(t2) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(t2) {
              if ((t2 = null == t2 ? 85 : t2) > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (t2 >= this.transform.minPitch)
                return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 ? this.setPitch(t2) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
              throw new Error("maxPitch must be greater than or equal to minPitch");
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(e2) {
              return this.transform.renderWorldCopies = e2, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
            }
            getLanguage() {
              return this._language;
            }
            _parseLanguage(t2) {
              return "auto" === t2 ? e.window.navigator.language : Array.isArray(t2) ? 0 === t2.length ? void 0 : t2.map((t3) => "auto" === t3 ? e.window.navigator.language : t3) : t2;
            }
            setLanguage(e2) {
              const t2 = this._parseLanguage(e2);
              if (!this.style || t2 === this._language)
                return this;
              this._language = t2, this.style._reloadSources();
              for (const e3 of this._controls)
                e3._setLanguage && e3._setLanguage(this._language);
              return this;
            }
            getWorldview() {
              return this._worldview;
            }
            setWorldview(e2) {
              return this.style && e2 !== this._worldview ? (this._worldview = e2, this.style._reloadSources(), this) : this;
            }
            getProjection() {
              return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
            }
            _showingGlobe() {
              return "globe" === this.transform.projection.name;
            }
            setProjection(e2) {
              return this._lazyInitEmptyStyle(), e2 ? "string" == typeof e2 && (e2 = { name: e2 }) : e2 = null, this._useExplicitProjection = !!e2, this._prioritizeAndUpdateProjection(e2, this.style.stylesheet ? this.style.stylesheet.projection : null);
            }
            _updateProjectionTransition() {
              if ("globe" !== this.getProjection().name)
                return;
              const t2 = this.transform, i2 = t2.projection.name;
              let o2;
              "globe" === i2 && t2.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? (t2.setMercatorFromTransition(), o2 = true) : "mercator" === i2 && t2.zoom < e.GLOBE_ZOOM_THRESHOLD_MAX && (t2.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
            }
            _prioritizeAndUpdateProjection(e2, t2) {
              return this._updateProjection(e2 || t2 || { name: "mercator" });
            }
            _updateProjection(t2) {
              let i2;
              if (i2 = "globe" === t2.name && this.transform.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t2), this.style.applyProjectionUpdate(), i2) {
                this.painter.clearBackgroundTiles();
                for (const e2 in this.style._sourceCaches)
                  this.style._sourceCaches[e2].clearTiles();
                this._update(true), this._forceMarkerAndPopupUpdate(true);
              }
              return this;
            }
            project(t2) {
              return this.transform.locationPoint3D(e.LngLat.convert(t2));
            }
            unproject(t2) {
              return this.transform.pointLocation3D(e.pointGeometry.convert(t2));
            }
            isMoving() {
              return this._moving || this.handlers && this.handlers.isMoving() || false;
            }
            isZooming() {
              return this._zooming || this.handlers && this.handlers.isZooming() || false;
            }
            isRotating() {
              return this._rotating || this.handlers && this.handlers.isRotating() || false;
            }
            _isDragging() {
              return this.handlers && this.handlers._isDragging() || false;
            }
            _createDelegatedListener(e2, t2, i2) {
              if ("mouseenter" === e2 || "mouseover" === e2) {
                let o2 = false;
                const r2 = (r3) => {
                  const n3 = t2.filter((e3) => this.getLayer(e3)), s2 = n3.length ? this.queryRenderedFeatures(r3.point, { layers: n3 }) : [];
                  s2.length ? o2 || (o2 = true, i2.call(this, new cr(e2, this, r3.originalEvent, { features: s2 }))) : o2 = false;
                }, n2 = () => {
                  o2 = false;
                };
                return { layers: new Set(t2), listener: i2, delegates: { mousemove: r2, mouseout: n2 } };
              }
              if ("mouseleave" === e2 || "mouseout" === e2) {
                let o2 = false;
                const r2 = (r3) => {
                  const n3 = t2.filter((e3) => this.getLayer(e3));
                  (n3.length ? this.queryRenderedFeatures(r3.point, { layers: n3 }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new cr(e2, this, r3.originalEvent)));
                }, n2 = (t3) => {
                  o2 && (o2 = false, i2.call(this, new cr(e2, this, t3.originalEvent)));
                };
                return { layers: new Set(t2), listener: i2, delegates: { mousemove: r2, mouseout: n2 } };
              }
              {
                const o2 = (e3) => {
                  const o3 = t2.filter((e4) => this.getLayer(e4)), r2 = o3.length ? this.queryRenderedFeatures(e3.point, { layers: o3 }) : [];
                  r2.length && (e3.features = r2, i2.call(this, e3), delete e3.features);
                };
                return { layers: new Set(t2), listener: i2, delegates: { [e2]: o2 } };
              }
            }
            on(e2, t2, i2) {
              if (void 0 === i2)
                return super.on(e2, t2);
              Array.isArray(t2) || (t2 = [t2]);
              const o2 = this._createDelegatedListener(e2, t2, i2);
              this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(o2);
              for (const e3 in o2.delegates)
                this.on(e3, o2.delegates[e3]);
              return this;
            }
            once(e2, t2, i2) {
              if (void 0 === i2)
                return super.once(e2, t2);
              Array.isArray(t2) || (t2 = [t2]);
              const o2 = this._createDelegatedListener(e2, t2, i2);
              for (const e3 in o2.delegates)
                this.once(e3, o2.delegates[e3]);
              return this;
            }
            off(e2, t2, i2) {
              if (void 0 === i2)
                return super.off(e2, t2);
              t2 = new Set(Array.isArray(t2) ? t2 : [t2]);
              const o2 = (e3, t3) => {
                if (e3.size !== t3.size)
                  return false;
                for (const i3 of e3)
                  if (!t3.has(i3))
                    return false;
                return true;
              }, r2 = this._delegatedListeners ? this._delegatedListeners[e2] : void 0;
              return r2 && ((e3) => {
                for (let r3 = 0; r3 < e3.length; r3++) {
                  const n2 = e3[r3];
                  if (n2.listener === i2 && o2(n2.layers, t2)) {
                    for (const e4 in n2.delegates)
                      this.off(e4, n2.delegates[e4]);
                    return e3.splice(r3, 1), this;
                  }
                }
              })(r2), this;
            }
            queryRenderedFeatures(t2, i2) {
              return this.style ? (void 0 !== i2 || void 0 === t2 || t2 instanceof e.pointGeometry || Array.isArray(t2) || (i2 = t2, t2 = void 0), this.style.queryRenderedFeatures(t2 = t2 || [[0, 0], [this.transform.width, this.transform.height]], i2 = i2 || {}, this.transform)) : [];
            }
            querySourceFeatures(e2, t2) {
              return this.style.querySourceFeatures(e2, t2);
            }
            setStyle(t2, i2) {
              return false !== (i2 = e.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && i2.localFontFamily === this._localFontFamily && this.style && t2 ? (this._diffStyle(t2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t2, i2));
            }
            _getUIString(e2) {
              const t2 = this._locale[e2];
              if (null == t2)
                throw new Error(`Missing UI string '${e2}'`);
              return t2;
            }
            _updateStyle(e2, t2) {
              return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e2 && (this.style = new Qt(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e2 ? this.style.loadURL(e2) : this.style.loadJSON(e2)), this._updateTerrain(), this;
            }
            _lazyInitEmptyStyle() {
              this.style || (this.style = new Qt(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            _diffStyle(t2, i2) {
              if ("string" == typeof t2) {
                const o2 = this._requestManager.normalizeStyleURL(t2), r2 = this._requestManager.transformRequest(o2, e.ResourceType.Style);
                e.getJSON(r2, (t3, o3) => {
                  t3 ? this.fire(new e.ErrorEvent(t3)) : o3 && this._updateDiff(o3, i2);
                });
              } else
                "object" == typeof t2 && this._updateDiff(t2, i2);
            }
            _updateDiff(t2, i2) {
              try {
                this.style.setState(t2) && this._update(true);
              } catch (o2) {
                e.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
              }
            }
            getStyle() {
              if (this.style)
                return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : (e.warnOnce("There is no style added to the map."), false);
            }
            addSource(e2, t2) {
              return this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true);
            }
            isSourceLoaded(e2) {
              return !!this.style && this.style._isSourceCacheLoaded(e2);
            }
            areTilesLoaded() {
              const e2 = this.style && this.style._sourceCaches;
              for (const t2 in e2) {
                const i2 = e2[t2]._tiles;
                for (const e3 in i2) {
                  const t3 = i2[e3];
                  if ("loaded" !== t3.state && "errored" !== t3.state)
                    return false;
                }
              }
              return true;
            }
            addSourceType(e2, t2, i2) {
              this._lazyInitEmptyStyle(), this.style.addSourceType(e2, t2, i2);
            }
            removeSource(e2) {
              return this.style.removeSource(e2), this._updateTerrain(), this._update(true);
            }
            getSource(e2) {
              return this.style.getSource(e2);
            }
            addImage(t2, i2, { pixelRatio: o2 = 1, sdf: r2 = false, stretchX: n2, stretchY: s2, content: a2 } = {}) {
              if (this._lazyInitEmptyStyle(), i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap) {
                const { width: l2, height: c2, data: h2 } = e.exported.getImageData(i2);
                this.style.addImage(t2, { data: new e.RGBAImage({ width: l2, height: c2 }, h2), pixelRatio: o2, stretchX: n2, stretchY: s2, content: a2, sdf: r2, version: 0 });
              } else if (void 0 === i2.width || void 0 === i2.height)
                this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              else {
                const { width: l2, height: c2 } = i2, h2 = i2;
                this.style.addImage(t2, { data: new e.RGBAImage({ width: l2, height: c2 }, new Uint8Array(h2.data)), pixelRatio: o2, stretchX: n2, stretchY: s2, content: a2, sdf: r2, version: 0, userImage: h2 }), h2.onAdd && h2.onAdd(this, t2);
              }
            }
            updateImage(t2, i2) {
              const o2 = this.style.getImage(t2);
              if (!o2)
                return void this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              const r2 = i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap ? e.exported.getImageData(i2) : i2, { width: n2, height: s2 } = r2;
              void 0 !== n2 && void 0 !== s2 ? n2 === o2.data.width && s2 === o2.data.height ? (o2.data.replace(r2.data, !(i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap)), this.style.updateImage(t2, o2)) : this.fire(new e.ErrorEvent(new Error(`The width and height of the updated image (${n2}, ${s2})
                must be that same as the previous version of the image
                (${o2.data.width}, ${o2.data.height})`))) : this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            }
            hasImage(t2) {
              return t2 ? !!this.style.getImage(t2) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), false);
            }
            removeImage(e2) {
              this.style.removeImage(e2);
            }
            loadImage(t2, i2) {
              e.getImage(this._requestManager.transformRequest(t2, e.ResourceType.Image), (t3, o2) => {
                i2(t3, o2 instanceof e.window.HTMLImageElement ? e.exported.getImageData(o2) : o2);
              });
            }
            listImages() {
              return this.style.listImages();
            }
            addLayer(e2, t2) {
              return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true);
            }
            moveLayer(e2, t2) {
              return this.style.moveLayer(e2, t2), this._update(true);
            }
            removeLayer(e2) {
              return this.style.removeLayer(e2), this._update(true);
            }
            getLayer(e2) {
              return this.style.getLayer(e2);
            }
            setLayerZoomRange(e2, t2, i2) {
              return this.style.setLayerZoomRange(e2, t2, i2), this._update(true);
            }
            setFilter(e2, t2, i2 = {}) {
              return this.style.setFilter(e2, t2, i2), this._update(true);
            }
            getFilter(e2) {
              return this.style.getFilter(e2);
            }
            setPaintProperty(e2, t2, i2, o2 = {}) {
              return this.style.setPaintProperty(e2, t2, i2, o2), this._update(true);
            }
            getPaintProperty(e2, t2) {
              return this.style.getPaintProperty(e2, t2);
            }
            setLayoutProperty(e2, t2, i2, o2 = {}) {
              return this.style.setLayoutProperty(e2, t2, i2, o2), this._update(true);
            }
            getLayoutProperty(e2, t2) {
              return this.style.getLayoutProperty(e2, t2);
            }
            setLight(e2, t2 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setLight(e2, t2), this._update(true);
            }
            getLight() {
              return this.style.getLight();
            }
            setTerrain(e2) {
              return this._lazyInitEmptyStyle(), !e2 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
            }
            getTerrain() {
              return this.style ? this.style.getTerrain() : null;
            }
            setFog(e2) {
              return this._lazyInitEmptyStyle(), this.style.setFog(e2), this._update(true);
            }
            getFog() {
              return this.style ? this.style.getFog() : null;
            }
            _queryFogOpacity(t2) {
              return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t2), this.transform) : 0;
            }
            setFeatureState(e2, t2) {
              return this.style.setFeatureState(e2, t2), this._update();
            }
            removeFeatureState(e2, t2) {
              return this.style.removeFeatureState(e2, t2), this._update();
            }
            getFeatureState(e2) {
              return this.style.getFeatureState(e2);
            }
            _updateContainerDimensions() {
              if (!this._container)
                return;
              const t2 = this._container.getBoundingClientRect().width || 400, i2 = this._container.getBoundingClientRect().height || 300;
              let o2, r2, n2, s2 = this._container;
              for (; s2 && (!r2 || !n2); ) {
                const t3 = e.window.getComputedStyle(s2).transform;
                t3 && "none" !== t3 && (o2 = t3.match(/matrix.*\((.+)\)/)[1].split(", "), o2[0] && "0" !== o2[0] && "1" !== o2[0] && (r2 = o2[0]), o2[3] && "0" !== o2[3] && "1" !== o2[3] && (n2 = o2[3])), s2 = s2.parentElement;
              }
              this._containerWidth = r2 ? Math.abs(t2 / r2) : t2, this._containerHeight = n2 ? Math.abs(i2 / n2) : i2;
            }
            _detectMissingCSS() {
              "rgb(250, 128, 114)" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
            }
            _setupContainer() {
              const e2 = this._container;
              e2.classList.add("mapboxgl-map"), (this._missingCSSCanary = n("div", "mapboxgl-canary", e2)).style.visibility = "hidden", this._detectMissingCSS();
              const t2 = this._canvasContainer = n("div", "mapboxgl-canvas-container", e2);
              this._interactive && t2.classList.add("mapboxgl-interactive"), this._canvas = n("canvas", "mapboxgl-canvas", t2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
              const i2 = this._controlContainer = n("div", "mapboxgl-control-container", e2), o2 = this._controlPositions = {};
              ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
                o2[e3] = n("div", `mapboxgl-ctrl-${e3}`, i2);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }
            _resizeCanvas(t2, i2) {
              const o2 = e.exported.devicePixelRatio || 1;
              this._canvas.width = o2 * Math.ceil(t2), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${i2}px`;
            }
            _addMarker(e2) {
              this._markers.push(e2);
            }
            _removeMarker(e2) {
              const t2 = this._markers.indexOf(e2);
              -1 !== t2 && this._markers.splice(t2, 1);
            }
            _addPopup(e2) {
              this._popups.push(e2);
            }
            _removePopup(e2) {
              const t2 = this._popups.indexOf(e2);
              -1 !== t2 && this._popups.splice(t2, 1);
            }
            _setupPainter() {
              const t2 = e.extend({}, i.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._useWebGL2 && this._canvas.getContext("webgl2", t2), r2 = o2 || this._canvas.getContext("webgl", t2) || this._canvas.getContext("experimental-webgl", t2);
              r2 ? (this._useWebGL2 && !o2 && e.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), e.storeAuthState(r2, true), this.painter = new Fo(r2, this.transform, !!o2), this.on("data", (e2) => {
                "source" === e2.dataType && this.painter.setTileLoadedFlag(true);
              }), e.exported$1.testSupport(r2)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")));
            }
            _contextLost(t2) {
              t2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", { originalEvent: t2 }));
            }
            _contextRestored(t2) {
              this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", { originalEvent: t2 }));
            }
            _onMapScroll(e2) {
              if (e2.target === this._container)
                return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            _update(e2) {
              return this.style ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(e2) {
              return this._update(), this._renderTaskQueue.add(e2);
            }
            _cancelRenderFrame(e2) {
              this._renderTaskQueue.remove(e2);
            }
            _requestDomTask(e2) {
              !this.loaded() || this.loaded() && !this.isMoving() ? e2() : this._domRenderTaskQueue.add(e2);
            }
            _render(t2) {
              let i2;
              const o2 = this.painter.context.extTimerQuery, r2 = e.exported.now();
              if (this.listens("gpu-timing-frame") && (i2 = o2.createQueryEXT(), o2.beginQueryEXT(o2.TIME_ELAPSED_EXT, i2)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e.window.performance.now())), this._renderTaskQueue.run(t2), this._domRenderTaskQueue.run(t2), this._removed)
                return;
              this._updateProjectionTransition();
              const n2 = this._isInitialLoad ? 0 : this._fadeDuration;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                const t3 = this.transform.zoom, i3 = this.transform.pitch, o3 = e.exported.now(), r3 = new e.EvaluationParameters(t3, { now: o3, fadeDuration: n2, pitch: i3, transition: this.style.getTransition() });
                this.style.update(r3);
              }
              this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
              let s2 = false;
              if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), s2 = this._updateAverageElevation(r2), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s2 = this._updateAverageElevation(r2), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n2, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i2) {
                const t3 = e.exported.now() - r2;
                o2.endQueryEXT(o2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
                  const n3 = o2.getQueryObjectEXT(i2, o2.QUERY_RESULT_EXT) / 1e6;
                  o2.deleteQueryEXT(i2), this.fire(new e.Event("gpu-timing-frame", { cpuTime: t3, gpuTime: n3 })), e.window.performance.mark("frame-gpu", { startTime: r2, detail: { gpuTime: n3 } });
                }, 50);
              }
              if (this.listens("gpu-timing-layer")) {
                const t3 = this.painter.collectGpuTimers();
                setTimeout(() => {
                  const i3 = this.painter.queryGpuTimers(t3);
                  this.fire(new e.Event("gpu-timing-layer", { layerTimes: i3 }));
                }, 50);
              }
              if (this.listens("gpu-timing-deferred-render")) {
                const t3 = this.painter.collectDeferredRenderGpuQueries();
                setTimeout(() => {
                  const i3 = this.painter.queryGpuTimeDeferredRender(t3);
                  this.fire(new e.Event("gpu-timing-deferred-render", { gpuTime: i3 }));
                }, 50);
              }
              const a2 = this._sourcesDirty || this._styleDirty || this._placementDirty || s2;
              if (a2 || this._repaint)
                this.triggerRepaint();
              else {
                const t3 = !this.isMoving() && this.loaded();
                if (t3 && (s2 = this._updateAverageElevation(r2, true)), s2)
                  this.triggerRepaint();
                else if (this._triggerFrame(false), t3 && (this.fire(new e.Event("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                  const t4 = this._calculateSpeedIndex();
                  this.fire(new e.Event("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
                }
              }
              !this._loaded || this._fullyLoaded || a2 || (this._fullyLoaded = true, e.LivePerformanceUtils.mark(e.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e.postPerformanceEvent(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
            }
            _forceMarkerAndPopupUpdate(e2) {
              for (const t2 of this._markers)
                e2 && !this.getRenderWorldCopies() && (t2._lngLat = t2._lngLat.wrap()), t2._update();
              for (const t2 of this._popups)
                !e2 || this.getRenderWorldCopies() || t2._trackPointer || (t2._lngLat = t2._lngLat.wrap()), t2._update();
            }
            _updateAverageElevation(e2, t2 = false) {
              const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
              if (!this.painter.averageElevationNeedsEasing())
                return 0 !== this.transform.averageElevation && i2(0);
              if ((t2 || e2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e2)) {
                const t3 = this.transform.averageElevation;
                let o2 = this.transform.sampleAverageElevation(), r2 = false;
                this.transform.elevation && (r2 = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o2) ? o2 = 0 : this._averageElevationLastSampledAt = e2;
                const n2 = Math.abs(t3 - o2);
                if (n2 > 1) {
                  if (this._isInitialLoad || r2)
                    return this._averageElevation.jumpTo(o2), i2(o2);
                  this._averageElevation.easeTo(o2, e2, 300);
                } else if (n2 > 1e-4)
                  return this._averageElevation.jumpTo(o2), i2(o2);
              }
              return !!this._averageElevation.isEasing(e2) && i2(this._averageElevation.getValue(e2));
            }
            _authenticate() {
              e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t2) => {
                if (t2 && (t2.message === e.AUTH_ERR_MSG || 401 === t2.status)) {
                  const t3 = this.painter.context.gl;
                  e.storeAuthState(t3, false), this._logoControl instanceof Jr && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                }
              }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
              });
            }
            _updateTerrain() {
              const e2 = this._isDragging();
              this.painter.updateTerrain(this.style, e2);
            }
            _calculateSpeedIndex() {
              const e2 = this.painter.canvasCopy(), t2 = this.painter.getCanvasCopiesAndTimestamps();
              t2.timeStamps.push(performance.now());
              const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
              function r2(e3) {
                i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
                const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
                return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
              }
              return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(r2(e2), t2.canvasCopies.map(r2), t2.timeStamps);
            }
            _canvasPixelComparison(e2, t2, i2) {
              let o2 = i2[1] - i2[0];
              const r2 = e2.length / 4;
              for (let n2 = 0; n2 < t2.length; n2++) {
                const s2 = t2[n2];
                let a2 = 0;
                for (let t3 = 0; t3 < s2.length; t3 += 4)
                  s2[t3] === e2[t3] && s2[t3 + 1] === e2[t3 + 1] && s2[t3 + 2] === e2[t3 + 2] && s2[t3 + 3] === e2[t3 + 3] && (a2 += 1);
                o2 += (i2[n2 + 2] - i2[n2 + 1]) * (1 - a2 / r2);
              }
              return o2;
            }
            remove() {
              this._hash && this._hash.remove();
              for (const e2 of this._controls)
                e2.onRemove(this);
              this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener("resize", this._onWindowResize, false), e.window.removeEventListener("orientationchange", this._onWindowResize, false), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, false), e.window.removeEventListener("online", this._onWindowOnline, false), e.window.removeEventListener("visibilitychange", this._onVisibilityChange, false));
              const t2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              t2 && t2.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), e.removeAuthState(this.painter.context.gl), this._removed = true, this.fire(new e.Event("remove"));
            }
            triggerRepaint() {
              this._triggerFrame(true);
            }
            _triggerFrame(t2) {
              this._renderNextFrame = this._renderNextFrame || t2, this.style && !this._frame && (this._frame = e.exported.frame((e2) => {
                const t3 = !!this._renderNextFrame;
                this._frame = null, this._renderNextFrame = null, t3 && this._render(e2);
              }));
            }
            _preloadTiles(t2) {
              const i2 = this.style ? Object.values(this.style._sourceCaches) : [];
              return e.asyncAll(i2, (e2, i3) => e2._preloadTiles(t2, i3), () => {
                this.triggerRepaint();
              }), this;
            }
            _onWindowOnline() {
              this._update();
            }
            _onWindowResize(e2) {
              this._trackResize && this.resize({ originalEvent: e2 })._update();
            }
            _onVisibilityChange() {
              "hidden" === e.window.document.visibilityState && this._visibilityHidden++;
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(e2) {
              this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
            }
            get showTerrainWireframe() {
              return !!this._showTerrainWireframe;
            }
            set showTerrainWireframe(e2) {
              this._showTerrainWireframe !== e2 && (this._showTerrainWireframe = e2, this._update());
            }
            get speedIndexTiming() {
              return !!this._speedIndexTiming;
            }
            set speedIndexTiming(e2) {
              this._speedIndexTiming !== e2 && (this._speedIndexTiming = e2, this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(e2) {
              this._showPadding !== e2 && (this._showPadding = e2, this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(e2) {
              this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(e2) {
              this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(e2) {
              this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(e2) {
              this._vertices = e2, this._update();
            }
            get showTileAABBs() {
              return !!this._showTileAABBs;
            }
            set showTileAABBs(e2) {
              this._showTileAABBs !== e2 && (this._showTileAABBs = e2, e2 && this._update());
            }
            _setCacheLimits(t2, i2) {
              e.setCacheLimits(t2, i2);
            }
            get version() {
              return e.version;
            }
          }, NavigationControl: class {
            constructor(t2) {
              this.options = e.extend({}, hn, t2), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e2) => {
                this._map && this._map.zoomIn({}, { originalEvent: e2 });
              }), n("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e2) => {
                this._map && this._map.zoomOut({}, { originalEvent: e2 });
              }), n("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e2) => {
                const t3 = this._map;
                t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e2 }) : t3.resetNorth({}, { originalEvent: e2 }));
              }), this._compassIcon = n("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
            }
            _updateZoomButtons() {
              const e2 = this._map;
              if (!e2)
                return;
              const t2 = e2.getZoom(), i2 = t2 === e2.getMaxZoom(), o2 = t2 === e2.getMinZoom();
              this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
            }
            _rotateCompassArrow() {
              const e2 = this._map;
              if (!e2)
                return;
              const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e2.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e2.transform.pitch}deg) rotateZ(${e2.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e2.transform.angle * (180 / Math.PI)}deg)`;
              e2._requestDomTask(() => {
                this._compassIcon && (this._compassIcon.style.transform = t2);
              });
            }
            onAdd(e2) {
              return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e2.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e2.on("pitch", this._rotateCompassArrow), e2.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new un(e2, this._compass, this.options.visualizePitch)), this._container;
            }
            onRemove() {
              const e2 = this._map;
              e2 && (this._container.remove(), this.options.showZoom && e2.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e2.off("pitch", this._rotateCompassArrow), e2.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
            }
            _createButton(e2, t2) {
              const i2 = n("button", e2, this._container);
              return i2.type = "button", i2.addEventListener("click", t2), i2;
            }
            _setButtonTitle(e2, t2) {
              if (!this._map)
                return;
              const i2 = this._map._getUIString(`NavigationControl.${t2}`);
              e2.setAttribute("aria-label", i2), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
            }
          }, GeolocateControl: class extends e.Evented {
            constructor(t2) {
              super(), this.options = e.extend({ geolocation: e.window.navigator.geolocation }, _n, t2), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Jo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
            }
            onAdd(e2) {
              return this._map = e2, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
            }
            onRemove() {
              void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
            }
            _checkGeolocationSupport(t2) {
              const i2 = (e2 = !!this.options.geolocation) => {
                this._supportsGeolocation = e2, t2(e2);
              };
              void 0 !== this._supportsGeolocation ? t2(this._supportsGeolocation) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({ name: "geolocation" }).then((e2) => i2("denied" !== e2.state)).catch(() => i2()) : i2();
            }
            _isOutOfMapMaxBounds(e2) {
              const t2 = this._map.getMaxBounds(), i2 = e2.coords;
              return !!t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              }
            }
            _onSuccess(t2) {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(t2))
                  return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t2)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation)
                  switch (this._lastKnownPosition = t2, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t2), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t2)), this._finish();
              }
            }
            _updateCamera(t2) {
              const i2 = new e.LngLat(t2.coords.longitude, t2.coords.latitude), o2 = t2.coords.accuracy, r2 = this._map.getBearing(), n2 = e.extend({ bearing: r2 }, this.options.fitBoundsOptions);
              this._map.fitBounds(i2.toBounds(o2), n2, { geolocateSource: true });
            }
            _updateMarker(t2) {
              if (t2) {
                const i2 = new e.LngLat(t2.coords.longitude, t2.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else
                this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }
            _updateCircleRadius() {
              const t2 = this._map.transform, i2 = e.mercatorZfromAltitude(1, t2._center.lat) * t2.worldSize, o2 = Math.ceil(2 * this._accuracy * i2);
              this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
            }
            _onZoom() {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }
            _updateMarkerRotation() {
              this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
            }
            _onError(t2) {
              if (this._map) {
                if (this.options.trackUserLocation)
                  if (1 === t2.code) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    const e2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2), void 0 !== this._geolocationWatchID && this._clearWatch();
                  } else {
                    if (3 === t2.code && this._noTimeout)
                      return;
                    this._setErrorState();
                  }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t2)), this._finish();
              }
            }
            _finish() {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }
            _setupUI(t2) {
              if (void 0 !== this._map) {
                if (this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this._geolocateButton = n("button", "mapboxgl-ctrl-geolocate", this._container), n("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t2) {
                  e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t3);
                } else {
                  const e2 = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n("div", "mapboxgl-user-location"), this._dotElement.appendChild(n("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new on({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = n("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new on({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t3) => {
                  t3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t3.originalEvent && "resize" === t3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend")));
                });
              }
            }
            _onDeviceOrientation(e2) {
              this._userLocationDotMarker && (e2.webkitCompassHeading ? this._heading = e2.webkitCompassHeading : true === e2.absolute && (this._heading = -1 * e2.alpha), this._updateMarkerRotationThrottled());
            }
            trigger() {
              if (!this._setup)
                return e.warnOnce("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart"));
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_ERROR":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                    break;
                  case "BACKGROUND":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                    break;
                  case "BACKGROUND_ERROR":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                }
                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                  this._clearWatch();
                else if (void 0 === this._geolocationWatchID) {
                  let e2;
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e2 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e2), this.options.showUserHeading && this._addDeviceOrientationListener();
                }
              } else
                this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
              return true;
            }
            _addDeviceOrientationListener() {
              const t2 = () => {
                e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
              };
              void 0 !== e.window.DeviceMotionEvent && "function" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((e2) => {
                "granted" === e2 && t2();
              }).catch(console.error) : t2();
            }
            _clearWatch() {
              this.options.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }
          }, AttributionControl: Kr, ScaleControl: class {
            constructor(t2) {
              this.options = e.extend({}, dn, t2), function() {
                try {
                  return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "narrow", unit: "meter" }), true;
                } catch (e2) {
                  return false;
                }
              }() || (this._setScale = pn.bind(this)), e.bindAll(["_update", "_setScale", "setUnit"], this);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            _update() {
              const e2 = this.options.maxWidth || 100, t2 = this._map, i2 = t2._containerHeight / 2, o2 = t2._containerWidth / 2 - e2 / 2, r2 = t2.unproject([o2, i2]), n2 = t2.unproject([o2 + e2, i2]), s2 = r2.distanceTo(n2);
              if ("imperial" === this.options.unit) {
                const t3 = 3.2808 * s2;
                t3 > 5280 ? this._setScale(e2, t3 / 5280, "mile") : this._setScale(e2, t3, "foot");
              } else
                "nautical" === this.options.unit ? this._setScale(e2, s2 / 1852, "nautical-mile") : s2 >= 1e3 ? this._setScale(e2, s2 / 1e3, "kilometer") : this._setScale(e2, s2, "meter");
            }
            _setScale(e2, t2, i2) {
              const o2 = mn(t2), r2 = o2 / t2;
              this._map._requestDomTask(() => {
                this._container.style.width = e2 * r2 + "px", this._container.innerHTML = "nautical-mile" !== i2 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "narrow", unit: i2 }).format(o2) : `${o2}&nbsp;nm`;
              });
            }
            onAdd(e2) {
              return this._map = e2, this._language = e2.getLanguage(), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e2.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
            }
            onRemove() {
              this._container.remove(), this._map.off("move", this._update), this._map = void 0;
            }
            _setLanguage(e2) {
              this._language = e2, this._update();
            }
            setUnit(e2) {
              this.options.unit = e2, this._update();
            }
          }, FullscreenControl: class {
            constructor(t2) {
              this._fullscreen = false, t2 && t2.container && (t2.container instanceof e.window.HTMLElement ? this._container = t2.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange");
            }
            onAdd(t2) {
              return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
            }
            onRemove() {
              this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
            }
            _checkFullscreenSupport() {
              return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);
            }
            _setupUI() {
              const t2 = this._fullscreenButton = n("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
              n("span", "mapboxgl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
            }
            _updateTitle() {
              const e2 = this._getTitle();
              this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e2);
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _changeIcon() {
              (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
            }
            _onClickFullscreen() {
              this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
            }
          }, Popup: class extends e.Evented {
            constructor(t2) {
              super(), this.options = e.extend(Object.create(rn), t2), e.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t2 && t2.className ? t2.className.trim().split(/\s+/) : []);
            }
            addTo(t2) {
              return this._map && this.remove(), this._map = t2, this.options.closeOnClick && t2.on("preclick", this._onClose), this.options.closeOnMove && t2.on("move", this._onClose), t2.on("remove", this.remove), this._update(), t2._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t2.on("mousemove", this._onMouseEvent), t2.on("mouseup", this._onMouseEvent), t2._canvasContainer.classList.add("mapboxgl-track-pointer")) : t2.on("move", this._update), this.fire(new e.Event("open")), this;
            }
            isOpen() {
              return !!this._map;
            }
            remove() {
              this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
              const t2 = this._map;
              return t2 && (t2.off("move", this._update), t2.off("move", this._onClose), t2.off("preclick", this._onClose), t2.off("click", this._onClose), t2.off("remove", this.remove), t2.off("mousemove", this._onMouseEvent), t2.off("mouseup", this._onMouseEvent), t2.off("drag", this._onMouseEvent), t2._canvasContainer && t2._canvasContainer.classList.remove("mapboxgl-track-pointer"), t2._removePopup(this), this._map = void 0), this.fire(new e.Event("close")), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(t2) {
              this._lngLat = e.LngLat.convert(t2), this._pos = null, this._trackPointer = false, this._update();
              const i2 = this._map;
              return i2 && (i2.on("move", this._update), i2.off("mousemove", this._onMouseEvent), i2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
            }
            trackPointer() {
              this._trackPointer = true, this._pos = null, this._update();
              const e2 = this._map;
              return e2 && (e2.off("move", this._update), e2.on("mousemove", this._onMouseEvent), e2.on("drag", this._onMouseEvent), e2._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
            }
            getElement() {
              return this._container;
            }
            setText(t2) {
              return this.setDOMContent(e.window.document.createTextNode(t2));
            }
            setHTML(t2) {
              const i2 = e.window.document.createDocumentFragment(), o2 = e.window.document.createElement("body");
              let r2;
              for (o2.innerHTML = t2; r2 = o2.firstChild, r2; )
                i2.appendChild(r2);
              return this.setDOMContent(i2);
            }
            getMaxWidth() {
              return this._container && this._container.style.maxWidth;
            }
            setMaxWidth(e2) {
              return this.options.maxWidth = e2, this._update(), this;
            }
            setDOMContent(e2) {
              let t2 = this._content;
              if (t2)
                for (; t2.hasChildNodes(); )
                  t2.firstChild && t2.removeChild(t2.firstChild);
              else
                t2 = this._content = n("div", "mapboxgl-popup-content", this._container || void 0);
              if (t2.appendChild(e2), this.options.closeButton) {
                const e3 = this._closeButton = n("button", "mapboxgl-popup-close-button", t2);
                e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.setAttribute("aria-hidden", "true"), e3.innerHTML = "&#215;", e3.addEventListener("click", this._onClose);
              }
              return this._update(), this._focusFirstElement(), this;
            }
            addClassName(e2) {
              return this._classList.add(e2), this._updateClassList(), this;
            }
            removeClassName(e2) {
              return this._classList.delete(e2), this._updateClassList(), this;
            }
            setOffset(e2) {
              return this.options.offset = e2, this._update(), this;
            }
            toggleClassName(e2) {
              let t2;
              return this._classList.delete(e2) ? t2 = false : (this._classList.add(e2), t2 = true), this._updateClassList(), t2;
            }
            _onMouseEvent(e2) {
              this._update(e2.point);
            }
            _getAnchor(e2) {
              if (this.options.anchor)
                return this.options.anchor;
              const t2 = this._map, i2 = this._container, o2 = this._pos;
              if (!t2 || !i2 || !o2)
                return "bottom";
              const r2 = i2.offsetWidth, n2 = i2.offsetHeight, s2 = o2.x < r2 / 2, a2 = o2.x > t2.transform.width - r2 / 2;
              if (o2.y + e2 < n2)
                return s2 ? "top-left" : a2 ? "top-right" : "top";
              if (o2.y > t2.transform.height - n2) {
                if (s2)
                  return "bottom-left";
                if (a2)
                  return "bottom-right";
              }
              return s2 ? "left" : a2 ? "right" : "bottom";
            }
            _updateClassList() {
              const e2 = this._container;
              if (!e2)
                return;
              const t2 = [...this._classList];
              t2.push("mapboxgl-popup"), this._anchor && t2.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t2.push("mapboxgl-popup-track-pointer"), e2.className = t2.join(" ");
            }
            _update(t2) {
              const i2 = this._map, o2 = this._content;
              if (!i2 || !this._lngLat && !this._trackPointer || !o2)
                return;
              let r2 = this._container;
              if (r2 || (r2 = this._container = n("div", "mapboxgl-popup", i2.getContainer()), this._tip = n("div", "mapboxgl-popup-tip", r2), r2.appendChild(o2)), this.options.maxWidth && r2.style.maxWidth !== this.options.maxWidth && (r2.style.maxWidth = this.options.maxWidth), i2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = en(this._lngLat, this._pos, i2.transform)), !this._trackPointer || t2) {
                const e2 = this._pos = this._trackPointer && t2 ? t2 : i2.project(this._lngLat), o3 = sn(this.options.offset), r3 = this._anchor = this._getAnchor(o3.y), n2 = sn(this.options.offset, r3), s2 = e2.add(n2).round();
                i2._requestDomTask(() => {
                  this._container && r3 && (this._container.style.transform = `${tn[r3]} translate(${s2.x}px,${s2.y}px)`);
                });
              }
              if (!this._marker && i2._showingGlobe()) {
                const t3 = e.isLngLatBehindGlobe(i2.transform, this._lngLat) ? 0 : 1;
                this._setOpacity(t3);
              }
              this._updateClassList();
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container)
                return;
              const e2 = this._container.querySelector(nn);
              e2 && e2.focus();
            }
            _onClose() {
              this.remove();
            }
            _setOpacity(e2) {
              this._container && (this._container.style.opacity = `${e2}`), this._content && (this._content.style.pointerEvents = e2 ? "auto" : "none");
            }
          }, Marker: on, Style: Qt, LngLat: e.LngLat, LngLatBounds: e.LngLatBounds, Point: e.pointGeometry, MercatorCoordinate: e.MercatorCoordinate, FreeCameraOptions: Zo, Evented: e.Evented, config: e.config, prewarm: function() {
            je().acquire(Ue);
          }, clearPrewarmedResources: function() {
            const e2 = Ge;
            e2 && (e2.isPreloaded() && 1 === e2.numActive() ? (e2.release(Ue), Ge = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, get accessToken() {
            return e.config.ACCESS_TOKEN;
          }, set accessToken(t2) {
            e.config.ACCESS_TOKEN = t2;
          }, get baseApiUrl() {
            return e.config.API_URL;
          }, set baseApiUrl(t2) {
            e.config.API_URL = t2;
          }, get workerCount() {
            return Ne.workerCount;
          }, set workerCount(e2) {
            Ne.workerCount = e2;
          }, get maxParallelImageRequests() {
            return e.config.MAX_PARALLEL_IMAGE_REQUESTS;
          }, set maxParallelImageRequests(t2) {
            e.config.MAX_PARALLEL_IMAGE_REQUESTS = t2;
          }, clearStorage(t2) {
            e.clearTileCache(t2);
          }, workerUrl: "", workerClass: null, setNow: e.exported.setNow, restoreNow: e.exported.restoreNow };
          return fn2;
        });
        var mapboxgl$1 = mapboxgl2;
        return mapboxgl$1;
      });
    }
  });

  // script.js
  var import_mapbox_gl = __toESM(require_mapbox_gl());

  // node_modules/@popperjs/core/lib/index.js
  var lib_exports = {};
  __export(lib_exports, {
    afterMain: () => afterMain,
    afterRead: () => afterRead,
    afterWrite: () => afterWrite,
    applyStyles: () => applyStyles_default,
    arrow: () => arrow_default,
    auto: () => auto,
    basePlacements: () => basePlacements,
    beforeMain: () => beforeMain,
    beforeRead: () => beforeRead,
    beforeWrite: () => beforeWrite,
    bottom: () => bottom,
    clippingParents: () => clippingParents,
    computeStyles: () => computeStyles_default,
    createPopper: () => createPopper3,
    createPopperBase: () => createPopper,
    createPopperLite: () => createPopper2,
    detectOverflow: () => detectOverflow,
    end: () => end,
    eventListeners: () => eventListeners_default,
    flip: () => flip_default,
    hide: () => hide_default,
    left: () => left,
    main: () => main,
    modifierPhases: () => modifierPhases,
    offset: () => offset_default,
    placements: () => placements,
    popper: () => popper,
    popperGenerator: () => popperGenerator,
    popperOffsets: () => popperOffsets_default,
    preventOverflow: () => preventOverflow_default,
    read: () => read,
    reference: () => reference,
    right: () => right,
    start: () => start,
    top: () => top,
    variationPlacements: () => variationPlacements,
    viewport: () => viewport,
    write: () => write
  });

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (true) {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      if (true) {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      }
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }, getWindow(popper2)) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    if (true) {
      var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
      if (true) {
        console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
      }
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map2 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map2.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map2.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/format.js
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p, c) {
      return p.replace(/%s/, c);
    }, str);
  }

  // node_modules/@popperjs/core/lib/utils/validateModifiers.js
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
        return self2.indexOf(value) === index;
      }).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
            break;
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (modifier.effect != null && typeof modifier.effect !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
              return '"' + s + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  // node_modules/@popperjs/core/lib/utils/uniqueBy.js
  function uniqueBy(arr, fn2) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn2(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper4(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          if (true) {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name = _ref2.name;
                return name === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (true) {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        if (true) {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
          if (typeof effect4 === "function") {
            var cleanupFn = effect4({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var createPopper = /* @__PURE__ */ popperGenerator();

  // node_modules/@popperjs/core/lib/popper-lite.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
  var createPopper2 = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper3 = /* @__PURE__ */ popperGenerator({
    defaultModifiers: defaultModifiers2
  });

  // node_modules/bootstrap/dist/js/bootstrap.esm.js
  var MAX_UID = 1e6;
  var MILLISECONDS_MULTIPLIER = 1e3;
  var TRANSITION_END = "transitionend";
  var toType = (object) => {
    if (object === null || object === void 0) {
      return `${object}`;
    }
    return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
  };
  var getUID = (prefix) => {
    do {
      prefix += Math.floor(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));
    return prefix;
  };
  var getSelector = (element) => {
    let selector = element.getAttribute("data-bs-target");
    if (!selector || selector === "#") {
      let hrefAttribute = element.getAttribute("href");
      if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
        return null;
      }
      if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
        hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
      }
      selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
    }
    return selector;
  };
  var getSelectorFromElement = (element) => {
    const selector = getSelector(element);
    if (selector) {
      return document.querySelector(selector) ? selector : null;
    }
    return null;
  };
  var getElementFromSelector = (element) => {
    const selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };
  var getTransitionDurationFromElement = (element) => {
    if (!element) {
      return 0;
    }
    let {
      transitionDuration,
      transitionDelay
    } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }
    transitionDuration = transitionDuration.split(",")[0];
    transitionDelay = transitionDelay.split(",")[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };
  var triggerTransitionEnd = (element) => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };
  var isElement2 = (object) => {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (typeof object.jquery !== "undefined") {
      object = object[0];
    }
    return typeof object.nodeType !== "undefined";
  };
  var getElement = (object) => {
    if (isElement2(object)) {
      return object.jquery ? object[0] : object;
    }
    if (typeof object === "string" && object.length > 0) {
      return document.querySelector(object);
    }
    return null;
  };
  var isVisible = (element) => {
    if (!isElement2(element) || element.getClientRects().length === 0) {
      return false;
    }
    const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
    const closedDetails = element.closest("details:not([open])");
    if (!closedDetails) {
      return elementIsVisible;
    }
    if (closedDetails !== element) {
      const summary = element.closest("summary");
      if (summary && summary.parentNode !== closedDetails) {
        return false;
      }
      if (summary === null) {
        return false;
      }
    }
    return elementIsVisible;
  };
  var isDisabled = (element) => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    if (element.classList.contains("disabled")) {
      return true;
    }
    if (typeof element.disabled !== "undefined") {
      return element.disabled;
    }
    return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
  };
  var findShadowRoot = (element) => {
    if (!document.documentElement.attachShadow) {
      return null;
    }
    if (typeof element.getRootNode === "function") {
      const root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) {
      return element;
    }
    if (!element.parentNode) {
      return null;
    }
    return findShadowRoot(element.parentNode);
  };
  var noop = () => {
  };
  var reflow = (element) => {
    element.offsetHeight;
  };
  var getjQuery = () => {
    if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
      return window.jQuery;
    }
    return null;
  };
  var DOMContentLoadedCallbacks = [];
  var onDOMContentLoaded = (callback) => {
    if (document.readyState === "loading") {
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener("DOMContentLoaded", () => {
          for (const callback2 of DOMContentLoadedCallbacks) {
            callback2();
          }
        });
      }
      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  var isRTL = () => document.documentElement.dir === "rtl";
  var defineJQueryPlugin = (plugin) => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;
        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  var execute = (callback) => {
    if (typeof callback === "function") {
      callback();
    }
  };
  var executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({
      target
    }) => {
      if (target !== transitionElement) {
        return;
      }
      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  var getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
    const listLength = list.length;
    let index = list.indexOf(activeElement);
    if (index === -1) {
      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    }
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }
    return list[Math.max(0, Math.min(index, listLength - 1))];
  };
  var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  var stripNameRegex = /\..*/;
  var stripUidRegex = /::\d+$/;
  var eventRegistry = {};
  var uidEvent = 1;
  var customEvents = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  };
  var nativeEvents = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
  function makeEventUid(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
  }
  function getElementEvents(element) {
    const uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }
  function bootstrapHandler(element, fn2) {
    return function handler(event) {
      hydrateObj(event, {
        delegateTarget: element
      });
      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn2);
      }
      return fn2.apply(element, [event]);
    };
  }
  function bootstrapDelegationHandler(element, selector, fn2) {
    return function handler(event) {
      const domElements = element.querySelectorAll(selector);
      for (let {
        target
      } = event; target && target !== this; target = target.parentNode) {
        for (const domElement of domElements) {
          if (domElement !== target) {
            continue;
          }
          hydrateObj(event, {
            delegateTarget: target
          });
          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn2);
          }
          return fn2.apply(target, [event]);
        }
      }
    };
  }
  function findHandler(events, callable, delegationSelector = null) {
    return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
  }
  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    const isDelegated = typeof handler === "string";
    const callable = isDelegated ? delegationFunction : handler || delegationFunction;
    let typeEvent = getTypeEvent(originalTypeEvent);
    if (!nativeEvents.has(typeEvent)) {
      typeEvent = originalTypeEvent;
    }
    return [isDelegated, callable, typeEvent];
  }
  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    if (originalTypeEvent in customEvents) {
      const wrapFunction = (fn3) => {
        return function(event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn3.call(this, event);
          }
        };
      };
      callable = wrapFunction(callable);
    }
    const events = getElementEvents(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
    if (previousFunction) {
      previousFunction.oneOff = previousFunction.oneOff && oneOff;
      return;
    }
    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
    const fn2 = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
    fn2.delegationSelector = isDelegated ? handler : null;
    fn2.callable = callable;
    fn2.oneOff = oneOff;
    fn2.uidEvent = uid;
    handlers[uid] = fn2;
    element.addEventListener(typeEvent, fn2, isDelegated);
  }
  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn2 = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn2) {
      return;
    }
    element.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));
    delete events[typeEvent][fn2.uidEvent];
  }
  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    for (const handlerKey of Object.keys(storeElementEvent)) {
      if (handlerKey.includes(namespace)) {
        const event = storeElementEvent[handlerKey];
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  }
  function getTypeEvent(event) {
    event = event.replace(stripNameRegex, "");
    return customEvents[event] || event;
  }
  var EventHandler = {
    on(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, false);
    },
    one(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, true);
    },
    off(element, originalTypeEvent, handler, delegationFunction) {
      if (typeof originalTypeEvent !== "string" || !element) {
        return;
      }
      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
      const inNamespace = typeEvent !== originalTypeEvent;
      const events = getElementEvents(element);
      const storeElementEvent = events[typeEvent] || {};
      const isNamespace = originalTypeEvent.startsWith(".");
      if (typeof callable !== "undefined") {
        if (!Object.keys(storeElementEvent).length) {
          return;
        }
        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
        return;
      }
      if (isNamespace) {
        for (const elementEvent of Object.keys(events)) {
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        }
      }
      for (const keyHandlers of Object.keys(storeElementEvent)) {
        const handlerKey = keyHandlers.replace(stripUidRegex, "");
        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          const event = storeElementEvent[keyHandlers];
          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
      }
    },
    trigger(element, event, args) {
      if (typeof event !== "string" || !element) {
        return null;
      }
      const $ = getjQuery();
      const typeEvent = getTypeEvent(event);
      const inNamespace = event !== typeEvent;
      let jQueryEvent = null;
      let bubbles = true;
      let nativeDispatch = true;
      let defaultPrevented = false;
      if (inNamespace && $) {
        jQueryEvent = $.Event(event, args);
        $(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }
      let evt = new Event(event, {
        bubbles,
        cancelable: true
      });
      evt = hydrateObj(evt, args);
      if (defaultPrevented) {
        evt.preventDefault();
      }
      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }
      if (evt.defaultPrevented && jQueryEvent) {
        jQueryEvent.preventDefault();
      }
      return evt;
    }
  };
  function hydrateObj(obj, meta) {
    for (const [key, value] of Object.entries(meta || {})) {
      try {
        obj[key] = value;
      } catch (_unused) {
        Object.defineProperty(obj, key, {
          configurable: true,
          get() {
            return value;
          }
        });
      }
    }
    return obj;
  }
  var elementMap = /* @__PURE__ */ new Map();
  var Data = {
    set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, /* @__PURE__ */ new Map());
      }
      const instanceMap = elementMap.get(element);
      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
        return;
      }
      instanceMap.set(key, instance);
    },
    get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }
      return null;
    },
    remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }
      const instanceMap = elementMap.get(element);
      instanceMap.delete(key);
      if (instanceMap.size === 0) {
        elementMap.delete(element);
      }
    }
  };
  function normalizeData(value) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    if (value === Number(value).toString()) {
      return Number(value);
    }
    if (value === "" || value === "null") {
      return null;
    }
    if (typeof value !== "string") {
      return value;
    }
    try {
      return JSON.parse(decodeURIComponent(value));
    } catch (_unused) {
      return value;
    }
  }
  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
  }
  var Manipulator = {
    setDataAttribute(element, key, value) {
      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute(element, key) {
      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes(element) {
      if (!element) {
        return {};
      }
      const attributes = {};
      const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
      for (const key of bsKeys) {
        let pureKey = key.replace(/^bs/, "");
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      }
      return attributes;
    },
    getDataAttribute(element, key) {
      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    }
  };
  var Config = class {
    // Getters
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      return config;
    }
    _mergeConfigObj(config, element) {
      const jsonConfig = isElement2(element) ? Manipulator.getDataAttribute(element, "config") : {};
      return {
        ...this.constructor.Default,
        ...typeof jsonConfig === "object" ? jsonConfig : {},
        ...isElement2(element) ? Manipulator.getDataAttributes(element) : {},
        ...typeof config === "object" ? config : {}
      };
    }
    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
      for (const property of Object.keys(configTypes)) {
        const expectedTypes = configTypes[property];
        const value = config[property];
        const valueType = isElement2(value) ? "element" : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
        }
      }
    }
  };
  var VERSION = "5.2.3";
  var BaseComponent = class extends Config {
    constructor(element, config) {
      super();
      element = getElement(element);
      if (!element) {
        return;
      }
      this._element = element;
      this._config = this._getConfig(config);
      Data.set(this._element, this.constructor.DATA_KEY, this);
    }
    // Public
    dispose() {
      Data.remove(this._element, this.constructor.DATA_KEY);
      EventHandler.off(this._element, this.constructor.EVENT_KEY);
      for (const propertyName of Object.getOwnPropertyNames(this)) {
        this[propertyName] = null;
      }
    }
    _queueCallback(callback, element, isAnimated = true) {
      executeAfterTransition(callback, element, isAnimated);
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config, this._element);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    // Static
    static getInstance(element) {
      return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config = {}) {
      return this.getInstance(element) || new this(element, typeof config === "object" ? config : null);
    }
    static get VERSION() {
      return VERSION;
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(name) {
      return `${name}${this.EVENT_KEY}`;
    }
  };
  var enableDismissTrigger = (component, method = "hide") => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      const target = getElementFromSelector(this) || this.closest(`.${name}`);
      const instance = component.getOrCreateInstance(target);
      instance[method]();
    });
  };
  var NAME$f = "alert";
  var DATA_KEY$a = "bs.alert";
  var EVENT_KEY$b = `.${DATA_KEY$a}`;
  var EVENT_CLOSE = `close${EVENT_KEY$b}`;
  var EVENT_CLOSED = `closed${EVENT_KEY$b}`;
  var CLASS_NAME_FADE$5 = "fade";
  var CLASS_NAME_SHOW$8 = "show";
  var Alert = class extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$f;
    }
    // Public
    close() {
      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
      if (closeEvent.defaultPrevented) {
        return;
      }
      this._element.classList.remove(CLASS_NAME_SHOW$8);
      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
    }
    // Private
    _destroyElement() {
      this._element.remove();
      EventHandler.trigger(this._element, EVENT_CLOSED);
      this.dispose();
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Alert.getOrCreateInstance(this);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  };
  enableDismissTrigger(Alert, "close");
  defineJQueryPlugin(Alert);
  var NAME$e = "button";
  var DATA_KEY$9 = "bs.button";
  var EVENT_KEY$a = `.${DATA_KEY$9}`;
  var DATA_API_KEY$6 = ".data-api";
  var CLASS_NAME_ACTIVE$3 = "active";
  var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
  var EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
  var Button = class extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$e;
    }
    // Public
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Button.getOrCreateInstance(this);
        if (config === "toggle") {
          data[config]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
  });
  defineJQueryPlugin(Button);
  var SelectorEngine = {
    find(selector, element = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne(selector, element = document.documentElement) {
      return Element.prototype.querySelector.call(element, selector);
    },
    children(element, selector) {
      return [].concat(...element.children).filter((child) => child.matches(selector));
    },
    parents(element, selector) {
      const parents = [];
      let ancestor = element.parentNode.closest(selector);
      while (ancestor) {
        parents.push(ancestor);
        ancestor = ancestor.parentNode.closest(selector);
      }
      return parents;
    },
    prev(element, selector) {
      let previous = element.previousElementSibling;
      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }
        previous = previous.previousElementSibling;
      }
      return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next(element, selector) {
      let next = element.nextElementSibling;
      while (next) {
        if (next.matches(selector)) {
          return [next];
        }
        next = next.nextElementSibling;
      }
      return [];
    },
    focusableChildren(element) {
      const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
      return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
    }
  };
  var NAME$d = "swipe";
  var EVENT_KEY$9 = ".bs.swipe";
  var EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
  var EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
  var EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
  var EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
  var EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
  var POINTER_TYPE_TOUCH = "touch";
  var POINTER_TYPE_PEN = "pen";
  var CLASS_NAME_POINTER_EVENT = "pointer-event";
  var SWIPE_THRESHOLD = 40;
  var Default$c = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
  };
  var DefaultType$c = {
    endCallback: "(function|null)",
    leftCallback: "(function|null)",
    rightCallback: "(function|null)"
  };
  var Swipe = class extends Config {
    constructor(element, config) {
      super();
      this._element = element;
      if (!element || !Swipe.isSupported()) {
        return;
      }
      this._config = this._getConfig(config);
      this._deltaX = 0;
      this._supportPointerEvents = Boolean(window.PointerEvent);
      this._initEvents();
    }
    // Getters
    static get Default() {
      return Default$c;
    }
    static get DefaultType() {
      return DefaultType$c;
    }
    static get NAME() {
      return NAME$d;
    }
    // Public
    dispose() {
      EventHandler.off(this._element, EVENT_KEY$9);
    }
    // Private
    _start(event) {
      if (!this._supportPointerEvents) {
        this._deltaX = event.touches[0].clientX;
        return;
      }
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX;
      }
    }
    _end(event) {
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX - this._deltaX;
      }
      this._handleSwipe();
      execute(this._config.endCallback);
    }
    _move(event) {
      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const absDeltaX = Math.abs(this._deltaX);
      if (absDeltaX <= SWIPE_THRESHOLD) {
        return;
      }
      const direction = absDeltaX / this._deltaX;
      this._deltaX = 0;
      if (!direction) {
        return;
      }
      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      if (this._supportPointerEvents) {
        EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
        EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
        EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
        EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
      }
    }
    _eventIsPointerPenTouch(event) {
      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    }
    // Static
    static isSupported() {
      return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
    }
  };
  var NAME$c = "carousel";
  var DATA_KEY$8 = "bs.carousel";
  var EVENT_KEY$8 = `.${DATA_KEY$8}`;
  var DATA_API_KEY$5 = ".data-api";
  var ARROW_LEFT_KEY$1 = "ArrowLeft";
  var ARROW_RIGHT_KEY$1 = "ArrowRight";
  var TOUCHEVENT_COMPAT_WAIT = 500;
  var ORDER_NEXT = "next";
  var ORDER_PREV = "prev";
  var DIRECTION_LEFT = "left";
  var DIRECTION_RIGHT = "right";
  var EVENT_SLIDE = `slide${EVENT_KEY$8}`;
  var EVENT_SLID = `slid${EVENT_KEY$8}`;
  var EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
  var EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
  var EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
  var EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
  var EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
  var EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
  var CLASS_NAME_CAROUSEL = "carousel";
  var CLASS_NAME_ACTIVE$2 = "active";
  var CLASS_NAME_SLIDE = "slide";
  var CLASS_NAME_END = "carousel-item-end";
  var CLASS_NAME_START = "carousel-item-start";
  var CLASS_NAME_NEXT = "carousel-item-next";
  var CLASS_NAME_PREV = "carousel-item-prev";
  var SELECTOR_ACTIVE = ".active";
  var SELECTOR_ITEM = ".carousel-item";
  var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
  var SELECTOR_ITEM_IMG = ".carousel-item img";
  var SELECTOR_INDICATORS = ".carousel-indicators";
  var SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
  var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  var KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
  };
  var Default$b = {
    interval: 5e3,
    keyboard: true,
    pause: "hover",
    ride: false,
    touch: true,
    wrap: true
  };
  var DefaultType$b = {
    interval: "(number|boolean)",
    // TODO:v6 remove boolean support
    keyboard: "boolean",
    pause: "(string|boolean)",
    ride: "(boolean|string)",
    touch: "boolean",
    wrap: "boolean"
  };
  var Carousel = class extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._interval = null;
      this._activeElement = null;
      this._isSliding = false;
      this.touchTimeout = null;
      this._swipeHelper = null;
      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
      this._addEventListeners();
      if (this._config.ride === CLASS_NAME_CAROUSEL) {
        this.cycle();
      }
    }
    // Getters
    static get Default() {
      return Default$b;
    }
    static get DefaultType() {
      return DefaultType$b;
    }
    static get NAME() {
      return NAME$c;
    }
    // Public
    next() {
      this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
      if (!document.hidden && isVisible(this._element)) {
        this.next();
      }
    }
    prev() {
      this._slide(ORDER_PREV);
    }
    pause() {
      if (this._isSliding) {
        triggerTransitionEnd(this._element);
      }
      this._clearInterval();
    }
    cycle() {
      this._clearInterval();
      this._updateInterval();
      this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
      if (!this._config.ride) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
        return;
      }
      this.cycle();
    }
    to(index) {
      const items = this._getItems();
      if (index > items.length - 1 || index < 0) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
        return;
      }
      const activeIndex = this._getItemIndex(this._getActive());
      if (activeIndex === index) {
        return;
      }
      const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
      this._slide(order2, items[index]);
    }
    dispose() {
      if (this._swipeHelper) {
        this._swipeHelper.dispose();
      }
      super.dispose();
    }
    // Private
    _configAfterMerge(config) {
      config.defaultInterval = config.interval;
      return config;
    }
    _addEventListeners() {
      if (this._config.keyboard) {
        EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
      }
      if (this._config.pause === "hover") {
        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
      }
      if (this._config.touch && Swipe.isSupported()) {
        this._addTouchEventListeners();
      }
    }
    _addTouchEventListeners() {
      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
        EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
      }
      const endCallBack = () => {
        if (this._config.pause !== "hover") {
          return;
        }
        this.pause();
        if (this.touchTimeout) {
          clearTimeout(this.touchTimeout);
        }
        this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
      };
      const swipeConfig = {
        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
        rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
        endCallback: endCallBack
      };
      this._swipeHelper = new Swipe(this._element, swipeConfig);
    }
    _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }
      const direction = KEY_TO_DIRECTION[event.key];
      if (direction) {
        event.preventDefault();
        this._slide(this._directionToOrder(direction));
      }
    }
    _getItemIndex(element) {
      return this._getItems().indexOf(element);
    }
    _setActiveIndicatorElement(index) {
      if (!this._indicatorsElement) {
        return;
      }
      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
      activeIndicator.removeAttribute("aria-current");
      const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
      if (newActiveIndicator) {
        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
        newActiveIndicator.setAttribute("aria-current", "true");
      }
    }
    _updateInterval() {
      const element = this._activeElement || this._getActive();
      if (!element) {
        return;
      }
      const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
      this._config.interval = elementInterval || this._config.defaultInterval;
    }
    _slide(order2, element = null) {
      if (this._isSliding) {
        return;
      }
      const activeElement = this._getActive();
      const isNext = order2 === ORDER_NEXT;
      const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
      if (nextElement === activeElement) {
        return;
      }
      const nextElementIndex = this._getItemIndex(nextElement);
      const triggerEvent = (eventName) => {
        return EventHandler.trigger(this._element, eventName, {
          relatedTarget: nextElement,
          direction: this._orderToDirection(order2),
          from: this._getItemIndex(activeElement),
          to: nextElementIndex
        });
      };
      const slideEvent = triggerEvent(EVENT_SLIDE);
      if (slideEvent.defaultPrevented) {
        return;
      }
      if (!activeElement || !nextElement) {
        return;
      }
      const isCycling = Boolean(this._interval);
      this.pause();
      this._isSliding = true;
      this._setActiveIndicatorElement(nextElementIndex);
      this._activeElement = nextElement;
      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
      nextElement.classList.add(orderClassName);
      reflow(nextElement);
      activeElement.classList.add(directionalClassName);
      nextElement.classList.add(directionalClassName);
      const completeCallBack = () => {
        nextElement.classList.remove(directionalClassName, orderClassName);
        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
        this._isSliding = false;
        triggerEvent(EVENT_SLID);
      };
      this._queueCallback(completeCallBack, activeElement, this._isAnimated());
      if (isCycling) {
        this.cycle();
      }
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_SLIDE);
    }
    _getActive() {
      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
    }
    _getItems() {
      return SelectorEngine.find(SELECTOR_ITEM, this._element);
    }
    _clearInterval() {
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
    }
    _directionToOrder(direction) {
      if (isRTL()) {
        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
      }
      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order2) {
      if (isRTL()) {
        return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Carousel.getOrCreateInstance(this, config);
        if (typeof config === "number") {
          data.to(config);
          return;
        }
        if (typeof config === "string") {
          if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
    const target = getElementFromSelector(this);
    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
      return;
    }
    event.preventDefault();
    const carousel = Carousel.getOrCreateInstance(target);
    const slideIndex = this.getAttribute("data-bs-slide-to");
    if (slideIndex) {
      carousel.to(slideIndex);
      carousel._maybeEnableCycle();
      return;
    }
    if (Manipulator.getDataAttribute(this, "slide") === "next") {
      carousel.next();
      carousel._maybeEnableCycle();
      return;
    }
    carousel.prev();
    carousel._maybeEnableCycle();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for (const carousel of carousels) {
      Carousel.getOrCreateInstance(carousel);
    }
  });
  defineJQueryPlugin(Carousel);
  var NAME$b = "collapse";
  var DATA_KEY$7 = "bs.collapse";
  var EVENT_KEY$7 = `.${DATA_KEY$7}`;
  var DATA_API_KEY$4 = ".data-api";
  var EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
  var EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
  var EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
  var EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
  var EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
  var CLASS_NAME_SHOW$7 = "show";
  var CLASS_NAME_COLLAPSE = "collapse";
  var CLASS_NAME_COLLAPSING = "collapsing";
  var CLASS_NAME_COLLAPSED = "collapsed";
  var CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
  var CLASS_NAME_HORIZONTAL = "collapse-horizontal";
  var WIDTH = "width";
  var HEIGHT = "height";
  var SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
  var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
  var Default$a = {
    parent: null,
    toggle: true
  };
  var DefaultType$a = {
    parent: "(null|element)",
    toggle: "boolean"
  };
  var Collapse = class extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._isTransitioning = false;
      this._triggerArray = [];
      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
      for (const elem of toggleList) {
        const selector = getSelectorFromElement(elem);
        const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
        if (selector !== null && filterElement.length) {
          this._triggerArray.push(elem);
        }
      }
      this._initializeChildren();
      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }
      if (this._config.toggle) {
        this.toggle();
      }
    }
    // Getters
    static get Default() {
      return Default$a;
    }
    static get DefaultType() {
      return DefaultType$a;
    }
    static get NAME() {
      return NAME$b;
    }
    // Public
    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      let activeChildren = [];
      if (this._config.parent) {
        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => Collapse.getOrCreateInstance(element, {
          toggle: false
        }));
      }
      if (activeChildren.length && activeChildren[0]._isTransitioning) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      for (const activeInstance of activeChildren) {
        activeInstance.hide();
      }
      const dimension = this._getDimension();
      this._element.classList.remove(CLASS_NAME_COLLAPSE);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        this._element.style[dimension] = "";
        EventHandler.trigger(this._element, EVENT_SHOWN$6);
      };
      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      const scrollSize = `scroll${capitalizedDimension}`;
      this._queueCallback(complete, this._element, true);
      this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      const dimension = this._getDimension();
      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      for (const trigger of this._triggerArray) {
        const element = getElementFromSelector(trigger);
        if (element && !this._isShown(element)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE);
        EventHandler.trigger(this._element, EVENT_HIDDEN$6);
      };
      this._element.style[dimension] = "";
      this._queueCallback(complete, this._element, true);
    }
    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW$7);
    }
    // Private
    _configAfterMerge(config) {
      config.toggle = Boolean(config.toggle);
      config.parent = getElement(config.parent);
      return config;
    }
    _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
      for (const element of children) {
        const selected = getElementFromSelector(element);
        if (selected) {
          this._addAriaAndCollapsedClass([element], this._isShown(selected));
        }
      }
    }
    _getFirstLevelChildren(selector) {
      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
      return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }
      for (const element of triggerArray) {
        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
        element.setAttribute("aria-expanded", isOpen);
      }
    }
    // Static
    static jQueryInterface(config) {
      const _config = {};
      if (typeof config === "string" && /show|hide/.test(config)) {
        _config.toggle = false;
      }
      return this.each(function() {
        const data = Collapse.getOrCreateInstance(this, _config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
    if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
      event.preventDefault();
    }
    const selector = getSelectorFromElement(this);
    const selectorElements = SelectorEngine.find(selector);
    for (const element of selectorElements) {
      Collapse.getOrCreateInstance(element, {
        toggle: false
      }).toggle();
    }
  });
  defineJQueryPlugin(Collapse);
  var NAME$a = "dropdown";
  var DATA_KEY$6 = "bs.dropdown";
  var EVENT_KEY$6 = `.${DATA_KEY$6}`;
  var DATA_API_KEY$3 = ".data-api";
  var ESCAPE_KEY$2 = "Escape";
  var TAB_KEY$1 = "Tab";
  var ARROW_UP_KEY$1 = "ArrowUp";
  var ARROW_DOWN_KEY$1 = "ArrowDown";
  var RIGHT_MOUSE_BUTTON = 2;
  var EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
  var EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
  var EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
  var EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
  var EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var CLASS_NAME_SHOW$6 = "show";
  var CLASS_NAME_DROPUP = "dropup";
  var CLASS_NAME_DROPEND = "dropend";
  var CLASS_NAME_DROPSTART = "dropstart";
  var CLASS_NAME_DROPUP_CENTER = "dropup-center";
  var CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
  var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
  var SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
  var SELECTOR_MENU = ".dropdown-menu";
  var SELECTOR_NAVBAR = ".navbar";
  var SELECTOR_NAVBAR_NAV = ".navbar-nav";
  var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
  var PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
  var PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
  var PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
  var PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
  var PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
  var PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
  var PLACEMENT_TOPCENTER = "top";
  var PLACEMENT_BOTTOMCENTER = "bottom";
  var Default$9 = {
    autoClose: true,
    boundary: "clippingParents",
    display: "dynamic",
    offset: [0, 2],
    popperConfig: null,
    reference: "toggle"
  };
  var DefaultType$9 = {
    autoClose: "(boolean|string)",
    boundary: "(string|element)",
    display: "string",
    offset: "(array|string|function)",
    popperConfig: "(null|object|function)",
    reference: "(string|element|object)"
  };
  var Dropdown = class extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._popper = null;
      this._parent = this._element.parentNode;
      this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
      this._inNavbar = this._detectNavbar();
    }
    // Getters
    static get Default() {
      return Default$9;
    }
    static get DefaultType() {
      return DefaultType$9;
    }
    static get NAME() {
      return NAME$a;
    }
    // Public
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (isDisabled(this._element) || this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._createPopper();
      if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, "mouseover", noop);
        }
      }
      this._element.focus();
      this._element.setAttribute("aria-expanded", true);
      this._menu.classList.add(CLASS_NAME_SHOW$6);
      this._element.classList.add(CLASS_NAME_SHOW$6);
      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
    }
    hide() {
      if (isDisabled(this._element) || !this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      this._completeHide(relatedTarget);
    }
    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }
    // Private
    _completeHide(relatedTarget) {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
      if (hideEvent.defaultPrevented) {
        return;
      }
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, "mouseover", noop);
        }
      }
      if (this._popper) {
        this._popper.destroy();
      }
      this._menu.classList.remove(CLASS_NAME_SHOW$6);
      this._element.classList.remove(CLASS_NAME_SHOW$6);
      this._element.setAttribute("aria-expanded", "false");
      Manipulator.removeDataAttribute(this._menu, "popper");
      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
    }
    _getConfig(config) {
      config = super._getConfig(config);
      if (typeof config.reference === "object" && !isElement2(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
        throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      }
      return config;
    }
    _createPopper() {
      if (typeof lib_exports === "undefined") {
        throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
      }
      let referenceElement = this._element;
      if (this._config.reference === "parent") {
        referenceElement = this._parent;
      } else if (isElement2(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (typeof this._config.reference === "object") {
        referenceElement = this._config.reference;
      }
      const popperConfig = this._getPopperConfig();
      this._popper = createPopper3(referenceElement, this._menu, popperConfig);
    }
    _isShown() {
      return this._menu.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getPlacement() {
      const parentDropdown = this._parent;
      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
        return PLACEMENT_TOPCENTER;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
        return PLACEMENT_BOTTOMCENTER;
      }
      const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }
      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
      return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
    _getOffset() {
      const {
        offset: offset2
      } = this._config;
      if (typeof offset2 === "string") {
        return offset2.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset2 === "function") {
        return (popperData) => offset2(popperData, this._element);
      }
      return offset2;
    }
    _getPopperConfig() {
      const defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      if (this._inNavbar || this._config.display === "static") {
        Manipulator.setDataAttribute(this._menu, "popper", "static");
        defaultBsPopperConfig.modifiers = [{
          name: "applyStyles",
          enabled: false
        }];
      }
      return {
        ...defaultBsPopperConfig,
        ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
      };
    }
    _selectMenuItem({
      key,
      target
    }) {
      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
      if (!items.length) {
        return;
      }
      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Dropdown.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
    static clearMenus(event) {
      if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
        return;
      }
      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
      for (const toggle of openToggles) {
        const context = Dropdown.getInstance(toggle);
        if (!context || context._config.autoClose === false) {
          continue;
        }
        const composedPath = event.composedPath();
        const isMenuTarget = composedPath.includes(context._menu);
        if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
          continue;
        }
        if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
          continue;
        }
        const relatedTarget = {
          relatedTarget: context._element
        };
        if (event.type === "click") {
          relatedTarget.clickEvent = event;
        }
        context._completeHide(relatedTarget);
      }
    }
    static dataApiKeydownHandler(event) {
      const isInput = /input|textarea/i.test(event.target.tagName);
      const isEscapeEvent = event.key === ESCAPE_KEY$2;
      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
      if (!isUpOrDownEvent && !isEscapeEvent) {
        return;
      }
      if (isInput && !isEscapeEvent) {
        return;
      }
      event.preventDefault();
      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
      const instance = Dropdown.getOrCreateInstance(getToggleButton);
      if (isUpOrDownEvent) {
        event.stopPropagation();
        instance.show();
        instance._selectMenuItem(event);
        return;
      }
      if (instance._isShown()) {
        event.stopPropagation();
        instance.hide();
        getToggleButton.focus();
      }
    }
  };
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });
  defineJQueryPlugin(Dropdown);
  var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
  var SELECTOR_STICKY_CONTENT = ".sticky-top";
  var PROPERTY_PADDING = "padding-right";
  var PROPERTY_MARGIN = "margin-right";
  var ScrollBarHelper = class {
    constructor() {
      this._element = document.body;
    }
    // Public
    getWidth() {
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
      const width = this.getWidth();
      this._disableOverFlow();
      this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow");
      this._resetElementAttributes(this._element, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
    // Private
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow");
      this._element.style.overflow = "hidden";
    }
    _setElementAttributes(selector, styleProperty, callback) {
      const scrollbarWidth = this.getWidth();
      const manipulationCallBack = (element) => {
        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }
        this._saveInitialAttribute(element, styleProperty);
        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _saveInitialAttribute(element, styleProperty) {
      const actualValue = element.style.getPropertyValue(styleProperty);
      if (actualValue) {
        Manipulator.setDataAttribute(element, styleProperty, actualValue);
      }
    }
    _resetElementAttributes(selector, styleProperty) {
      const manipulationCallBack = (element) => {
        const value = Manipulator.getDataAttribute(element, styleProperty);
        if (value === null) {
          element.style.removeProperty(styleProperty);
          return;
        }
        Manipulator.removeDataAttribute(element, styleProperty);
        element.style.setProperty(styleProperty, value);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
      if (isElement2(selector)) {
        callBack(selector);
        return;
      }
      for (const sel of SelectorEngine.find(selector, this._element)) {
        callBack(sel);
      }
    }
  };
  var NAME$9 = "backdrop";
  var CLASS_NAME_FADE$4 = "fade";
  var CLASS_NAME_SHOW$5 = "show";
  var EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
  var Default$8 = {
    className: "modal-backdrop",
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: "body"
    // give the choice to place backdrop under different elements
  };
  var DefaultType$8 = {
    className: "string",
    clickCallback: "(function|null)",
    isAnimated: "boolean",
    isVisible: "boolean",
    rootElement: "(element|string)"
  };
  var Backdrop = class extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }
    // Getters
    static get Default() {
      return Default$8;
    }
    static get DefaultType() {
      return DefaultType$8;
    }
    static get NAME() {
      return NAME$9;
    }
    // Public
    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._append();
      const element = this._getElement();
      if (this._config.isAnimated) {
        reflow(element);
      }
      element.classList.add(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        execute(callback);
      });
    }
    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._getElement().classList.remove(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    }
    dispose() {
      if (!this._isAppended) {
        return;
      }
      EventHandler.off(this._element, EVENT_MOUSEDOWN);
      this._element.remove();
      this._isAppended = false;
    }
    // Private
    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement("div");
        backdrop.className = this._config.className;
        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE$4);
        }
        this._element = backdrop;
      }
      return this._element;
    }
    _configAfterMerge(config) {
      config.rootElement = getElement(config.rootElement);
      return config;
    }
    _append() {
      if (this._isAppended) {
        return;
      }
      const element = this._getElement();
      this._config.rootElement.append(element);
      EventHandler.on(element, EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }
    _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
  };
  var NAME$8 = "focustrap";
  var DATA_KEY$5 = "bs.focustrap";
  var EVENT_KEY$5 = `.${DATA_KEY$5}`;
  var EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
  var EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
  var TAB_KEY = "Tab";
  var TAB_NAV_FORWARD = "forward";
  var TAB_NAV_BACKWARD = "backward";
  var Default$7 = {
    autofocus: true,
    trapElement: null
    // The element to trap focus inside of
  };
  var DefaultType$7 = {
    autofocus: "boolean",
    trapElement: "element"
  };
  var FocusTrap = class extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }
    // Getters
    static get Default() {
      return Default$7;
    }
    static get DefaultType() {
      return DefaultType$7;
    }
    static get NAME() {
      return NAME$8;
    }
    // Public
    activate() {
      if (this._isActive) {
        return;
      }
      if (this._config.autofocus) {
        this._config.trapElement.focus();
      }
      EventHandler.off(document, EVENT_KEY$5);
      EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
      EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
      this._isActive = true;
    }
    deactivate() {
      if (!this._isActive) {
        return;
      }
      this._isActive = false;
      EventHandler.off(document, EVENT_KEY$5);
    }
    // Private
    _handleFocusin(event) {
      const {
        trapElement
      } = this._config;
      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
        return;
      }
      const elements = SelectorEngine.focusableChildren(trapElement);
      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
    _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }
      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
  };
  var NAME$7 = "modal";
  var DATA_KEY$4 = "bs.modal";
  var EVENT_KEY$4 = `.${DATA_KEY$4}`;
  var DATA_API_KEY$2 = ".data-api";
  var ESCAPE_KEY$1 = "Escape";
  var EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
  var EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
  var EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
  var EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
  var EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
  var EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
  var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
  var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
  var EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
  var EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
  var CLASS_NAME_OPEN = "modal-open";
  var CLASS_NAME_FADE$3 = "fade";
  var CLASS_NAME_SHOW$4 = "show";
  var CLASS_NAME_STATIC = "modal-static";
  var OPEN_SELECTOR$1 = ".modal.show";
  var SELECTOR_DIALOG = ".modal-dialog";
  var SELECTOR_MODAL_BODY = ".modal-body";
  var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
  var Default$6 = {
    backdrop: true,
    focus: true,
    keyboard: true
  };
  var DefaultType$6 = {
    backdrop: "(boolean|string)",
    focus: "boolean",
    keyboard: "boolean"
  };
  var Modal = class extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._isTransitioning = false;
      this._scrollBar = new ScrollBarHelper();
      this._addEventListeners();
    }
    // Getters
    static get Default() {
      return Default$6;
    }
    static get DefaultType() {
      return DefaultType$6;
    }
    static get NAME() {
      return NAME$7;
    }
    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown || this._isTransitioning) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._isTransitioning = true;
      this._scrollBar.hide();
      document.body.classList.add(CLASS_NAME_OPEN);
      this._adjustDialog();
      this._backdrop.show(() => this._showElement(relatedTarget));
    }
    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._isShown = false;
      this._isTransitioning = true;
      this._focustrap.deactivate();
      this._element.classList.remove(CLASS_NAME_SHOW$4);
      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
    }
    dispose() {
      for (const htmlElement of [window, this._dialog]) {
        EventHandler.off(htmlElement, EVENT_KEY$4);
      }
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    // Private
    _initializeBackDrop() {
      return new Backdrop({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value,
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _showElement(relatedTarget) {
      if (!document.body.contains(this._element)) {
        document.body.append(this._element);
      }
      this._element.style.display = "block";
      this._element.removeAttribute("aria-hidden");
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.scrollTop = 0;
      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
      if (modalBody) {
        modalBody.scrollTop = 0;
      }
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW$4);
      const transitionComplete = () => {
        if (this._config.focus) {
          this._focustrap.activate();
        }
        this._isTransitioning = false;
        EventHandler.trigger(this._element, EVENT_SHOWN$4, {
          relatedTarget
        });
      };
      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
        if (event.key !== ESCAPE_KEY$1) {
          return;
        }
        if (this._config.keyboard) {
          event.preventDefault();
          this.hide();
          return;
        }
        this._triggerBackdropTransition();
      });
      EventHandler.on(window, EVENT_RESIZE$1, () => {
        if (this._isShown && !this._isTransitioning) {
          this._adjustDialog();
        }
      });
      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
        EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
          if (this._element !== event.target || this._element !== event2.target) {
            return;
          }
          if (this._config.backdrop === "static") {
            this._triggerBackdropTransition();
            return;
          }
          if (this._config.backdrop) {
            this.hide();
          }
        });
      });
    }
    _hideModal() {
      this._element.style.display = "none";
      this._element.setAttribute("aria-hidden", true);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      this._isTransitioning = false;
      this._backdrop.hide(() => {
        document.body.classList.remove(CLASS_NAME_OPEN);
        this._resetAdjustments();
        this._scrollBar.reset();
        EventHandler.trigger(this._element, EVENT_HIDDEN$4);
      });
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const initialOverflowY = this._element.style.overflowY;
      if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
        return;
      }
      if (!isModalOverflowing) {
        this._element.style.overflowY = "hidden";
      }
      this._element.classList.add(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.classList.remove(CLASS_NAME_STATIC);
        this._queueCallback(() => {
          this._element.style.overflowY = initialOverflowY;
        }, this._dialog);
      }, this._dialog);
      this._element.focus();
    }
    /**
     * The following methods are used to handle overflowing modals
     */
    _adjustDialog() {
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const scrollbarWidth = this._scrollBar.getWidth();
      const isBodyOverflowing = scrollbarWidth > 0;
      if (isBodyOverflowing && !isModalOverflowing) {
        const property = isRTL() ? "paddingLeft" : "paddingRight";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
      if (!isBodyOverflowing && isModalOverflowing) {
        const property = isRTL() ? "paddingRight" : "paddingLeft";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "";
      this._element.style.paddingRight = "";
    }
    // Static
    static jQueryInterface(config, relatedTarget) {
      return this.each(function() {
        const data = Modal.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](relatedTarget);
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
    const target = getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
      if (showEvent.defaultPrevented) {
        return;
      }
      EventHandler.one(target, EVENT_HIDDEN$4, () => {
        if (isVisible(this)) {
          this.focus();
        }
      });
    });
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    if (alreadyOpen) {
      Modal.getInstance(alreadyOpen).hide();
    }
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);
  defineJQueryPlugin(Modal);
  var NAME$6 = "offcanvas";
  var DATA_KEY$3 = "bs.offcanvas";
  var EVENT_KEY$3 = `.${DATA_KEY$3}`;
  var DATA_API_KEY$1 = ".data-api";
  var EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
  var ESCAPE_KEY = "Escape";
  var CLASS_NAME_SHOW$3 = "show";
  var CLASS_NAME_SHOWING$1 = "showing";
  var CLASS_NAME_HIDING = "hiding";
  var CLASS_NAME_BACKDROP = "offcanvas-backdrop";
  var OPEN_SELECTOR = ".offcanvas.show";
  var EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
  var EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
  var EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
  var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
  var EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
  var EVENT_RESIZE = `resize${EVENT_KEY$3}`;
  var EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
  var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
  var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
  var Default$5 = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  var DefaultType$5 = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    scroll: "boolean"
  };
  var Offcanvas = class extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._isShown = false;
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._addEventListeners();
    }
    // Getters
    static get Default() {
      return Default$5;
    }
    static get DefaultType() {
      return DefaultType$5;
    }
    static get NAME() {
      return NAME$6;
    }
    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._backdrop.show();
      if (!this._config.scroll) {
        new ScrollBarHelper().hide();
      }
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.classList.add(CLASS_NAME_SHOWING$1);
      const completeCallBack = () => {
        if (!this._config.scroll || this._config.backdrop) {
          this._focustrap.activate();
        }
        this._element.classList.add(CLASS_NAME_SHOW$3);
        this._element.classList.remove(CLASS_NAME_SHOWING$1);
        EventHandler.trigger(this._element, EVENT_SHOWN$3, {
          relatedTarget
        });
      };
      this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
      if (!this._isShown) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._focustrap.deactivate();
      this._element.blur();
      this._isShown = false;
      this._element.classList.add(CLASS_NAME_HIDING);
      this._backdrop.hide();
      const completeCallback = () => {
        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
        this._element.removeAttribute("aria-modal");
        this._element.removeAttribute("role");
        if (!this._config.scroll) {
          new ScrollBarHelper().reset();
        }
        EventHandler.trigger(this._element, EVENT_HIDDEN$3);
      };
      this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    // Private
    _initializeBackDrop() {
      const clickCallback = () => {
        if (this._config.backdrop === "static") {
          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
          return;
        }
        this.hide();
      };
      const isVisible2 = Boolean(this._config.backdrop);
      return new Backdrop({
        className: CLASS_NAME_BACKDROP,
        isVisible: isVisible2,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: isVisible2 ? clickCallback : null
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
        if (event.key !== ESCAPE_KEY) {
          return;
        }
        if (!this._config.keyboard) {
          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
          return;
        }
        this.hide();
      });
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Offcanvas.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
    const target = getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$3, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    if (alreadyOpen && alreadyOpen !== target) {
      Offcanvas.getInstance(alreadyOpen).hide();
    }
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
      Offcanvas.getOrCreateInstance(selector).show();
    }
  });
  EventHandler.on(window, EVENT_RESIZE, () => {
    for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
      if (getComputedStyle(element).position !== "fixed") {
        Offcanvas.getOrCreateInstance(element).hide();
      }
    }
  });
  enableDismissTrigger(Offcanvas);
  defineJQueryPlugin(Offcanvas);
  var uriAttributes = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
  var allowedAttribute = (attribute, allowedAttributeList) => {
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
      if (uriAttributes.has(attributeName)) {
        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
      }
      return true;
    }
    return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
  };
  var DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
    if (!unsafeHtml.length) {
      return unsafeHtml;
    }
    if (sanitizeFunction && typeof sanitizeFunction === "function") {
      return sanitizeFunction(unsafeHtml);
    }
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
    const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
    for (const element of elements) {
      const elementName = element.nodeName.toLowerCase();
      if (!Object.keys(allowList).includes(elementName)) {
        element.remove();
        continue;
      }
      const attributeList = [].concat(...element.attributes);
      const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
      for (const attribute of attributeList) {
        if (!allowedAttribute(attribute, allowedAttributes)) {
          element.removeAttribute(attribute.nodeName);
        }
      }
    }
    return createdDocument.body.innerHTML;
  }
  var NAME$5 = "TemplateFactory";
  var Default$4 = {
    allowList: DefaultAllowlist,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: "",
    html: false,
    sanitize: true,
    sanitizeFn: null,
    template: "<div></div>"
  };
  var DefaultType$4 = {
    allowList: "object",
    content: "object",
    extraClass: "(string|function)",
    html: "boolean",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    template: "string"
  };
  var DefaultContentType = {
    entry: "(string|element|function|null)",
    selector: "(string|element)"
  };
  var TemplateFactory = class extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
    }
    // Getters
    static get Default() {
      return Default$4;
    }
    static get DefaultType() {
      return DefaultType$4;
    }
    static get NAME() {
      return NAME$5;
    }
    // Public
    getContent() {
      return Object.values(this._config.content).map((config) => this._resolvePossibleFunction(config)).filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(content) {
      this._checkContent(content);
      this._config.content = {
        ...this._config.content,
        ...content
      };
      return this;
    }
    toHtml() {
      const templateWrapper = document.createElement("div");
      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
      for (const [selector, text] of Object.entries(this._config.content)) {
        this._setContent(templateWrapper, text, selector);
      }
      const template = templateWrapper.children[0];
      const extraClass = this._resolvePossibleFunction(this._config.extraClass);
      if (extraClass) {
        template.classList.add(...extraClass.split(" "));
      }
      return template;
    }
    // Private
    _typeCheckConfig(config) {
      super._typeCheckConfig(config);
      this._checkContent(config.content);
    }
    _checkContent(arg) {
      for (const [selector, content] of Object.entries(arg)) {
        super._typeCheckConfig({
          selector,
          entry: content
        }, DefaultContentType);
      }
    }
    _setContent(template, content, selector) {
      const templateElement = SelectorEngine.findOne(selector, template);
      if (!templateElement) {
        return;
      }
      content = this._resolvePossibleFunction(content);
      if (!content) {
        templateElement.remove();
        return;
      }
      if (isElement2(content)) {
        this._putElementInTemplate(getElement(content), templateElement);
        return;
      }
      if (this._config.html) {
        templateElement.innerHTML = this._maybeSanitize(content);
        return;
      }
      templateElement.textContent = content;
    }
    _maybeSanitize(arg) {
      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
    }
    _resolvePossibleFunction(arg) {
      return typeof arg === "function" ? arg(this) : arg;
    }
    _putElementInTemplate(element, templateElement) {
      if (this._config.html) {
        templateElement.innerHTML = "";
        templateElement.append(element);
        return;
      }
      templateElement.textContent = element.textContent;
    }
  };
  var NAME$4 = "tooltip";
  var DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
  var CLASS_NAME_FADE$2 = "fade";
  var CLASS_NAME_MODAL = "modal";
  var CLASS_NAME_SHOW$2 = "show";
  var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
  var SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
  var EVENT_MODAL_HIDE = "hide.bs.modal";
  var TRIGGER_HOVER = "hover";
  var TRIGGER_FOCUS = "focus";
  var TRIGGER_CLICK = "click";
  var TRIGGER_MANUAL = "manual";
  var EVENT_HIDE$2 = "hide";
  var EVENT_HIDDEN$2 = "hidden";
  var EVENT_SHOW$2 = "show";
  var EVENT_SHOWN$2 = "shown";
  var EVENT_INSERTED = "inserted";
  var EVENT_CLICK$1 = "click";
  var EVENT_FOCUSIN$1 = "focusin";
  var EVENT_FOCUSOUT$1 = "focusout";
  var EVENT_MOUSEENTER = "mouseenter";
  var EVENT_MOUSELEAVE = "mouseleave";
  var AttachmentMap = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: isRTL() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: isRTL() ? "right" : "left"
  };
  var Default$3 = {
    allowList: DefaultAllowlist,
    animation: true,
    boundary: "clippingParents",
    container: false,
    customClass: "",
    delay: 0,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    html: false,
    offset: [0, 0],
    placement: "top",
    popperConfig: null,
    sanitize: true,
    sanitizeFn: null,
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    title: "",
    trigger: "hover focus"
  };
  var DefaultType$3 = {
    allowList: "object",
    animation: "boolean",
    boundary: "(string|element)",
    container: "(string|element|boolean)",
    customClass: "(string|function)",
    delay: "(number|object)",
    fallbackPlacements: "array",
    html: "boolean",
    offset: "(array|string|function)",
    placement: "(string|function)",
    popperConfig: "(null|object|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    selector: "(string|boolean)",
    template: "string",
    title: "(string|element|function)",
    trigger: "string"
  };
  var Tooltip = class extends BaseComponent {
    constructor(element, config) {
      if (typeof lib_exports === "undefined") {
        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      }
      super(element, config);
      this._isEnabled = true;
      this._timeout = 0;
      this._isHovered = null;
      this._activeTrigger = {};
      this._popper = null;
      this._templateFactory = null;
      this._newContent = null;
      this.tip = null;
      this._setListeners();
      if (!this._config.selector) {
        this._fixTitle();
      }
    }
    // Getters
    static get Default() {
      return Default$3;
    }
    static get DefaultType() {
      return DefaultType$3;
    }
    static get NAME() {
      return NAME$4;
    }
    // Public
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      if (!this._isEnabled) {
        return;
      }
      this._activeTrigger.click = !this._activeTrigger.click;
      if (this._isShown()) {
        this._leave();
        return;
      }
      this._enter();
    }
    dispose() {
      clearTimeout(this._timeout);
      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
      if (this._element.getAttribute("data-bs-original-title")) {
        this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
      }
      this._disposePopper();
      super.dispose();
    }
    show() {
      if (this._element.style.display === "none") {
        throw new Error("Please use show on visible elements");
      }
      if (!(this._isWithContent() && this._isEnabled)) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
      const shadowRoot = findShadowRoot(this._element);
      const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
      if (showEvent.defaultPrevented || !isInTheDom) {
        return;
      }
      this._disposePopper();
      const tip = this._getTipElement();
      this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
      const {
        container
      } = this._config;
      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        container.append(tip);
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
      }
      this._popper = this._createPopper(tip);
      tip.classList.add(CLASS_NAME_SHOW$2);
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, "mouseover", noop);
        }
      }
      const complete = () => {
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
        if (this._isHovered === false) {
          this._leave();
        }
        this._isHovered = false;
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    hide() {
      if (!this._isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
      if (hideEvent.defaultPrevented) {
        return;
      }
      const tip = this._getTipElement();
      tip.classList.remove(CLASS_NAME_SHOW$2);
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, "mouseover", noop);
        }
      }
      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;
      this._isHovered = null;
      const complete = () => {
        if (this._isWithActiveTrigger()) {
          return;
        }
        if (!this._isHovered) {
          this._disposePopper();
        }
        this._element.removeAttribute("aria-describedby");
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    update() {
      if (this._popper) {
        this._popper.update();
      }
    }
    // Protected
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      if (!this.tip) {
        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
      }
      return this.tip;
    }
    _createTipElement(content) {
      const tip = this._getTemplateFactory(content).toHtml();
      if (!tip) {
        return null;
      }
      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
      tip.classList.add(`bs-${this.constructor.NAME}-auto`);
      const tipId = getUID(this.constructor.NAME).toString();
      tip.setAttribute("id", tipId);
      if (this._isAnimated()) {
        tip.classList.add(CLASS_NAME_FADE$2);
      }
      return tip;
    }
    setContent(content) {
      this._newContent = content;
      if (this._isShown()) {
        this._disposePopper();
        this.show();
      }
    }
    _getTemplateFactory(content) {
      if (this._templateFactory) {
        this._templateFactory.changeContent(content);
      } else {
        this._templateFactory = new TemplateFactory({
          ...this._config,
          // the `content` var has to be after `this._config`
          // to override config.content in case of popover
          content,
          extraClass: this._resolvePossibleFunction(this._config.customClass)
        });
      }
      return this._templateFactory;
    }
    _getContentForTemplate() {
      return {
        [SELECTOR_TOOLTIP_INNER]: this._getTitle()
      };
    }
    _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
    }
    // Private
    _initializeOnDelegatedTarget(event) {
      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
    }
    _createPopper(tip) {
      const placement = typeof this._config.placement === "function" ? this._config.placement.call(this, tip, this._element) : this._config.placement;
      const attachment = AttachmentMap[placement.toUpperCase()];
      return createPopper3(this._element, tip, this._getPopperConfig(attachment));
    }
    _getOffset() {
      const {
        offset: offset2
      } = this._config;
      if (typeof offset2 === "string") {
        return offset2.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset2 === "function") {
        return (popperData) => offset2(popperData, this._element);
      }
      return offset2;
    }
    _resolvePossibleFunction(arg) {
      return typeof arg === "function" ? arg.call(this._element) : arg;
    }
    _getPopperConfig(attachment) {
      const defaultBsPopperConfig = {
        placement: attachment,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "preSetPlacement",
          enabled: true,
          phase: "beforeMain",
          fn: (data) => {
            this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
          }
        }]
      };
      return {
        ...defaultBsPopperConfig,
        ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
      };
    }
    _setListeners() {
      const triggers = this._config.trigger.split(" ");
      for (const trigger of triggers) {
        if (trigger === "click") {
          EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context.toggle();
          });
        } else if (trigger !== TRIGGER_MANUAL) {
          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
          EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
            context._enter();
          });
          EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
            context._leave();
          });
        }
      }
      this._hideModalHandler = () => {
        if (this._element) {
          this.hide();
        }
      };
      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    }
    _fixTitle() {
      const title = this._element.getAttribute("title");
      if (!title) {
        return;
      }
      if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
        this._element.setAttribute("aria-label", title);
      }
      this._element.setAttribute("data-bs-original-title", title);
      this._element.removeAttribute("title");
    }
    _enter() {
      if (this._isShown() || this._isHovered) {
        this._isHovered = true;
        return;
      }
      this._isHovered = true;
      this._setTimeout(() => {
        if (this._isHovered) {
          this.show();
        }
      }, this._config.delay.show);
    }
    _leave() {
      if (this._isWithActiveTrigger()) {
        return;
      }
      this._isHovered = false;
      this._setTimeout(() => {
        if (!this._isHovered) {
          this.hide();
        }
      }, this._config.delay.hide);
    }
    _setTimeout(handler, timeout) {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(handler, timeout);
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(true);
    }
    _getConfig(config) {
      const dataAttributes = Manipulator.getDataAttributes(this._element);
      for (const dataAttribute of Object.keys(dataAttributes)) {
        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
          delete dataAttributes[dataAttribute];
        }
      }
      config = {
        ...dataAttributes,
        ...typeof config === "object" && config ? config : {}
      };
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      config.container = config.container === false ? document.body : getElement(config.container);
      if (typeof config.delay === "number") {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }
      if (typeof config.title === "number") {
        config.title = config.title.toString();
      }
      if (typeof config.content === "number") {
        config.content = config.content.toString();
      }
      return config;
    }
    _getDelegateConfig() {
      const config = {};
      for (const key in this._config) {
        if (this.constructor.Default[key] !== this._config[key]) {
          config[key] = this._config[key];
        }
      }
      config.selector = false;
      config.trigger = "manual";
      return config;
    }
    _disposePopper() {
      if (this._popper) {
        this._popper.destroy();
        this._popper = null;
      }
      if (this.tip) {
        this.tip.remove();
        this.tip = null;
      }
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Tooltip.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  };
  defineJQueryPlugin(Tooltip);
  var NAME$3 = "popover";
  var SELECTOR_TITLE = ".popover-header";
  var SELECTOR_CONTENT = ".popover-body";
  var Default$2 = {
    ...Tooltip.Default,
    content: "",
    offset: [0, 8],
    placement: "right",
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    trigger: "click"
  };
  var DefaultType$2 = {
    ...Tooltip.DefaultType,
    content: "(null|string|element|function)"
  };
  var Popover = class extends Tooltip {
    // Getters
    static get Default() {
      return Default$2;
    }
    static get DefaultType() {
      return DefaultType$2;
    }
    static get NAME() {
      return NAME$3;
    }
    // Overrides
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }
    // Private
    _getContentForTemplate() {
      return {
        [SELECTOR_TITLE]: this._getTitle(),
        [SELECTOR_CONTENT]: this._getContent()
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Popover.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  };
  defineJQueryPlugin(Popover);
  var NAME$2 = "scrollspy";
  var DATA_KEY$2 = "bs.scrollspy";
  var EVENT_KEY$2 = `.${DATA_KEY$2}`;
  var DATA_API_KEY = ".data-api";
  var EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
  var EVENT_CLICK = `click${EVENT_KEY$2}`;
  var EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
  var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
  var CLASS_NAME_ACTIVE$1 = "active";
  var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  var SELECTOR_TARGET_LINKS = "[href]";
  var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
  var SELECTOR_NAV_LINKS = ".nav-link";
  var SELECTOR_NAV_ITEMS = ".nav-item";
  var SELECTOR_LIST_ITEMS = ".list-group-item";
  var SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
  var SELECTOR_DROPDOWN = ".dropdown";
  var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
  var Default$1 = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "0px 0px -25%",
    smoothScroll: false,
    target: null,
    threshold: [0.1, 0.5, 1]
  };
  var DefaultType$1 = {
    offset: "(number|null)",
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "string",
    smoothScroll: "boolean",
    target: "element",
    threshold: "array"
  };
  var ScrollSpy = class extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._targetLinks = /* @__PURE__ */ new Map();
      this._observableSections = /* @__PURE__ */ new Map();
      this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
      this._activeTarget = null;
      this._observer = null;
      this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      };
      this.refresh();
    }
    // Getters
    static get Default() {
      return Default$1;
    }
    static get DefaultType() {
      return DefaultType$1;
    }
    static get NAME() {
      return NAME$2;
    }
    // Public
    refresh() {
      this._initializeTargetsAndObservables();
      this._maybeEnableSmoothScroll();
      if (this._observer) {
        this._observer.disconnect();
      } else {
        this._observer = this._getNewObserver();
      }
      for (const section of this._observableSections.values()) {
        this._observer.observe(section);
      }
    }
    dispose() {
      this._observer.disconnect();
      super.dispose();
    }
    // Private
    _configAfterMerge(config) {
      config.target = getElement(config.target) || document.body;
      config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
      if (typeof config.threshold === "string") {
        config.threshold = config.threshold.split(",").map((value) => Number.parseFloat(value));
      }
      return config;
    }
    _maybeEnableSmoothScroll() {
      if (!this._config.smoothScroll) {
        return;
      }
      EventHandler.off(this._config.target, EVENT_CLICK);
      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
        const observableSection = this._observableSections.get(event.target.hash);
        if (observableSection) {
          event.preventDefault();
          const root = this._rootElement || window;
          const height = observableSection.offsetTop - this._element.offsetTop;
          if (root.scrollTo) {
            root.scrollTo({
              top: height,
              behavior: "smooth"
            });
            return;
          }
          root.scrollTop = height;
        }
      });
    }
    _getNewObserver() {
      const options = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin
      };
      return new IntersectionObserver((entries) => this._observerCallback(entries), options);
    }
    // The logic of selection
    _observerCallback(entries) {
      const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
      const activate = (entry) => {
        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
        this._process(targetElement(entry));
      };
      const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
      const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = parentScrollTop;
      for (const entry of entries) {
        if (!entry.isIntersecting) {
          this._activeTarget = null;
          this._clearActiveClass(targetElement(entry));
          continue;
        }
        const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        if (userScrollsDown && entryIsLowerThanPrevious) {
          activate(entry);
          if (!parentScrollTop) {
            return;
          }
          continue;
        }
        if (!userScrollsDown && !entryIsLowerThanPrevious) {
          activate(entry);
        }
      }
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = /* @__PURE__ */ new Map();
      this._observableSections = /* @__PURE__ */ new Map();
      const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
      for (const anchor of targetLinks) {
        if (!anchor.hash || isDisabled(anchor)) {
          continue;
        }
        const observableSection = SelectorEngine.findOne(anchor.hash, this._element);
        if (isVisible(observableSection)) {
          this._targetLinks.set(anchor.hash, anchor);
          this._observableSections.set(anchor.hash, observableSection);
        }
      }
    }
    _process(target) {
      if (this._activeTarget === target) {
        return;
      }
      this._clearActiveClass(this._config.target);
      this._activeTarget = target;
      target.classList.add(CLASS_NAME_ACTIVE$1);
      this._activateParents(target);
      EventHandler.trigger(this._element, EVENT_ACTIVATE, {
        relatedTarget: target
      });
    }
    _activateParents(target) {
      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
        return;
      }
      for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
          item.classList.add(CLASS_NAME_ACTIVE$1);
        }
      }
    }
    _clearActiveClass(parent) {
      parent.classList.remove(CLASS_NAME_ACTIVE$1);
      const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
      for (const node of activeNodes) {
        node.classList.remove(CLASS_NAME_ACTIVE$1);
      }
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = ScrollSpy.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  };
  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
      ScrollSpy.getOrCreateInstance(spy);
    }
  });
  defineJQueryPlugin(ScrollSpy);
  var NAME$1 = "tab";
  var DATA_KEY$1 = "bs.tab";
  var EVENT_KEY$1 = `.${DATA_KEY$1}`;
  var EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
  var EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
  var EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
  var EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
  var EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
  var EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
  var EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
  var ARROW_LEFT_KEY = "ArrowLeft";
  var ARROW_RIGHT_KEY = "ArrowRight";
  var ARROW_UP_KEY = "ArrowUp";
  var ARROW_DOWN_KEY = "ArrowDown";
  var CLASS_NAME_ACTIVE = "active";
  var CLASS_NAME_FADE$1 = "fade";
  var CLASS_NAME_SHOW$1 = "show";
  var CLASS_DROPDOWN = "dropdown";
  var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
  var SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
  var NOT_SELECTOR_DROPDOWN_TOGGLE = ":not(.dropdown-toggle)";
  var SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
  var SELECTOR_OUTER = ".nav-item, .list-group-item";
  var SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
  var SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
  var SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
  var Tab = class extends BaseComponent {
    constructor(element) {
      super(element);
      this._parent = this._element.closest(SELECTOR_TAB_PANEL);
      if (!this._parent) {
        return;
      }
      this._setInitialAttributes(this._parent, this._getChildren());
      EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
    }
    // Getters
    static get NAME() {
      return NAME$1;
    }
    // Public
    show() {
      const innerElem = this._element;
      if (this._elemIsActive(innerElem)) {
        return;
      }
      const active = this._getActiveElem();
      const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
        relatedTarget: innerElem
      }) : null;
      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
        relatedTarget: active
      });
      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
        return;
      }
      this._deactivate(active, innerElem);
      this._activate(innerElem, active);
    }
    // Private
    _activate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.add(CLASS_NAME_ACTIVE);
      this._activate(getElementFromSelector(element));
      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.add(CLASS_NAME_SHOW$1);
          return;
        }
        element.removeAttribute("tabindex");
        element.setAttribute("aria-selected", true);
        this._toggleDropDown(element, true);
        EventHandler.trigger(element, EVENT_SHOWN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _deactivate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.remove(CLASS_NAME_ACTIVE);
      element.blur();
      this._deactivate(getElementFromSelector(element));
      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.remove(CLASS_NAME_SHOW$1);
          return;
        }
        element.setAttribute("aria-selected", false);
        element.setAttribute("tabindex", "-1");
        this._toggleDropDown(element, false);
        EventHandler.trigger(element, EVENT_HIDDEN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _keydown(event) {
      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
      const nextActiveElement = getNextActiveElement(this._getChildren().filter((element) => !isDisabled(element)), event.target, isNext, true);
      if (nextActiveElement) {
        nextActiveElement.focus({
          preventScroll: true
        });
        Tab.getOrCreateInstance(nextActiveElement).show();
      }
    }
    _getChildren() {
      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find((child) => this._elemIsActive(child)) || null;
    }
    _setInitialAttributes(parent, children) {
      this._setAttributeIfNotExists(parent, "role", "tablist");
      for (const child of children) {
        this._setInitialAttributesOnChild(child);
      }
    }
    _setInitialAttributesOnChild(child) {
      child = this._getInnerElement(child);
      const isActive = this._elemIsActive(child);
      const outerElem = this._getOuterElement(child);
      child.setAttribute("aria-selected", isActive);
      if (outerElem !== child) {
        this._setAttributeIfNotExists(outerElem, "role", "presentation");
      }
      if (!isActive) {
        child.setAttribute("tabindex", "-1");
      }
      this._setAttributeIfNotExists(child, "role", "tab");
      this._setInitialAttributesOnTargetPanel(child);
    }
    _setInitialAttributesOnTargetPanel(child) {
      const target = getElementFromSelector(child);
      if (!target) {
        return;
      }
      this._setAttributeIfNotExists(target, "role", "tabpanel");
      if (child.id) {
        this._setAttributeIfNotExists(target, "aria-labelledby", `#${child.id}`);
      }
    }
    _toggleDropDown(element, open) {
      const outerElem = this._getOuterElement(element);
      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
        return;
      }
      const toggle = (selector, className) => {
        const element2 = SelectorEngine.findOne(selector, outerElem);
        if (element2) {
          element2.classList.toggle(className, open);
        }
      };
      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
      outerElem.setAttribute("aria-expanded", open);
    }
    _setAttributeIfNotExists(element, attribute, value) {
      if (!element.hasAttribute(attribute)) {
        element.setAttribute(attribute, value);
      }
    }
    _elemIsActive(elem) {
      return elem.classList.contains(CLASS_NAME_ACTIVE);
    }
    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(elem) {
      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
    }
    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(elem) {
      return elem.closest(SELECTOR_OUTER) || elem;
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Tab.getOrCreateInstance(this);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    Tab.getOrCreateInstance(this).show();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
      Tab.getOrCreateInstance(element);
    }
  });
  defineJQueryPlugin(Tab);
  var NAME = "toast";
  var DATA_KEY = "bs.toast";
  var EVENT_KEY = `.${DATA_KEY}`;
  var EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
  var EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
  var EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
  var EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
  var EVENT_HIDE = `hide${EVENT_KEY}`;
  var EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  var EVENT_SHOW = `show${EVENT_KEY}`;
  var EVENT_SHOWN = `shown${EVENT_KEY}`;
  var CLASS_NAME_FADE = "fade";
  var CLASS_NAME_HIDE = "hide";
  var CLASS_NAME_SHOW = "show";
  var CLASS_NAME_SHOWING = "showing";
  var DefaultType = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  };
  var Default = {
    animation: true,
    autohide: true,
    delay: 5e3
  };
  var Toast = class extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._timeout = null;
      this._hasMouseInteraction = false;
      this._hasKeyboardInteraction = false;
      this._setListeners();
    }
    // Getters
    static get Default() {
      return Default;
    }
    static get DefaultType() {
      return DefaultType;
    }
    static get NAME() {
      return NAME;
    }
    // Public
    show() {
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._clearTimeout();
      if (this._config.animation) {
        this._element.classList.add(CLASS_NAME_FADE);
      }
      const complete = () => {
        this._element.classList.remove(CLASS_NAME_SHOWING);
        EventHandler.trigger(this._element, EVENT_SHOWN);
        this._maybeScheduleHide();
      };
      this._element.classList.remove(CLASS_NAME_HIDE);
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
      if (!this.isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const complete = () => {
        this._element.classList.add(CLASS_NAME_HIDE);
        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
        EventHandler.trigger(this._element, EVENT_HIDDEN);
      };
      this._element.classList.add(CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
      this._clearTimeout();
      if (this.isShown()) {
        this._element.classList.remove(CLASS_NAME_SHOW);
      }
      super.dispose();
    }
    isShown() {
      return this._element.classList.contains(CLASS_NAME_SHOW);
    }
    // Private
    _maybeScheduleHide() {
      if (!this._config.autohide) {
        return;
      }
      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
        return;
      }
      this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
      switch (event.type) {
        case "mouseover":
        case "mouseout": {
          this._hasMouseInteraction = isInteracting;
          break;
        }
        case "focusin":
        case "focusout": {
          this._hasKeyboardInteraction = isInteracting;
          break;
        }
      }
      if (isInteracting) {
        this._clearTimeout();
        return;
      }
      const nextElement = event.relatedTarget;
      if (this._element === nextElement || this._element.contains(nextElement)) {
        return;
      }
      this._maybeScheduleHide();
    }
    _setListeners() {
      EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
      EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
    }
    _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Toast.getOrCreateInstance(this, config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config](this);
        }
      });
    }
  };
  enableDismissTrigger(Toast);
  defineJQueryPlugin(Toast);

  // script.js
  var lines = /* @__PURE__ */ new Map([
    ["Bakerloo", "#B36305"],
    ["Central", "#E32017"],
    ["Circle", "#FFD300"],
    ["District", "#00782A"],
    ["Hammersmith & City", "#F3A9BB"],
    ["Jubilee", "#A0A5A9"],
    ["Metropolitan", "#9B0056"],
    ["Northern", "#000000"],
    ["Piccadilly", "#003688"],
    ["Victoria", "#0098D4"],
    ["Waterloo & City", "#95CDBA"],
    ["DLR", "#00A4A7"],
    ["London Overground", "#EE7C0E"],
    ["Tramlink", "#84B817"],
    ["Emirates Air Line", "#E21836"],
    ["Crossrail", "#7156A5"]
  ]);
  function addLine(name, colour, bheight) {
    map.addLayer({
      "filter": ["==", "line_name", name],
      "id": encodeURIComponent(name) + "-extruded",
      "type": "fill-extrusion",
      "source": "tubes",
      "paint": {
        "fill-extrusion-color": colour,
        "fill-extrusion-base": bheight,
        "fill-extrusion-height": bheight + 2,
        "fill-extrusion-height-transition": {
          duration: 1500,
          delay: 1e3
        },
        "fill-extrusion-opacity": 0.85
      }
    });
  }
  import_mapbox_gl.default.accessToken = "pk.eyJ1IjoidXJzY2hyZWkiLCJhIjoiY2pubHJsaGZjMWl1dzNrbzM3eDBuNzN3eiJ9.5xEWTiavcSRbv7LYZoAmUg";
  var map = new import_mapbox_gl.default.Map({
    container: "map",
    style: "mapbox://styles/mapbox/light-v9",
    zoom: 15.5,
    center: {
      lng: -0.11598344692356477,
      lat: 51.512726521488304
    },
    maxBounds: [{
      "lng": -0.5533749005341804,
      "lat": 51.31536873314653
    }, {
      "lng": 0.4214032710438005,
      "lat": 51.71445426713464
    }]
  });
  map.on("style.load", function() {
    map.addSource(
      "tubes",
      {
        type: "geojson",
        data: "static/tube_polygons.geojson"
      }
    );
    var bheight = 500;
    for (let [name, colour] of lines) {
      addLine(name, colour, bheight);
    }
    map.flyTo({
      bearing: Math.floor(Math.random() * (360 - 1 + 1)) + 1,
      pitch: Math.floor(Math.random() * (70 - 1 + 1)) + 50
    });
  });
  map.on("load", () => {
    for (let [name, colour] of lines) {
      document.getElementById("linelist").insertAdjacentHTML(
        "beforeend",
        `<button type="button" style="background-color: ${colour};"
                id="${encodeURIComponent(name)}" class="btn btn-outline-light active"
                aria-pressed="true"><span style="color: #f8f9fa;">${name}</span></button>`
      );
    }
    document.querySelectorAll(".btn:not(#share)").forEach(function(btn) {
      btn.onclick = function() {
        const bgcolour = btn.style.backgroundColor;
        if (map.getLayoutProperty(`${btn.id}-extruded`, "visibility") === "visible") {
          map.setLayoutProperty(`${btn.id}-extruded`, "visibility", "none");
          btn.style.backgroundColor = "#f8f9fa";
          btn.firstChild.style.color = bgcolour;
        } else {
          map.setLayoutProperty(btn.id + "-extruded", "visibility", "visible");
          btn.style.backgroundColor = lines.get(btn.textContent);
          btn.firstChild.style.color = "#f8f9fa";
        }
      };
    });
    const sharedbutton = document.getElementById("share");
    sharedbutton.onclick = function() {
      if (map.getLayer("share-extruded")) {
        map.removeLayer("share-extruded");
        for (let [name, colour] of lines) {
          map.setPaintProperty(`${encodeURIComponent(name)}-extruded`, "fill-extrusion-color", colour);
        }
      } else {
        for (let [name, colour] of lines) {
          map.setPaintProperty(`${encodeURIComponent(name)}-extruded`, "fill-extrusion-color", "#A0A5A9");
        }
        map.addLayer({
          "filter": ["==", "shared", true],
          "id": "share-extruded",
          "type": "fill-extrusion",
          "source": "tubes",
          "paint": {
            "fill-extrusion-color": "#ff1d8e",
            "fill-extrusion-base": 500,
            "fill-extrusion-height": 500 + 2,
            "fill-extrusion-height-transition": {
              duration: 1500,
              delay: 1e3
            },
            "fill-extrusion-opacity": 0.95
          }
        });
      }
    };
    setTimeout(function() {
      map.flyTo({
        zoom: 14,
        speed: 0.2,
        curve: 1
      });
    }, 3e3);
  });
})();
/*! Bundled license information:

mapbox-gl/dist/mapbox-gl.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

bootstrap/dist/js/bootstrap.esm.js:
  (*!
    * Bootstrap v5.2.3 (https://getbootstrap.com/)
    * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    *)
*/
